"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllbridgeCoreClientPoolInfoCaching = void 0;
const timed_cache_1 = __importDefault(require("timed-cache"));
const exceptions_1 = require("../../exceptions");
const core_api_mapper_1 = require("./core-api-mapper");
const _55_SECONDS_TTL = 55 * 1000;
class AllbridgeCoreClientPoolInfoCaching {
    client;
    poolInfoCache;
    constructor(client) {
        this.client = client;
        this.poolInfoCache = new PoolInfoCache();
    }
    async getChainDetailsMap() {
        const result = await this.client.getChainDetailsMapAndPoolInfoMap();
        return result.chainDetailsMap;
    }
    async tokens() {
        return await this.client.tokens();
    }
    getTransferStatus(chainSymbol, txId) {
        return this.client.getTransferStatus(chainSymbol, txId);
    }
    getReceiveTransactionCost(args) {
        return this.client.getReceiveTransactionCost(args);
    }
    getPendingInfo() {
        return this.client.getPendingInfo();
    }
    getGasBalance(chainSymbol, address) {
        return this.client.getGasBalance(chainSymbol, address);
    }
    async getPoolInfoByKey(poolKeyObject) {
        this.poolInfoCache.putAllIfNotExists((await this.client.getChainDetailsMapAndPoolInfoMap()).poolInfoMap);
        const poolInfo = this.poolInfoCache.get(poolKeyObject);
        if (poolInfo) {
            return poolInfo;
        }
        else {
            const poolInfoMap = await this.client.getPoolInfoMap(poolKeyObject);
            this.poolInfoCache.putAll(poolInfoMap);
            const result = poolInfoMap[(0, core_api_mapper_1.mapPoolKeyObjectToPoolKey)(poolKeyObject)];
            if (result) {
                return result;
            }
            throw new exceptions_1.SdkError("Cannot find pool info for " + poolKeyObject.poolAddress + " on chain " + poolKeyObject.chainSymbol);
        }
    }
    async refreshPoolInfo(poolKeyObjects) {
        let poolInfoMap;
        if (poolKeyObjects) {
            this.poolInfoCache.putAllIfNotExists((await this.client.getChainDetailsMapAndPoolInfoMap()).poolInfoMap);
            poolInfoMap = await this.client.getPoolInfoMap(poolKeyObjects);
        }
        else {
            const result = await this.client.getChainDetailsMapAndPoolInfoMap();
            poolInfoMap = await this.client.getPoolInfoMap((0, core_api_mapper_1.mapChainDetailsMapToPoolKeyObjects)(result.chainDetailsMap));
        }
        this.poolInfoCache.putAll(poolInfoMap);
    }
    cachePut(poolKeyObject, poolInfo) {
        this.poolInfoCache.put((0, core_api_mapper_1.mapPoolKeyObjectToPoolKey)(poolKeyObject), poolInfo);
    }
}
exports.AllbridgeCoreClientPoolInfoCaching = AllbridgeCoreClientPoolInfoCaching;
class PoolInfoCache {
    cache;
    constructor() {
        this.cache = new timed_cache_1.default({ defaultTtl: _55_SECONDS_TTL });
    }
    putAll(poolInfoMap) {
        for (const [key, value] of Object.entries(poolInfoMap)) {
            this.cache.put(key, value);
        }
    }
    putAllIfNotExists(poolInfoMap) {
        for (const [key, value] of Object.entries(poolInfoMap)) {
            if (!this.cache.get(key)) {
                this.cache.put(key, value);
            }
        }
    }
    put(key, poolInfo) {
        this.cache.put(key, poolInfo);
    }
    get(poolKeyObject) {
        const key = (0, core_api_mapper_1.mapPoolKeyObjectToPoolKey)(poolKeyObject);
        return this.cache.get(key);
    }
}
//# sourceMappingURL=core-client-pool-info-caching.js.map