import { BigSource } from "big.js";
import { AdditionalBasicChainProperties } from "./chains/models";
import { AmountFormat, AmountFormatted, AmountsAndGasFeeOptions, BridgeService, ChainDetailsMap, CheckAddressResponse, ExtraGasMaxLimitResponse, GasBalanceResponse, GasFeeOptions, GetNativeTokenBalanceParams, GetTokenBalanceParams, LiquidityPoolService, Messenger, PendingStatusInfoResponse, PoolInfo, Provider, SendAmountDetails, SwapAndBridgeCalculationData, TokenWithChainDetails, TransferStatusResponse } from "./models";
import { CctpParams } from "./services/bridge/sol";
import { Utils } from "./utils";
export * from "./configs";
export * from "./models";
export interface AllbridgeCoreSdkOptions {
    coreApiUrl: string;
    /**
     * A set of query parameters to be added to all requests to the Core API.
     */
    coreApiQueryParams?: Record<string, string>;
    /**
     * A set of headers to be added to all requests to the Core API.
     */
    coreApiHeaders?: Record<string, string>;
    /**
     * Jupiter Swap Api</br>
     * Default: https://lite-api.jup.ag/swap/v1</br>
     * {@link https://dev.jup.ag/docs/swap-api/}
     */
    jupiterUrl: string;
    /**
     * Jupiter Api Key Header</br>
     * {@link https://dev.jup.ag/docs/api-setup}
     */
    jupiterApiKeyHeader?: string;
    /**
     * Jupiter v6 'maxAccounts' parameter</br>
     * Rough estimate of the max accounts to be used for the quote, so that you can compose with your own accounts</br>
     * {@link https://station.jup.ag/docs/apis/swap-api#using-maxaccounts}
     */
    jupiterMaxAccounts?: number;
    wormholeMessengerProgramId: string;
    solanaLookUpTable: string;
    sorobanNetworkPassphrase: string;
    /**
     * Optional. Will be used in methods</br>
     * {@link LiquidityPoolService.getPoolInfoFromChain} and {@link LiquidityPoolService.getAmountToBeWithdrawn}</br>
     * to fetch information from the blockchain with fewer HTTP requests using JSON-RPC API
     */
    tronJsonRpc?: string;
    cctpParams: CctpParams;
    /**
     * The number of seconds that pool information taken from the chain will be cached.
     *
     * @type {number}
     */
    cachePoolInfoChainSec: number;
    /**
     * @internal
     * Optional additional properties to merge with the default properties.
     */
    additionalChainsProperties?: Record<string, AdditionalBasicChainProperties>;
}
/**
 * Type representing RPC node URLs for different blockchain chains.</br>
 * Provide node RPC URL for chain connection you intend to communicate with</br>
 * - required for SOL, TRX chains</br>
 * - optional for EVM chains -- you can interact by passing a {@link Provider} that will be used to communicate with the chain</br>
 * @typedef {Record<string, string>} NodeRpcUrls
 * @property {string} chainSymbol - The symbol of the chain representing one of the supported blockchain networks (e.g., "ETH" for Ethereum). For more details, see: {@link ChainSymbol}.
 * @property {string} rpcUrl - The RPC node URL for the specified chain.
 */
export type NodeRpcUrls = Record<string, string>;
/**
 * @deprecated Use {@link NodeRpcUrls}
 */
export interface NodeUrlsConfig {
    solanaRpcUrl: string;
    tronRpcUrl: string;
}
export declare class AllbridgeCoreSdk {
    readonly params: AllbridgeCoreSdkOptions;
    bridge: BridgeService;
    pool: LiquidityPoolService;
    utils: Utils;
    private service;
    /**
     * Initializes the SDK object.
     * @param nodeUrls node rpc urls for full functionality
     * @param params
     * Optional.
     * If not defined, the default {@link mainnet} parameters are used.
     */
    constructor(nodeUrls: NodeUrlsConfig | NodeRpcUrls, params?: AllbridgeCoreSdkOptions);
    /**
     * Returns {@link ChainDetailsMap} containing a list of supported tokens groped by chain.
     *
     * @param type - A string value which specifies ChainDetailsMap to retrieve.
     *               Can be either 'swap' for send or 'pool' for liquidity pools setup.
     *               Defaults to 'swap'.
     */
    chainDetailsMap(type?: "swap" | "pool"): Promise<ChainDetailsMap>;
    /**
     * Returns a list of supported {@link TokenWithChainDetails | tokens}.
     *
     * @param type - A string value which specifies a set of tokens to retrieve.
     *               Can be either 'swap' for tokens to send or 'pool' for liquidity pools operations.
     *               Defaults to 'swap'.
     * @returns A promise that resolves to an array of {@link TokenWithChainDetails}.
     */
    tokens(type?: "swap" | "pool"): Promise<TokenWithChainDetails[]>;
    /**
     * Returns a list of supported {@link TokenWithChainDetails | tokens} on the selected chain.
     * @param chainSymbol - The symbol of the chain representing one of the supported blockchain networks (e.g., "ETH" for Ethereum). For more details, see: {@link ChainSymbol}.
     * @param type - A string value which specifies a set of tokens to retrieve.
     *               Can be either 'swap' for tokens to send or 'pool' for liquidity pools operations.
     *               Defaults to 'swap'.
     */
    tokensByChain(chainSymbol: string, type?: "swap" | "pool"): Promise<TokenWithChainDetails[]>;
    /**
     * Fetches information about tokens transfer by chosen chainSymbol and transaction Id from the Allbridge Core API.
     * @param chainSymbol - The symbol of the chain representing one of the supported blockchain networks (e.g., "ETH" for Ethereum). For more details, see: {@link ChainSymbol}.
     * @param txId
     */
    getTransferStatus(chainSymbol: string, txId: string): Promise<TransferStatusResponse>;
    /**
     * Get gas balance
     * @param chainSymbol - The symbol of the chain representing one of the supported blockchain networks (e.g., "ETH" for Ethereum). For more details, see: {@link ChainSymbol}.
     * @param address
     */
    getGasBalance(chainSymbol: string, address: string): Promise<GasBalanceResponse>;
    /**
     * Check address and show gas balance
     * @deprecated
     * @param chainSymbol - The symbol of the chain representing one of the supported blockchain networks (e.g., "ETH" for Ethereum). For more details, see: {@link ChainSymbol}.
     * @param recipientAddress
     * @param tokenAddress
     */
    checkAddress(chainSymbol: string, recipientAddress: string, tokenAddress?: string): Promise<CheckAddressResponse>;
    /**
     * Returns information about pending transactions for the same destination chain and the amount of tokens can be received as a result of transfer considering pending transactions.
     * @param amount the amount of tokens that will be sent
     * @param amountFormat amount format
     * @param sourceToken selected token transfer from
     * @param destToken selected token transfer to
     * @returns range of possible amount based on already pending transactions
     */
    getPendingStatusInfo(amount: string, amountFormat: AmountFormat, sourceToken: TokenWithChainDetails, destToken: TokenWithChainDetails): Promise<PendingStatusInfoResponse>;
    /**
     * Get token balance
     * @param params
     * @param provider
     * @returns Token balance
     */
    getTokenBalance(params: GetTokenBalanceParams, provider?: Provider): Promise<string>;
    /**
     * Get native (gas) token balance
     * @param params
     * @param provider
     * @returns Token balance
     */
    getNativeTokenBalance(params: GetNativeTokenBalanceParams, provider?: Provider): Promise<AmountFormatted>;
    /**
     * @deprecated
     * Calculates the percentage of fee from the initial amount that is charged when swapping from the selected source chain.
     * (Does not include fee related to the destination chain. Does not include gas fee)
     * @param amountFloat initial amount of tokens to swap
     * @param sourceChainToken selected token on the source chain
     * @returns fee percent
     */
    calculateFeePercentOnSourceChain(amountFloat: BigSource, sourceChainToken: TokenWithChainDetails): Promise<number>;
    /**
     * @deprecated
     * Calculates the percentage of fee that is charged when swapping to the selected destination chain. The destination chain fee percent applies to the amount after the source chain fee.
     * (Does not include fee related to the source chain. Does not include gas fee)
     * @see {@link calculateFeePercentOnSourceChain}
     * @param amountFloat initial amount of tokens to swap
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @returns fee percent
     */
    calculateFeePercentOnDestinationChain(amountFloat: BigSource, sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails): Promise<number>;
    /**
     * Calculates the amount of tokens to be received as a result of transfer
     * and fetches {@link GasFeeOptions} which contains available ways to pay the gas fee.
     * @param amountToSendFloat the amount of tokens that will be sent
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger
     */
    getAmountToBeReceivedAndGasFeeOptions(amountToSendFloat: BigSource, sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, messenger: Messenger): Promise<AmountsAndGasFeeOptions>;
    /**
     * Calculates the amount of tokens to send based on requested tokens amount be received as a result of transfer.
     * and fetches {@link GasFeeOptions} which contains available ways to pay the gas fee.
     * @param amountToBeReceivedFloat the amount of tokens that should be received
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger
     */
    getAmountToSendAndGasFeeOptions(amountToBeReceivedFloat: BigSource, sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, messenger: Messenger): Promise<AmountsAndGasFeeOptions>;
    /**
     * Calculates the amount of tokens to be received as a result of transfer.
     * @param amountToSendFloat the amount of tokens that will be sent
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger Optional. selected messenger
     */
    getAmountToBeReceived(amountToSendFloat: BigSource, sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, 
    /**
     * The Messengers for different routes.
     * Optional.
     * The {@link Messenger.ALLBRIDGE}, {@link Messenger.WORMHOLE} by default.
     */
    messenger?: Messenger): Promise<string>;
    /**
     * Calculates the amount of tokens to be received as a result of transfer based on actual blockchain pool state.
     * @param amountToSendFloat the amount of tokens that will be sent
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger Optional. selected messenger
     * @param sourceProvider Optional. source chain Provider
     * @param destinationProvider Optional. destination chain Provider
     */
    getAmountToBeReceivedFromChain(amountToSendFloat: BigSource, sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, 
    /**
     * The Messengers for different routes.
     * Optional.
     * The {@link Messenger.ALLBRIDGE}, {@link Messenger.WORMHOLE} by default.
     */
    messenger?: Messenger, sourceProvider?: Provider, destinationProvider?: Provider): Promise<string>;
    /**
     * Calculates the amount of tokens to be received as a result of transfer based on passed pool state.
     * @param amountToSendFloat the amount of tokens that will be sent
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param sourcePool source token pool state
     * @param destinationPool destination token pool state
     * @param messenger Optional. selected messenger
     */
    getAmountToBeReceivedFromPools(amountToSendFloat: BigSource, sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, sourcePool: PoolInfo, destinationPool: PoolInfo, messenger?: Messenger): string;
    /**
     * Calculates the amount of tokens to send based on requested tokens amount be received as a result of transfer.
     * @param amountToBeReceivedFloat the amount of tokens that should be received
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger Optional. selected messenger
     */
    getAmountToSend(amountToBeReceivedFloat: BigSource, sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, 
    /**
     * The Messengers for different routes.
     * Optional.
     * The {@link Messenger.ALLBRIDGE}, {@link Messenger.WORMHOLE} by default.
     */
    messenger?: Messenger): Promise<string>;
    /**
     * Calculates the amount of tokens to send based on requested tokens amount be received as a result of transfer based on actual blockchain pool state.
     * @param amountToBeReceivedFloat the amount of tokens that should be received
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger Optional. selected messenger
     * @param sourceProvider Optional. source chain Provider
     * @param destinationProvider Optional. destination chain Provider
     */
    getAmountToSendFromChain(amountToBeReceivedFloat: BigSource, sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, 
    /**
     * The Messengers for different routes.
     * Optional.
     * The {@link Messenger.ALLBRIDGE}, {@link Messenger.WORMHOLE} by default.
     */
    messenger?: Messenger, sourceProvider?: Provider, destinationProvider?: Provider): Promise<string>;
    /**
     * Calculates the amount of tokens to send based on requested tokens amount be received as a result of transfer based on passed pool state.
     * @param amountToBeReceivedFloat the amount of tokens that should be received
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param sourcePool source token pool state
     * @param destinationPool destination token pool state
     * @param messenger Optional. selected messenger
     */
    getAmountToSendFromPools(amountToBeReceivedFloat: BigSource, sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, sourcePool: PoolInfo, destinationPool: PoolInfo, messenger?: Messenger): string;
    /**
     * Fetches possible ways to pay the transfer gas fee.
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger
     * @returns {@link GasFeeOptions}
     */
    getGasFeeOptions(sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, messenger: Messenger): Promise<GasFeeOptions>;
    /**
     * Gets the average time in ms to complete a transfer for given tokens and messenger.
     * @param sourceChainToken selected token on the source chain.
     * @param destinationChainToken selected token on the destination chain.
     * @param messenger
     * @returns Average transfer time in milliseconds or null if a given combination of tokens and messenger is not supported.
     */
    getAverageTransferTime(sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails, messenger: Messenger): number | null;
    /**
     * Gets information about the poolInfo by token
     * @param token
     * @returns poolInfo
     */
    getPoolInfoByToken(token: TokenWithChainDetails): Promise<PoolInfo>;
    /**
     * Forces refresh of cached information about the state of liquidity pools.
     * Outdated cache leads to calculated amounts being less accurate.
     * The cache is invalidated at regular intervals, but it can be forced to be refreshed by calling this method.+
     *
     * @param tokens if present, the corresponding liquidity pools will be updated
     */
    refreshPoolInfo(tokens?: TokenWithChainDetails | TokenWithChainDetails[]): Promise<void>;
    /**
     * Convert APR to percentage view
     * @param apr
     * @returns aprPercentageView
     */
    aprInPercents(apr: string): string;
    /**
     * Get possible limit of extra gas amount.
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @returns {@link ExtraGasMaxLimitResponse}
     */
    getExtraGasMaxLimits(sourceChainToken: TokenWithChainDetails, destinationChainToken: TokenWithChainDetails): Promise<ExtraGasMaxLimitResponse>;
    /**
     * @param amount - amount
     * @param amountFormat - AmountFormat
     * @param sourceToken - selected token on the source chain
     * @return virtual amount
     */
    getVUsdFromAmount(amount: string, amountFormat: AmountFormat, sourceToken: TokenWithChainDetails): Promise<AmountFormatted>;
    /**
     * @param vUsdAmount - amount of vUsd, int format
     * @param destToken selected token on the destination chain
     * @return amount of destToken
     */
    getAmountFromVUsd(vUsdAmount: string, destToken: TokenWithChainDetails): Promise<AmountFormatted>;
    /**
     * @deprecated Use {@link getSendAmountDetails}
     * @param amountInTokenPrecision
     * @param sourceToken
     * @param destToken
     */
    swapAndBridgeFeeCalculation(amountInTokenPrecision: string, sourceToken: TokenWithChainDetails, destToken: TokenWithChainDetails): Promise<SwapAndBridgeCalculationData>;
    /**
     * @deprecated Use {@link getAmountToBeReceived} and then {@link getSendAmountDetails}
     * @param amountInTokenPrecision
     * @param sourceToken
     * @param destToken
     */
    swapAndBridgeFeeCalculationReverse(amountInTokenPrecision: string, sourceToken: TokenWithChainDetails, destToken: TokenWithChainDetails): Promise<SwapAndBridgeCalculationData>;
    /**
     *  Show amount changes (fee and amount adjustment) during send through pools on source and destination chains
     */
    getSendAmountDetails(amount: string, amountFormat: AmountFormat, sourceToken: TokenWithChainDetails, destToken: TokenWithChainDetails): Promise<SendAmountDetails>;
}
