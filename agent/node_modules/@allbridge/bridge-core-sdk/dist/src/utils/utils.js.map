{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/utils/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Big, BigSource } from \"big.js\";\nimport { AllbridgeCoreClientPoolsExt } from \"../client/core-api/core-client-pool-info-caching\";\nimport { ArgumentInvalidDecimalsError, InvalidAmountError, TimeoutError } from \"../exceptions\";\nimport { PoolInfo, TokenWithChainDetails } from \"../tokens-info\";\n\nexport async function getPoolInfoByToken(\n  api: AllbridgeCoreClientPoolsExt,\n  sourceChainToken: TokenWithChainDetails\n): Promise<PoolInfo> {\n  return await api.getPoolInfoByKey({\n    chainSymbol: sourceChainToken.chainSymbol,\n    poolAddress: sourceChainToken.poolAddress,\n  });\n}\n\nexport function validateAmountGtZero(amount: BigSource) {\n  if (Big(amount).lte(0)) {\n    throw new InvalidAmountError(\"Amount must be greater than zero\");\n  }\n}\n\nexport function validateAmountDecimals(argName: string, amountFloat: number | string | Big, decimalRequired: number) {\n  const amount = Big(amountFloat).toFixed();\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [integerPart, fractionalPart] = amount.split(\".\");\n\n  if (fractionalPart && fractionalPart.length > decimalRequired) {\n    throw new ArgumentInvalidDecimalsError(argName, fractionalPart.length, decimalRequired);\n  }\n}\n\nexport async function promiseWithTimeout<T>(promise: Promise<T>, msg: string, timeoutMs: number): Promise<T> {\n  return (await Promise.race([\n    promise,\n    new Promise((resolve, reject) => {\n      setTimeout(() => reject(new TimeoutError(msg)), timeoutMs);\n    }),\n  ])) as any as T;\n}\n\nexport async function promiseWithTimeoutAndRetries<T>(\n  toTry: () => Promise<T>,\n  msg: string,\n  maxRetries: number,\n  timeoutMs: number\n): Promise<T> {\n  if (maxRetries < 1)\n    throw new Error(`Bad argument: 'maxRetries' must be greater than 0, but ${maxRetries} was received.`);\n  let attemptCount = 0;\n  while (true) {\n    try {\n      return await promiseWithTimeout(toTry(), msg, timeoutMs);\n    } catch (ignoreError) {\n      if (++attemptCount >= maxRetries) throw new TimeoutError(msg);\n    }\n  }\n}\n\n/**\n * Keep calling a `fn` for `secondsToWait` seconds, if `keepWaitingIf` is true.\n * Returns an array of all attempts to call the function.\n */\nexport async function withExponentialBackoff<T>(\n  fn: (previousFailure?: T) => Promise<T>,\n  keepWaitingIf: (result: T) => boolean,\n  secondsToWait: number,\n  exponentialFactor = 1.5,\n  verbose = false\n): Promise<T[]> {\n  const attempts: T[] = [];\n\n  let count = 0;\n  const initialAttempt = await fn();\n  attempts.push(initialAttempt);\n  if (!keepWaitingIf(initialAttempt)) return attempts;\n\n  const waitUntil = new Date(Date.now() + secondsToWait * 1000).valueOf();\n  let waitTime = 1000;\n  let totalWaitTime = waitTime;\n\n  while (Date.now() < waitUntil) {\n    const lastAttempt = attempts[attempts.length - 1];\n    if (lastAttempt === undefined || !keepWaitingIf(lastAttempt)) break;\n\n    count++;\n    // Wait a beat\n    if (verbose) {\n      console.info(\n        `Waiting ${waitTime}ms before trying again (bringing the total wait time to ${totalWaitTime}ms so far, of total ${\n          secondsToWait * 1000\n        }ms)`\n      );\n    }\n    await new Promise((res) => setTimeout(res, waitTime));\n    // Exponential backoff\n    waitTime = waitTime * exponentialFactor;\n    if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {\n      waitTime = waitUntil - Date.now();\n      if (verbose) {\n        console.info(`was gonna wait too long; new waitTime: ${waitTime}ms`);\n      }\n    }\n    totalWaitTime = waitTime + totalWaitTime;\n    // Try again\n    const nextAttempt = await fn(lastAttempt);\n    attempts.push(nextAttempt);\n    if (verbose && keepWaitingIf(nextAttempt)) {\n      console.info(\n        `${count}. Called ${fn.name}; ${attempts.length} prev attempts. Most recent: ${JSON.stringify(\n          attempts[attempts.length - 1],\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  return attempts;\n}\n"]}