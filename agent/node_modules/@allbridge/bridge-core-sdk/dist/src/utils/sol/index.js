"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultSolUtils = void 0;
const web3_js_1 = require("@solana/web3.js");
const chain_enums_1 = require("../../chains/chain.enums");
const index_1 = require("../../index");
const utils_1 = require("./utils");
class DefaultSolUtils {
    nodeRpcUrlsConfig;
    params;
    constructor(nodeRpcUrlsConfig, params) {
        this.nodeRpcUrlsConfig = nodeRpcUrlsConfig;
        this.params = params;
    }
    async addMemoToTx(transaction, memo) {
        if (memo.length > 28) {
            throw new index_1.SdkError("InvalidArgumentException memo cannot be more than 28 characters");
        }
        const connection = new web3_js_1.Connection(this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.SOL), "confirmed");
        const addressLookupTableAccounts = await (0, utils_1.fetchAddressLookupTableAccountsFromTx)(transaction, connection);
        const message = web3_js_1.TransactionMessage.decompile(transaction.message, {
            addressLookupTableAccounts: addressLookupTableAccounts,
        });
        const lastInstruction = message.instructions[message.instructions.length - 1];
        if (!lastInstruction?.keys) {
            throw new index_1.SdkError("Last instruction or its keys are invalid.");
        }
        lastInstruction.keys.push({
            pubkey: new web3_js_1.PublicKey(Buffer.from(memo)),
            isSigner: false,
            isWritable: false,
        });
        transaction.message = message.compileToV0Message(addressLookupTableAccounts);
    }
}
exports.DefaultSolUtils = DefaultSolUtils;
//# sourceMappingURL=index.js.map