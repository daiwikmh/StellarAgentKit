"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFeePercent = getFeePercent;
exports.toSystemPrecision = toSystemPrecision;
exports.fromSystemPrecision = fromSystemPrecision;
exports.convertAmountPrecision = convertAmountPrecision;
exports.toPowBase10 = toPowBase10;
exports.convertFloatAmountToInt = convertFloatAmountToInt;
exports.convertIntAmountToFloat = convertIntAmountToFloat;
exports.calculatePoolInfoImbalance = calculatePoolInfoImbalance;
exports.swapToVUsd = swapToVUsd;
exports.swapFromVUsd = swapFromVUsd;
exports.getSwapFromVUsdPoolInfo = getSwapFromVUsdPoolInfo;
exports.swapToVUsdReverse = swapToVUsdReverse;
exports.swapFromVUsdReverse = swapFromVUsdReverse;
exports.getY = getY;
exports.getEarned = getEarned;
exports.aprInPercents = aprInPercents;
exports.getD = getD;
const big_js_1 = require("big.js");
const bn_js_1 = __importDefault(require("bn.js"));
const exceptions_1 = require("../../exceptions");
const constants_1 = require("./constants");
function getFeePercent(input, output) {
    return (0, big_js_1.Big)(100).minus((0, big_js_1.Big)(100).times(output).div(input)).toNumber();
}
function toSystemPrecision(amount, decimals) {
    return convertAmountPrecision(amount, decimals, constants_1.SYSTEM_PRECISION).round(0, big_js_1.Big.roundDown);
}
function fromSystemPrecision(amount, decimals) {
    return convertAmountPrecision(amount, constants_1.SYSTEM_PRECISION, decimals);
}
function convertAmountPrecision(amount, decimalsFrom, decimalsTo) {
    const dif = (0, big_js_1.Big)(decimalsTo).minus(decimalsFrom).toNumber();
    return (0, big_js_1.Big)(amount).times(toPowBase10(dif));
}
function toPowBase10(decimals) {
    return (0, big_js_1.Big)(10).pow(decimals);
}
function convertFloatAmountToInt(amountFloat, decimals) {
    return (0, big_js_1.Big)(amountFloat).times(toPowBase10(decimals));
}
function convertIntAmountToFloat(amountInt, decimals) {
    const amountValue = (0, big_js_1.Big)(amountInt);
    if (amountValue.eq(0)) {
        return (0, big_js_1.Big)(0);
    }
    return (0, big_js_1.Big)(amountValue).div(toPowBase10(decimals));
}
function calculatePoolInfoImbalance(poolInfo) {
    return convertIntAmountToFloat((0, big_js_1.Big)(poolInfo.tokenBalance).minus(poolInfo.vUsdBalance).toFixed(), constants_1.SYSTEM_PRECISION)
        .div(2)
        .toFixed();
}
function swapToVUsd(amount, { feeShare, decimals }, poolInfo) {
    const amountValue = (0, big_js_1.Big)(amount);
    if (amountValue.lte(0)) {
        return "0";
    }
    const fee = amountValue.times(feeShare);
    const amountWithoutFee = amountValue.minus(fee);
    const inSystemPrecision = toSystemPrecision(amountWithoutFee, decimals);
    const tokenBalance = (0, big_js_1.Big)(poolInfo.tokenBalance).plus(inSystemPrecision);
    const vUsdNewAmount = getY(tokenBalance, poolInfo.aValue, poolInfo.dValue);
    return (0, big_js_1.Big)(poolInfo.vUsdBalance).minus(vUsdNewAmount).round(0, big_js_1.Big.roundDown).toFixed();
}
function swapFromVUsd(amount, { feeShare, decimals }, poolInfo) {
    const amountValue = (0, big_js_1.Big)(amount);
    if (amountValue.lte(0)) {
        return (0, big_js_1.Big)(0).toFixed();
    }
    const vUsdBalance = amountValue.plus(poolInfo.vUsdBalance);
    const newAmount = getY(vUsdBalance, poolInfo.aValue, poolInfo.dValue);
    const result = fromSystemPrecision((0, big_js_1.Big)(poolInfo.tokenBalance).minus(newAmount), decimals);
    const fee = (0, big_js_1.Big)(result).times(feeShare);
    return (0, big_js_1.Big)(result).minus(fee).round(0, big_js_1.Big.roundDown).toFixed();
}
function getSwapFromVUsdPoolInfo(vUsdAmount, poolInfo) {
    const amountValue = (0, big_js_1.Big)(vUsdAmount);
    if (amountValue.lte(0)) {
        return poolInfo;
    }
    const vUsdBalance = amountValue.plus(poolInfo.vUsdBalance);
    const newAmount = getY(vUsdBalance, poolInfo.aValue, poolInfo.dValue);
    return {
        aValue: poolInfo.aValue,
        dValue: poolInfo.dValue,
        tokenBalance: newAmount.toFixed(0),
        vUsdBalance: vUsdBalance.toFixed(0),
    };
}
/**
 * @param amount - vUsd amount should be received
 * @param feeShare
 * @param decimals
 * @param poolInfo
 */
function swapToVUsdReverse(amount, { feeShare, decimals }, poolInfo) {
    if ((0, big_js_1.Big)(amount).lte(0)) {
        return (0, big_js_1.Big)(0);
    }
    const vUsdNewAmount = (0, big_js_1.Big)(poolInfo.vUsdBalance).minus(amount);
    if (vUsdNewAmount.lte(0)) {
        throw new exceptions_1.InsufficientPoolLiquidityError();
    }
    const tokenBalance = getY(vUsdNewAmount, poolInfo.aValue, poolInfo.dValue);
    const inSystemPrecision = (0, big_js_1.Big)(tokenBalance).minus(poolInfo.tokenBalance);
    const amountWithoutFee = fromSystemPrecision(inSystemPrecision, decimals);
    const reversedFeeShare = (0, big_js_1.Big)(feeShare).div((0, big_js_1.Big)(1).minus(feeShare));
    const fee = (0, big_js_1.Big)(amountWithoutFee).times(reversedFeeShare).round(0, big_js_1.Big.roundUp);
    return (0, big_js_1.Big)(amountWithoutFee).plus(fee).round(0, big_js_1.Big.roundDown);
}
/**
 * @param amount - amount should be received
 * @param feeShare
 * @param decimals
 * @param poolInfo
 */
function swapFromVUsdReverse(amount, { feeShare, decimals }, poolInfo) {
    if ((0, big_js_1.Big)(amount).lte(0)) {
        return (0, big_js_1.Big)(0);
    }
    const reversedFeeShare = (0, big_js_1.Big)(feeShare).div((0, big_js_1.Big)(1).minus(feeShare));
    const fee = (0, big_js_1.Big)(amount).times(reversedFeeShare).round(0, big_js_1.Big.roundUp);
    const amountWithFee = (0, big_js_1.Big)(amount).plus(fee);
    const inSystemPrecision = toSystemPrecision(amountWithFee, decimals);
    const tokenBalance = (0, big_js_1.Big)(poolInfo.tokenBalance).minus(inSystemPrecision);
    if (tokenBalance.lte(0)) {
        throw new exceptions_1.InsufficientPoolLiquidityError();
    }
    const vUsdNewAmount = getY(tokenBalance, poolInfo.aValue, poolInfo.dValue);
    return (0, big_js_1.Big)(vUsdNewAmount).minus(poolInfo.vUsdBalance).round(0, big_js_1.Big.roundDown);
}
// y = (sqrt(x(4ad³ + x (4a(d - x) - d )²)) + x (4a(d - x) - d ))/8ax
// commonPart = 4a(d - x) - d
// sqrt = sqrt(x * (4ad³ + x * commonPart²)
// y =   (sqrt + x * commonPart) / divider
function getY(x, a, d) {
    const commonPartBig = (0, big_js_1.Big)(4).times(a).times((0, big_js_1.Big)(d).minus(x)).minus(d);
    const dCubed = (0, big_js_1.Big)(d).pow(3);
    const commonPartSquared = commonPartBig.pow(2);
    const sqrtBig = (0, big_js_1.Big)(x)
        .times((0, big_js_1.Big)(x).times(commonPartSquared).plus((0, big_js_1.Big)(4).times(a).times(dCubed)))
        .sqrt()
        .round(0, big_js_1.Big.roundDown);
    const dividerBig = (0, big_js_1.Big)(8).times(a).times(x);
    const result = commonPartBig.times(x).plus(sqrtBig).div(dividerBig).round(0, big_js_1.Big.roundDown);
    if (result.eq(0)) {
        return (0, big_js_1.Big)(0);
    }
    return result.plus(1); // +1 to offset rounding errors
}
function getEarned(userLpAmount, userRewardDebt, accRewardPerShareP, p) {
    const userLpAmountBN = new bn_js_1.default(userLpAmount);
    const accRewardPerSharePBN = new bn_js_1.default(accRewardPerShareP);
    const userRewardDebtBN = new bn_js_1.default(userRewardDebt);
    const rewards = userLpAmountBN.mul(accRewardPerSharePBN).shrn(p);
    return rewards.sub(userRewardDebtBN).toString();
}
function aprInPercents(apr) {
    return (0, big_js_1.Big)(apr).gt(0) ? `${Number((0, big_js_1.Big)(apr).times(100).toFixed(2)).toLocaleString()}%` : "N/A";
}
// a = 8Axy(x+y)
// b = xy(16A - 4) / 3
// c = sqrt(a² + b³)
// D = cbrt(a + c) + cbrt(a - c)
function getD(aValue, x, y) {
    const xy = (0, big_js_1.Big)(x).times(y);
    const xPlusY = (0, big_js_1.Big)(x).plus(y);
    const a = (0, big_js_1.Big)(8).times(aValue).times(xy).times(xPlusY);
    const b = xy.times((0, big_js_1.Big)(16).times(aValue).minus(4)).div(3);
    const aSquared = a.times(a);
    const bCubed = b.times(b).times(b);
    const a2b3 = aSquared.plus(bCubed);
    const c = (0, big_js_1.Big)(a2b3).sqrt();
    const cbrtAPlusC = (0, big_js_1.Big)(Math.cbrt(+a.plus(c).toFixed()));
    const cbrtAMinusC = (0, big_js_1.Big)(Math.cbrt(+a.minus(c).toFixed()));
    return cbrtAPlusC.plus(cbrtAMinusC).toFixed();
}
//# sourceMappingURL=index.js.map