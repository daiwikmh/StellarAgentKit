"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultSrbUtils = void 0;
const stellar_sdk_1 = require("@stellar/stellar-sdk");
const chain_enums_1 = require("../../chains/chain.enums");
const index_1 = require("../../index");
const token_contract_1 = require("../../services/models/srb/token-contract");
const utils_1 = require("../../services/models/srb/utils");
const utils_2 = require("../utils");
const FEE = 100;
const SEND_TRANSACTION_TIMEOUT = 180;
class DefaultSrbUtils {
    nodeRpcUrlsConfig;
    params;
    constructor(nodeRpcUrlsConfig, params) {
        this.nodeRpcUrlsConfig = nodeRpcUrlsConfig;
        this.params = params;
    }
    async buildChangeTrustLineXdrTx(params) {
        const stellar = new stellar_sdk_1.Horizon.Server(this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.STLR));
        const stellarAccount = await stellar.loadAccount(params.sender);
        const tokenContract = this.getContract(token_contract_1.TokenContract, params.tokenAddress);
        const result = await tokenContract.name();
        if ((0, utils_1.isErrorSorobanResult)(result)) {
            throw new index_1.SdkError();
        }
        const tokenName = (0, utils_1.getViewResultSoroban)(result);
        if (!tokenName) {
            throw new index_1.SdkError();
        }
        const [symbol, srbTokenAddress] = tokenName.split(":");
        if (symbol === undefined || srbTokenAddress === undefined) {
            throw new index_1.SdkError(`Invalid token name format. Expected format 'symbol:srbTokenAddress'`);
        }
        const asset = new stellar_sdk_1.Asset(symbol, srbTokenAddress);
        const changeTrust = stellar_sdk_1.Operation.changeTrust({
            asset: asset,
            limit: params.limit,
        });
        return new stellar_sdk_1.TransactionBuilder(stellarAccount, {
            fee: FEE.toString(10),
            networkPassphrase: this.params.sorobanNetworkPassphrase,
        })
            .addOperation(changeTrust)
            .setTimeout(SEND_TRANSACTION_TIMEOUT)
            .build()
            .toXDR();
    }
    async getBalanceLine(sender, tokenAddress) {
        const tokenContract = this.getContract(token_contract_1.TokenContract, tokenAddress);
        const result = await tokenContract.name();
        if ((0, utils_1.isErrorSorobanResult)(result)) {
            throw new index_1.SdkError();
        }
        const tokenName = (0, utils_1.getViewResultSoroban)(result);
        if (!tokenName) {
            throw new index_1.SdkError();
        }
        const [symbol, srbTokenAddress] = tokenName.split(":");
        const nodeRpcUrl = this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.STLR);
        const stellar = new stellar_sdk_1.Horizon.Server(nodeRpcUrl);
        const stellarAccount = await stellar.loadAccount(sender);
        const balanceInfo = stellarAccount.balances;
        return balanceInfo.find((balance) => (balance.asset_type === "credit_alphanum4" || balance.asset_type === "credit_alphanum12") &&
            balance.asset_code == symbol &&
            balance.asset_issuer == srbTokenAddress);
    }
    async submitTransactionStellar(xdrTx) {
        const stellar = new stellar_sdk_1.Horizon.Server(this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.STLR));
        const transaction = stellar_sdk_1.TransactionBuilder.fromXDR(xdrTx, this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.STLR));
        return await stellar.submitTransaction(transaction);
    }
    async simulateAndCheckRestoreTxRequiredSoroban(xdrTx, sourceAccount) {
        const server = new stellar_sdk_1.rpc.Server(this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.SRB));
        const account = await server.getAccount(sourceAccount);
        const transaction = stellar_sdk_1.TransactionBuilder.fromXDR(xdrTx, this.params.sorobanNetworkPassphrase);
        const simulation = await server.simulateTransaction(transaction);
        if (stellar_sdk_1.rpc.Api.isSimulationRestore(simulation)) {
            return new stellar_sdk_1.TransactionBuilder(account, {
                fee: (+stellar_sdk_1.BASE_FEE + +simulation.restorePreamble.minResourceFee).toString(),
                networkPassphrase: this.params.sorobanNetworkPassphrase,
            })
                .setSorobanData(simulation.restorePreamble.transactionData.build())
                .addOperation(stellar_sdk_1.Operation.restoreFootprint({}))
                .setTimeout(stellar_sdk_1.TimeoutInfinite)
                .build()
                .toXDR();
        }
        return undefined;
    }
    async sendTransactionSoroban(xdrTx) {
        const server = new stellar_sdk_1.rpc.Server(this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.SRB));
        const transaction = stellar_sdk_1.TransactionBuilder.fromXDR(xdrTx, this.params.sorobanNetworkPassphrase);
        return server.sendTransaction(transaction);
    }
    async confirmTx(hash, secondsToWait = 15) {
        const server = new stellar_sdk_1.rpc.Server(this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.SRB));
        const getTransactionResponseAll = await (0, utils_2.withExponentialBackoff)(() => server.getTransaction(hash), (resp) => resp.status === stellar_sdk_1.rpc.Api.GetTransactionStatus.NOT_FOUND, secondsToWait);
        if (getTransactionResponseAll.length === 0) {
            throw new index_1.SdkError("No transaction responses found.");
        }
        const lastResponse = getTransactionResponseAll[getTransactionResponseAll.length - 1];
        if (!lastResponse) {
            throw new index_1.SdkError("Unexpected error: last response is undefined.");
        }
        return lastResponse;
    }
    getContract(contract, address) {
        const config = {
            contractId: address,
            networkPassphrase: this.params.sorobanNetworkPassphrase,
            rpcUrl: this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.SRB),
        };
        return new contract(config);
    }
}
exports.DefaultSrbUtils = DefaultSrbUtils;
//# sourceMappingURL=index.js.map