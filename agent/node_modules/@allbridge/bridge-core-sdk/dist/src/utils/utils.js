"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPoolInfoByToken = getPoolInfoByToken;
exports.validateAmountGtZero = validateAmountGtZero;
exports.validateAmountDecimals = validateAmountDecimals;
exports.promiseWithTimeout = promiseWithTimeout;
exports.promiseWithTimeoutAndRetries = promiseWithTimeoutAndRetries;
exports.withExponentialBackoff = withExponentialBackoff;
const big_js_1 = require("big.js");
const exceptions_1 = require("../exceptions");
async function getPoolInfoByToken(api, sourceChainToken) {
    return await api.getPoolInfoByKey({
        chainSymbol: sourceChainToken.chainSymbol,
        poolAddress: sourceChainToken.poolAddress,
    });
}
function validateAmountGtZero(amount) {
    if ((0, big_js_1.Big)(amount).lte(0)) {
        throw new exceptions_1.InvalidAmountError("Amount must be greater than zero");
    }
}
function validateAmountDecimals(argName, amountFloat, decimalRequired) {
    const amount = (0, big_js_1.Big)(amountFloat).toFixed();
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const [integerPart, fractionalPart] = amount.split(".");
    if (fractionalPart && fractionalPart.length > decimalRequired) {
        throw new exceptions_1.ArgumentInvalidDecimalsError(argName, fractionalPart.length, decimalRequired);
    }
}
async function promiseWithTimeout(promise, msg, timeoutMs) {
    return (await Promise.race([
        promise,
        new Promise((resolve, reject) => {
            setTimeout(() => reject(new exceptions_1.TimeoutError(msg)), timeoutMs);
        }),
    ]));
}
async function promiseWithTimeoutAndRetries(toTry, msg, maxRetries, timeoutMs) {
    if (maxRetries < 1)
        throw new Error(`Bad argument: 'maxRetries' must be greater than 0, but ${maxRetries} was received.`);
    let attemptCount = 0;
    while (true) {
        try {
            return await promiseWithTimeout(toTry(), msg, timeoutMs);
        }
        catch (ignoreError) {
            if (++attemptCount >= maxRetries)
                throw new exceptions_1.TimeoutError(msg);
        }
    }
}
/**
 * Keep calling a `fn` for `secondsToWait` seconds, if `keepWaitingIf` is true.
 * Returns an array of all attempts to call the function.
 */
async function withExponentialBackoff(fn, keepWaitingIf, secondsToWait, exponentialFactor = 1.5, verbose = false) {
    const attempts = [];
    let count = 0;
    const initialAttempt = await fn();
    attempts.push(initialAttempt);
    if (!keepWaitingIf(initialAttempt))
        return attempts;
    const waitUntil = new Date(Date.now() + secondsToWait * 1000).valueOf();
    let waitTime = 1000;
    let totalWaitTime = waitTime;
    while (Date.now() < waitUntil) {
        const lastAttempt = attempts[attempts.length - 1];
        if (lastAttempt === undefined || !keepWaitingIf(lastAttempt))
            break;
        count++;
        // Wait a beat
        if (verbose) {
            console.info(`Waiting ${waitTime}ms before trying again (bringing the total wait time to ${totalWaitTime}ms so far, of total ${secondsToWait * 1000}ms)`);
        }
        await new Promise((res) => setTimeout(res, waitTime));
        // Exponential backoff
        waitTime = waitTime * exponentialFactor;
        if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {
            waitTime = waitUntil - Date.now();
            if (verbose) {
                console.info(`was gonna wait too long; new waitTime: ${waitTime}ms`);
            }
        }
        totalWaitTime = waitTime + totalWaitTime;
        // Try again
        const nextAttempt = await fn(lastAttempt);
        attempts.push(nextAttempt);
        if (verbose && keepWaitingIf(nextAttempt)) {
            console.info(`${count}. Called ${fn.name}; ${attempts.length} prev attempts. Most recent: ${JSON.stringify(attempts[attempts.length - 1], null, 2)}`);
        }
    }
    return attempts;
}
//# sourceMappingURL=utils.js.map