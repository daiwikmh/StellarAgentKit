"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllbridgeCoreSdk = void 0;
const configs_1 = require("./configs");
const services_1 = require("./services");
const utils_1 = require("./utils");
__exportStar(require("./configs"), exports);
__exportStar(require("./models"), exports);
/**
 * @deprecated Use {@link NodeRpcUrls}
 */
function isNodeUrlsConfig(nodeUrls) {
    return "solanaRpcUrl" in nodeUrls;
}
class AllbridgeCoreSdk {
    params;
    bridge;
    pool;
    utils;
    service;
    /**
     * Initializes the SDK object.
     * @param nodeUrls node rpc urls for full functionality
     * @param params
     * Optional.
     * If not defined, the default {@link mainnet} parameters are used.
     */
    constructor(nodeUrls, params = configs_1.mainnet) {
        let nodeRpcUrlsConfig;
        if (isNodeUrlsConfig(nodeUrls)) {
            nodeRpcUrlsConfig = new services_1.NodeRpcUrlsConfig({ SOL: nodeUrls.solanaRpcUrl, TRX: nodeUrls.tronRpcUrl });
        }
        else {
            nodeRpcUrlsConfig = new services_1.NodeRpcUrlsConfig(nodeUrls);
        }
        this.service = new services_1.AllbridgeCoreSdkService(nodeRpcUrlsConfig, params);
        this.bridge = this.service.bridge;
        this.pool = this.service.pool;
        this.utils = new utils_1.DefaultUtils(nodeRpcUrlsConfig, params);
        this.params = params;
    }
    /**
     * Returns {@link ChainDetailsMap} containing a list of supported tokens groped by chain.
     *
     * @param type - A string value which specifies ChainDetailsMap to retrieve.
     *               Can be either 'swap' for send or 'pool' for liquidity pools setup.
     *               Defaults to 'swap'.
     */
    async chainDetailsMap(type = "swap") {
        return this.service.chainDetailsMap(type);
    }
    /**
     * Returns a list of supported {@link TokenWithChainDetails | tokens}.
     *
     * @param type - A string value which specifies a set of tokens to retrieve.
     *               Can be either 'swap' for tokens to send or 'pool' for liquidity pools operations.
     *               Defaults to 'swap'.
     * @returns A promise that resolves to an array of {@link TokenWithChainDetails}.
     */
    async tokens(type = "swap") {
        return this.service.tokens(type);
    }
    /**
     * Returns a list of supported {@link TokenWithChainDetails | tokens} on the selected chain.
     * @param chainSymbol - The symbol of the chain representing one of the supported blockchain networks (e.g., "ETH" for Ethereum). For more details, see: {@link ChainSymbol}.
     * @param type - A string value which specifies a set of tokens to retrieve.
     *               Can be either 'swap' for tokens to send or 'pool' for liquidity pools operations.
     *               Defaults to 'swap'.
     */
    async tokensByChain(chainSymbol, type = "swap") {
        return this.service.tokensByChain(chainSymbol, type);
    }
    /**
     * Fetches information about tokens transfer by chosen chainSymbol and transaction Id from the Allbridge Core API.
     * @param chainSymbol - The symbol of the chain representing one of the supported blockchain networks (e.g., "ETH" for Ethereum). For more details, see: {@link ChainSymbol}.
     * @param txId
     */
    async getTransferStatus(chainSymbol, txId) {
        return this.service.getTransferStatus(chainSymbol, txId);
    }
    /**
     * Get gas balance
     * @param chainSymbol - The symbol of the chain representing one of the supported blockchain networks (e.g., "ETH" for Ethereum). For more details, see: {@link ChainSymbol}.
     * @param address
     */
    async getGasBalance(chainSymbol, address) {
        return this.service.getGasBalance(chainSymbol, address);
    }
    /**
     * Check address and show gas balance
     * @deprecated
     * @param chainSymbol - The symbol of the chain representing one of the supported blockchain networks (e.g., "ETH" for Ethereum). For more details, see: {@link ChainSymbol}.
     * @param recipientAddress
     * @param tokenAddress
     */
    async checkAddress(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    chainSymbol, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    recipientAddress, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    tokenAddress) {
        return await this.service.checkAddress();
    }
    /**
     * Returns information about pending transactions for the same destination chain and the amount of tokens can be received as a result of transfer considering pending transactions.
     * @param amount the amount of tokens that will be sent
     * @param amountFormat amount format
     * @param sourceToken selected token transfer from
     * @param destToken selected token transfer to
     * @returns range of possible amount based on already pending transactions
     */
    async getPendingStatusInfo(amount, amountFormat, sourceToken, destToken) {
        return this.service.getPendingStatusInfo(amount, amountFormat, sourceToken, destToken);
    }
    /**
     * Get token balance
     * @param params
     * @param provider
     * @returns Token balance
     */
    async getTokenBalance(params, provider) {
        return this.service.getTokenBalance(params, provider);
    }
    /**
     * Get native (gas) token balance
     * @param params
     * @param provider
     * @returns Token balance
     */
    async getNativeTokenBalance(params, provider) {
        return this.service.getNativeTokenBalance(params, provider);
    }
    /**
     * @deprecated
     * Calculates the percentage of fee from the initial amount that is charged when swapping from the selected source chain.
     * (Does not include fee related to the destination chain. Does not include gas fee)
     * @param amountFloat initial amount of tokens to swap
     * @param sourceChainToken selected token on the source chain
     * @returns fee percent
     */
    async calculateFeePercentOnSourceChain(amountFloat, sourceChainToken) {
        return this.service.calculateFeePercentOnSourceChain(amountFloat, sourceChainToken);
    }
    /**
     * @deprecated
     * Calculates the percentage of fee that is charged when swapping to the selected destination chain. The destination chain fee percent applies to the amount after the source chain fee.
     * (Does not include fee related to the source chain. Does not include gas fee)
     * @see {@link calculateFeePercentOnSourceChain}
     * @param amountFloat initial amount of tokens to swap
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @returns fee percent
     */
    async calculateFeePercentOnDestinationChain(amountFloat, sourceChainToken, destinationChainToken) {
        return this.service.calculateFeePercentOnDestinationChain(amountFloat, sourceChainToken, destinationChainToken);
    }
    /**
     * Calculates the amount of tokens to be received as a result of transfer
     * and fetches {@link GasFeeOptions} which contains available ways to pay the gas fee.
     * @param amountToSendFloat the amount of tokens that will be sent
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger
     */
    async getAmountToBeReceivedAndGasFeeOptions(amountToSendFloat, sourceChainToken, destinationChainToken, messenger) {
        return this.service.getAmountToBeReceivedAndGasFeeOptions(amountToSendFloat, sourceChainToken, destinationChainToken, messenger);
    }
    /**
     * Calculates the amount of tokens to send based on requested tokens amount be received as a result of transfer.
     * and fetches {@link GasFeeOptions} which contains available ways to pay the gas fee.
     * @param amountToBeReceivedFloat the amount of tokens that should be received
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger
     */
    async getAmountToSendAndGasFeeOptions(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, messenger) {
        return this.service.getAmountToSendAndGasFeeOptions(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, messenger);
    }
    /**
     * Calculates the amount of tokens to be received as a result of transfer.
     * @param amountToSendFloat the amount of tokens that will be sent
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger Optional. selected messenger
     */
    async getAmountToBeReceived(amountToSendFloat, sourceChainToken, destinationChainToken, 
    /**
     * The Messengers for different routes.
     * Optional.
     * The {@link Messenger.ALLBRIDGE}, {@link Messenger.WORMHOLE} by default.
     */
    messenger) {
        return this.service.getAmountToBeReceived(amountToSendFloat, sourceChainToken, destinationChainToken, messenger);
    }
    /**
     * Calculates the amount of tokens to be received as a result of transfer based on actual blockchain pool state.
     * @param amountToSendFloat the amount of tokens that will be sent
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger Optional. selected messenger
     * @param sourceProvider Optional. source chain Provider
     * @param destinationProvider Optional. destination chain Provider
     */
    async getAmountToBeReceivedFromChain(amountToSendFloat, sourceChainToken, destinationChainToken, 
    /**
     * The Messengers for different routes.
     * Optional.
     * The {@link Messenger.ALLBRIDGE}, {@link Messenger.WORMHOLE} by default.
     */
    messenger, sourceProvider, destinationProvider) {
        return this.service.getAmountToBeReceivedFromChain(amountToSendFloat, sourceChainToken, destinationChainToken, messenger, sourceProvider, destinationProvider);
    }
    /**
     * Calculates the amount of tokens to be received as a result of transfer based on passed pool state.
     * @param amountToSendFloat the amount of tokens that will be sent
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param sourcePool source token pool state
     * @param destinationPool destination token pool state
     * @param messenger Optional. selected messenger
     */
    getAmountToBeReceivedFromPools(amountToSendFloat, sourceChainToken, destinationChainToken, sourcePool, destinationPool, messenger) {
        return this.service.getAmountToBeReceivedFromPools(amountToSendFloat, sourceChainToken, destinationChainToken, sourcePool, destinationPool, messenger);
    }
    /**
     * Calculates the amount of tokens to send based on requested tokens amount be received as a result of transfer.
     * @param amountToBeReceivedFloat the amount of tokens that should be received
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger Optional. selected messenger
     */
    async getAmountToSend(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, 
    /**
     * The Messengers for different routes.
     * Optional.
     * The {@link Messenger.ALLBRIDGE}, {@link Messenger.WORMHOLE} by default.
     */
    messenger) {
        return this.service.getAmountToSend(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, messenger);
    }
    /**
     * Calculates the amount of tokens to send based on requested tokens amount be received as a result of transfer based on actual blockchain pool state.
     * @param amountToBeReceivedFloat the amount of tokens that should be received
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger Optional. selected messenger
     * @param sourceProvider Optional. source chain Provider
     * @param destinationProvider Optional. destination chain Provider
     */
    async getAmountToSendFromChain(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, 
    /**
     * The Messengers for different routes.
     * Optional.
     * The {@link Messenger.ALLBRIDGE}, {@link Messenger.WORMHOLE} by default.
     */
    messenger, sourceProvider, destinationProvider) {
        return this.service.getAmountToSendFromChain(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, messenger, sourceProvider, destinationProvider);
    }
    /**
     * Calculates the amount of tokens to send based on requested tokens amount be received as a result of transfer based on passed pool state.
     * @param amountToBeReceivedFloat the amount of tokens that should be received
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param sourcePool source token pool state
     * @param destinationPool destination token pool state
     * @param messenger Optional. selected messenger
     */
    getAmountToSendFromPools(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, sourcePool, destinationPool, messenger) {
        return this.service.getAmountToSendFromPools(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, sourcePool, destinationPool, messenger);
    }
    /**
     * Fetches possible ways to pay the transfer gas fee.
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @param messenger
     * @returns {@link GasFeeOptions}
     */
    async getGasFeeOptions(sourceChainToken, destinationChainToken, messenger) {
        return this.service.getGasFeeOptions(sourceChainToken, destinationChainToken, messenger);
    }
    /**
     * Gets the average time in ms to complete a transfer for given tokens and messenger.
     * @param sourceChainToken selected token on the source chain.
     * @param destinationChainToken selected token on the destination chain.
     * @param messenger
     * @returns Average transfer time in milliseconds or null if a given combination of tokens and messenger is not supported.
     */
    getAverageTransferTime(sourceChainToken, destinationChainToken, messenger) {
        return this.service.getAverageTransferTime(sourceChainToken, destinationChainToken, messenger);
    }
    /**
     * Gets information about the poolInfo by token
     * @param token
     * @returns poolInfo
     */
    async getPoolInfoByToken(token) {
        return this.service.getPoolInfoByToken(token);
    }
    /**
     * Forces refresh of cached information about the state of liquidity pools.
     * Outdated cache leads to calculated amounts being less accurate.
     * The cache is invalidated at regular intervals, but it can be forced to be refreshed by calling this method.+
     *
     * @param tokens if present, the corresponding liquidity pools will be updated
     */
    async refreshPoolInfo(tokens) {
        return this.service.refreshPoolInfo(tokens);
    }
    /**
     * Convert APR to percentage view
     * @param apr
     * @returns aprPercentageView
     */
    aprInPercents(apr) {
        return this.service.aprInPercents(apr);
    }
    /**
     * Get possible limit of extra gas amount.
     * @param sourceChainToken selected token on the source chain
     * @param destinationChainToken selected token on the destination chain
     * @returns {@link ExtraGasMaxLimitResponse}
     */
    async getExtraGasMaxLimits(sourceChainToken, destinationChainToken) {
        return this.service.getExtraGasMaxLimits(sourceChainToken, destinationChainToken);
    }
    /**
     * @param amount - amount
     * @param amountFormat - AmountFormat
     * @param sourceToken - selected token on the source chain
     * @return virtual amount
     */
    async getVUsdFromAmount(amount, amountFormat, sourceToken) {
        return this.service.getVUsdFromAmount(amount, amountFormat, sourceToken);
    }
    /**
     * @param vUsdAmount - amount of vUsd, int format
     * @param destToken selected token on the destination chain
     * @return amount of destToken
     */
    async getAmountFromVUsd(vUsdAmount, destToken) {
        return this.service.getAmountFromVUsd(vUsdAmount, destToken);
    }
    /**
     * @deprecated Use {@link getSendAmountDetails}
     * @param amountInTokenPrecision
     * @param sourceToken
     * @param destToken
     */
    async swapAndBridgeFeeCalculation(amountInTokenPrecision, sourceToken, destToken) {
        return this.service.swapAndBridgeFeeCalculation(amountInTokenPrecision, sourceToken, destToken);
    }
    /**
     * @deprecated Use {@link getAmountToBeReceived} and then {@link getSendAmountDetails}
     * @param amountInTokenPrecision
     * @param sourceToken
     * @param destToken
     */
    async swapAndBridgeFeeCalculationReverse(amountInTokenPrecision, sourceToken, destToken) {
        return this.service.swapAndBridgeFeeCalculationReverse(amountInTokenPrecision, sourceToken, destToken);
    }
    /**
     *  Show amount changes (fee and amount adjustment) during send through pools on source and destination chains
     */
    async getSendAmountDetails(amount, amountFormat, sourceToken, destToken) {
        return this.service.getSendAmountDetails(amount, amountFormat, sourceToken, destToken);
    }
}
exports.AllbridgeCoreSdk = AllbridgeCoreSdk;
//# sourceMappingURL=index.js.map