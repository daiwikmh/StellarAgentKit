"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatAddress = formatAddress;
exports.normalizeSuiHex = normalizeSuiHex;
exports.hexToBuffer = hexToBuffer;
exports.evmAddressToBuffer32 = evmAddressToBuffer32;
exports.tronAddressToBuffer32 = tronAddressToBuffer32;
exports.tronAddressToEthAddress = tronAddressToEthAddress;
exports.getTokenByTokenAddress = getTokenByTokenAddress;
exports.getNonce = getNonce;
exports.getNonceBigInt = getNonceBigInt;
exports.prepareTxSwapParams = prepareTxSwapParams;
exports.prepareTxSendParams = prepareTxSendParams;
exports.getGasFeeOptions = getGasFeeOptions;
exports.getExtraGasMaxLimits = getExtraGasMaxLimits;
exports.isSendParams = isSendParams;
const web3_js_1 = require("@solana/web3.js");
const stellar_sdk_1 = require("@stellar/stellar-sdk");
const big_js_1 = require("big.js");
const randombytes_1 = __importDefault(require("randombytes"));
const tronweb_1 = require("tronweb");
const chains_1 = require("../../chains");
const core_api_model_1 = require("../../client/core-api/core-api.model");
const exceptions_1 = require("../../exceptions");
const models_1 = require("../../models");
const calculation_1 = require("../../utils/calculation");
// 2. COMMON Realization
function formatAddress(address, from, to) {
    let buffer;
    switch (from) {
        case models_1.ChainType.EVM: {
            buffer = evmAddressToBuffer32(address);
            break;
        }
        case models_1.ChainType.SOLANA: {
            buffer = new web3_js_1.PublicKey(address).toBuffer();
            break;
        }
        case models_1.ChainType.TRX: {
            buffer = tronAddressToBuffer32(address);
            break;
        }
        case models_1.ChainType.SRB: {
            buffer = new stellar_sdk_1.Address(address).toBuffer();
            break;
        }
        case models_1.ChainType.SUI: {
            buffer = evmAddressToBuffer32(address);
            break;
        }
    }
    switch (to) {
        case models_1.ChainType.EVM: {
            return "0x" + buffer.toString("hex");
        }
        case models_1.ChainType.SOLANA: {
            return Array.from(buffer);
        }
        case models_1.ChainType.TRX: {
            return buffer;
        }
        case models_1.ChainType.SRB: {
            return buffer.toJSON().data;
        }
        case models_1.ChainType.SUI: {
            return "0x" + buffer.toString("hex");
        }
    }
}
function normalizeSuiHex(hex) {
    return hex.replace(/^0x/i, "");
}
function hexToBuffer(hex) {
    return Buffer.from(hex.replace(/^0x/i, ""), "hex");
}
function evmAddressToBuffer32(address) {
    const length = 32;
    const buff = hexToBuffer(address);
    return Buffer.concat([Buffer.alloc(length - buff.length, 0), buff], length);
}
function tronAddressToBuffer32(address) {
    const ethAddress = tronAddressToEthAddress(address);
    const buffer = hexToBuffer(ethAddress);
    return bufferToSize(buffer, 32);
}
function tronAddressToEthAddress(address) {
    const bytes = tronweb_1.utils.crypto.decodeBase58Address(address);
    if (!bytes)
        return "";
    return tronweb_1.utils.bytes.byteArray2hexStr(bytes).replace(/^41/, "0x");
}
function bufferToSize(buffer, size) {
    if (buffer.length >= size) {
        return buffer;
    }
    const result = Buffer.alloc(size, 0);
    buffer.copy(result, size - buffer.length);
    return result;
}
function getTokenByTokenAddress(chainDetailsMap, chainSymbol, tokenAddress) {
    const chainDetail = chainDetailsMap[chainSymbol];
    if (!chainDetail) {
        throw new exceptions_1.SdkError("Cannot find chain detail for " + chainSymbol);
    }
    const token = chainDetail.tokens.find((value) => value.tokenAddress.toUpperCase() === tokenAddress.toUpperCase());
    if (!token) {
        throw new exceptions_1.SdkError("Cannot find token info about token " + tokenAddress + " on chain " + chainSymbol);
    }
    return token;
}
function getNonce() {
    return (0, randombytes_1.default)(32);
}
function getNonceBigInt() {
    const bigint = (0, randombytes_1.default)(32).readBigInt64BE();
    if (bigint < 0) {
        return bigint * -1n;
    }
    return bigint;
}
// 2. COMMON Realization
function prepareTxSwapParams(bridgeChainType, params) {
    const txSwapParams = {};
    const sourceToken = params.sourceToken;
    txSwapParams.amount = (0, calculation_1.convertFloatAmountToInt)(params.amount, sourceToken.decimals).toFixed();
    txSwapParams.contractAddress = sourceToken.bridgeAddress;
    txSwapParams.fromAccountAddress = params.fromAccountAddress;
    if (bridgeChainType === models_1.ChainType.SUI) {
        if (!sourceToken.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI sourceToken must contain 'originTokenAddress'");
        }
        txSwapParams.fromTokenAddress = sourceToken.originTokenAddress;
    }
    else {
        txSwapParams.fromTokenAddress = formatAddress(sourceToken.tokenAddress, bridgeChainType, bridgeChainType);
    }
    txSwapParams.toAccountAddress = params.toAccountAddress;
    if (bridgeChainType === models_1.ChainType.SUI) {
        if (!params.destinationToken.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI destinationToken must contain 'originTokenAddress'");
        }
        txSwapParams.toTokenAddress = params.destinationToken.originTokenAddress;
    }
    else {
        txSwapParams.toTokenAddress = formatAddress(params.destinationToken.tokenAddress, bridgeChainType, bridgeChainType);
    }
    txSwapParams.minimumReceiveAmount = params.minimumReceiveAmount
        ? (0, calculation_1.convertFloatAmountToInt)(params.minimumReceiveAmount, params.destinationToken.decimals).toFixed()
        : "0";
    return txSwapParams;
}
// 2. COMMON Realization
async function prepareTxSendParams(bridgeChainType, params, api) {
    const txSendParams = {};
    txSendParams.fromChainId = params.sourceToken.allbridgeChainId;
    txSendParams.fromChainSymbol = params.sourceToken.chainSymbol;
    const toChainType = chains_1.Chains.getChainProperty(params.destinationToken.chainSymbol).chainType;
    if (bridgeChainType === models_1.ChainType.SUI) {
        if (!params.sourceToken.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI token must contain 'originTokenAddress'");
        }
        txSendParams.fromTokenAddress = params.sourceToken.originTokenAddress;
    }
    else {
        txSendParams.fromTokenAddress = params.sourceToken.tokenAddress;
    }
    txSendParams.toChainId = params.destinationToken.allbridgeChainId;
    txSendParams.toTokenAddress = params.destinationToken.tokenAddress;
    if (params.gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
        txSendParams.gasFeePaymentMethod = models_1.FeePaymentMethod.WITH_STABLECOIN;
    }
    else {
        // default FeePaymentMethod.WITH_NATIVE_CURRENCY
        txSendParams.gasFeePaymentMethod = models_1.FeePaymentMethod.WITH_NATIVE_CURRENCY;
    }
    const sourceToken = params.sourceToken;
    if (params.messenger === core_api_model_1.Messenger.CCTP) {
        if (!sourceToken.cctpAddress || !params.destinationToken.cctpAddress) {
            throw new exceptions_1.CCTPDoesNotSupportedError("Such route does not support CCTP protocol");
        }
        txSendParams.contractAddress = sourceToken.cctpAddress;
    }
    else if (params.messenger === core_api_model_1.Messenger.CCTP_V2) {
        if (!sourceToken.cctpV2Address || !params.destinationToken.cctpV2Address) {
            throw new exceptions_1.CCTPDoesNotSupportedError("Such route does not support CCTP V2 protocol");
        }
        txSendParams.contractAddress = sourceToken.cctpV2Address;
    }
    else {
        txSendParams.contractAddress = sourceToken.bridgeAddress;
    }
    txSendParams.messenger = params.messenger;
    txSendParams.fromAccountAddress = params.fromAccountAddress;
    txSendParams.amount = (0, calculation_1.convertFloatAmountToInt)(params.amount, sourceToken.decimals).toFixed();
    //Fee
    let { fee, feeFormat } = params;
    if (!fee) {
        const gasFeeOptions = await getGasFeeOptions(txSendParams.fromChainId, params.sourceToken.chainType, txSendParams.toChainId, sourceToken.decimals, txSendParams.messenger, api);
        const gasFeeOption = gasFeeOptions[txSendParams.gasFeePaymentMethod];
        if (!gasFeeOption) {
            throw new exceptions_1.InvalidGasFeePaymentOptionError();
        }
        fee = gasFeeOption[models_1.AmountFormat.INT];
        feeFormat = models_1.AmountFormat.INT;
    }
    if (feeFormat == models_1.AmountFormat.FLOAT) {
        switch (txSendParams.gasFeePaymentMethod) {
            case models_1.FeePaymentMethod.WITH_NATIVE_CURRENCY:
                txSendParams.fee = (0, calculation_1.convertFloatAmountToInt)(fee, chains_1.Chains.getChainDecimalsByType(sourceToken.chainType)).toFixed(0);
                break;
            case models_1.FeePaymentMethod.WITH_STABLECOIN:
                txSendParams.fee = (0, calculation_1.convertFloatAmountToInt)(fee, sourceToken.decimals).toFixed(0);
                break;
        }
    }
    else {
        txSendParams.fee = fee;
    }
    //ExtraGas
    const { extraGas, extraGasFormat } = params;
    if (extraGas && +extraGas > 0) {
        if (extraGasFormat == models_1.AmountFormat.FLOAT) {
            switch (txSendParams.gasFeePaymentMethod) {
                case models_1.FeePaymentMethod.WITH_NATIVE_CURRENCY:
                    txSendParams.extraGas = (0, calculation_1.convertFloatAmountToInt)(extraGas, chains_1.Chains.getChainDecimalsByType(sourceToken.chainType)).toFixed(0);
                    break;
                case models_1.FeePaymentMethod.WITH_STABLECOIN:
                    txSendParams.extraGas = (0, calculation_1.convertFloatAmountToInt)(extraGas, sourceToken.decimals).toFixed(0);
                    break;
            }
        }
        else {
            txSendParams.extraGas = extraGas;
        }
        await validateExtraGasNotExceeded(txSendParams.extraGas, txSendParams.gasFeePaymentMethod, sourceToken, params.destinationToken, api);
    }
    if (bridgeChainType !== models_1.ChainType.SUI) {
        txSendParams.fromTokenAddress = formatAddress(txSendParams.fromTokenAddress, bridgeChainType, bridgeChainType);
    }
    txSendParams.toAccountAddress = formatAddress(params.toAccountAddress, toChainType, bridgeChainType);
    txSendParams.toTokenAddress = formatAddress(txSendParams.toTokenAddress, toChainType, bridgeChainType);
    if (txSendParams.gasFeePaymentMethod == models_1.FeePaymentMethod.WITH_STABLECOIN) {
        validateAmountEnough(txSendParams.amount, sourceToken.decimals, txSendParams.fee, txSendParams.extraGas);
    }
    return txSendParams;
}
function validateAmountEnough(amountInt, decimals, feeInt, extraGasInt) {
    const amountTotal = (0, big_js_1.Big)(amountInt)
        .minus(feeInt)
        .minus(extraGasInt ?? 0);
    if (amountTotal.lte(0)) {
        throw new exceptions_1.AmountNotEnoughError(`Amount not enough to pay fee, ${(0, calculation_1.convertIntAmountToFloat)((0, big_js_1.Big)(amountTotal).minus(1).neg(), decimals).toFixed()} stables is missing`);
    }
}
async function getGasFeeOptions(sourceAllbridgeChainId, sourceChainType, destinationAllbridgeChainId, sourceChainTokenDecimals, messenger, api) {
    const transactionCostResponse = await api.getReceiveTransactionCost({
        sourceChainId: sourceAllbridgeChainId,
        destinationChainId: destinationAllbridgeChainId,
        messenger,
    });
    const gasFeeOptions = {
        [models_1.FeePaymentMethod.WITH_NATIVE_CURRENCY]: {
            [models_1.AmountFormat.INT]: transactionCostResponse.fee,
            [models_1.AmountFormat.FLOAT]: (0, calculation_1.convertIntAmountToFloat)(transactionCostResponse.fee, chains_1.Chains.getChainDecimalsByType(sourceChainType)).toFixed(),
        },
    };
    if (transactionCostResponse.sourceNativeTokenPrice) {
        const gasFeeIntWithStables = (0, calculation_1.convertAmountPrecision)(new big_js_1.Big(transactionCostResponse.fee).mul(transactionCostResponse.sourceNativeTokenPrice), chains_1.Chains.getChainDecimalsByType(sourceChainType), sourceChainTokenDecimals).toFixed(0, big_js_1.Big.roundUp);
        gasFeeOptions[models_1.FeePaymentMethod.WITH_STABLECOIN] = {
            [models_1.AmountFormat.INT]: gasFeeIntWithStables,
            [models_1.AmountFormat.FLOAT]: (0, calculation_1.convertIntAmountToFloat)(gasFeeIntWithStables, sourceChainTokenDecimals).toFixed(),
        };
    }
    return gasFeeOptions;
}
async function validateExtraGasNotExceeded(extraGasInt, gasFeePaymentMethod, sourceToken, destinationToken, api) {
    const extraGasLimits = await getExtraGasMaxLimits(sourceToken, destinationToken, api);
    const extraGasMaxLimit = extraGasLimits.extraGasMax[gasFeePaymentMethod];
    if (!extraGasMaxLimit) {
        throw new exceptions_1.InvalidGasFeePaymentOptionError(`Impossible to pay extra gas by '${gasFeePaymentMethod}' payment method`);
    }
    const extraGasMaxIntLimit = extraGasMaxLimit[models_1.AmountFormat.INT];
    if ((0, big_js_1.Big)(extraGasInt).gt(extraGasMaxIntLimit)) {
        throw new exceptions_1.ExtraGasMaxLimitExceededError(`Extra gas ${extraGasInt} in int format, exceeded limit ${extraGasMaxIntLimit} for '${gasFeePaymentMethod}' payment method`);
    }
}
async function getExtraGasMaxLimits(sourceChainToken, destinationChainToken, api) {
    const extraGasMaxLimits = {};
    const transactionCostResponse = await api.getReceiveTransactionCost({
        sourceChainId: sourceChainToken.allbridgeChainId,
        destinationChainId: destinationChainToken.allbridgeChainId,
        messenger: core_api_model_1.Messenger.ALLBRIDGE,
    });
    const maxAmount = destinationChainToken.txCostAmount.maxAmount;
    const maxAmountFloat = (0, calculation_1.convertIntAmountToFloat)(maxAmount, chains_1.Chains.getChainDecimalsByType(destinationChainToken.chainType)).toFixed();
    const maxAmountFloatInSourceNative = (0, big_js_1.Big)(maxAmountFloat)
        .div(transactionCostResponse.exchangeRate)
        .toFixed(chains_1.Chains.getChainDecimalsByType(sourceChainToken.chainType), big_js_1.Big.roundDown);
    const maxAmountInSourceNative = (0, calculation_1.convertFloatAmountToInt)(maxAmountFloatInSourceNative, chains_1.Chains.getChainDecimalsByType(sourceChainToken.chainType)).toFixed(0);
    extraGasMaxLimits[models_1.FeePaymentMethod.WITH_NATIVE_CURRENCY] = {
        [models_1.AmountFormat.INT]: maxAmountInSourceNative,
        [models_1.AmountFormat.FLOAT]: maxAmountFloatInSourceNative,
    };
    if (transactionCostResponse.sourceNativeTokenPrice) {
        const maxAmountFloatInStable = (0, big_js_1.Big)(maxAmountFloatInSourceNative)
            .mul(transactionCostResponse.sourceNativeTokenPrice)
            .toFixed(sourceChainToken.decimals, big_js_1.Big.roundDown);
        extraGasMaxLimits[models_1.FeePaymentMethod.WITH_STABLECOIN] = {
            [models_1.AmountFormat.INT]: (0, calculation_1.convertFloatAmountToInt)(maxAmountFloatInStable, sourceChainToken.decimals).toFixed(0),
            [models_1.AmountFormat.FLOAT]: maxAmountFloatInStable,
        };
    }
    return {
        extraGasMax: extraGasMaxLimits,
        destinationChain: {
            gasAmountMax: {
                [models_1.AmountFormat.INT]: maxAmount,
                [models_1.AmountFormat.FLOAT]: maxAmountFloat,
            },
            swap: {
                [models_1.AmountFormat.INT]: destinationChainToken.txCostAmount.swap,
                [models_1.AmountFormat.FLOAT]: (0, calculation_1.convertIntAmountToFloat)(destinationChainToken.txCostAmount.swap, chains_1.Chains.getChainDecimalsByType(destinationChainToken.chainType)).toFixed(),
            },
            transfer: {
                [models_1.AmountFormat.INT]: destinationChainToken.txCostAmount.transfer,
                [models_1.AmountFormat.FLOAT]: (0, calculation_1.convertIntAmountToFloat)(destinationChainToken.txCostAmount.transfer, chains_1.Chains.getChainDecimalsByType(destinationChainToken.chainType)).toFixed(),
            },
        },
        exchangeRate: transactionCostResponse.exchangeRate,
        sourceNativeTokenPrice: transactionCostResponse.sourceNativeTokenPrice,
    };
}
function isSendParams(params) {
    return params.sourceToken.chainSymbol !== params.destinationToken.chainSymbol;
}
//# sourceMappingURL=utils.js.map