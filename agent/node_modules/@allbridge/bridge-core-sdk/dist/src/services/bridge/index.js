"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultBridgeService = void 0;
exports.getSpender = getSpender;
exports.getChainBridgeService = getChainBridgeService;
const tronweb_1 = require("tronweb");
const web3_1 = require("web3");
const chains_1 = require("../../chains");
const core_api_model_1 = require("../../client/core-api/core-api.model");
const exceptions_1 = require("../../exceptions");
const index_1 = require("../../index");
const utils_1 = require("../../utils/utils");
const evm_1 = require("./evm");
const raw_bridge_transaction_builder_1 = require("./raw-bridge-transaction-builder");
const sol_1 = require("./sol");
const srb_1 = require("./srb");
const sui_1 = require("./sui");
const trx_1 = require("./trx");
class DefaultBridgeService {
    api;
    nodeRpcUrlsConfig;
    params;
    tokenService;
    rawTxBuilder;
    constructor(api, nodeRpcUrlsConfig, params, tokenService) {
        this.api = api;
        this.nodeRpcUrlsConfig = nodeRpcUrlsConfig;
        this.params = params;
        this.tokenService = tokenService;
        this.rawTxBuilder = new raw_bridge_transaction_builder_1.DefaultRawBridgeTransactionBuilder(api, nodeRpcUrlsConfig, params, tokenService);
    }
    async getAllowance(a, b) {
        let provider;
        let params;
        if (b) {
            provider = a;
            params = b;
        }
        else {
            params = a;
        }
        const spender = getSpender(params.token, params.messenger);
        return await this.tokenService.getAllowance({ ...params, spender }, provider);
    }
    async checkAllowance(a, b) {
        let provider;
        let params;
        if (b) {
            provider = a;
            params = b;
        }
        else {
            params = a;
        }
        const spender = getSpender(params.token, params.messenger);
        return this.tokenService.checkAllowance({ ...params, spender }, provider);
    }
    async approve(provider, approveData) {
        const spender = getSpender(approveData.token, approveData.messenger);
        return this.tokenService.approve(provider, { ...approveData, spender });
    }
    async send(provider, params) {
        (0, utils_1.validateAmountGtZero)(params.amount);
        (0, utils_1.validateAmountDecimals)("amount", params.amount, params.sourceToken.decimals);
        return getChainBridgeService(params.sourceToken.chainSymbol, this.api, this.nodeRpcUrlsConfig, this.params, provider).send(params);
    }
}
exports.DefaultBridgeService = DefaultBridgeService;
function getSpender(token, messenger) {
    if (messenger && messenger == core_api_model_1.Messenger.CCTP) {
        if (token.cctpAddress) {
            return token.cctpAddress;
        }
        else {
            throw new exceptions_1.CCTPDoesNotSupportedError("Such route does not support CCTP protocol");
        }
    }
    else if (messenger && messenger == core_api_model_1.Messenger.CCTP_V2) {
        if (token.cctpV2Address) {
            return token.cctpV2Address;
        }
        else {
            throw new exceptions_1.CCTPDoesNotSupportedError("Such route does not support CCTP V2 protocol");
        }
    }
    else {
        return token.bridgeAddress;
    }
}
function getChainBridgeService(chainSymbol, api, nodeRpcUrlsConfig, params, provider) {
    switch (chains_1.Chains.getChainProperty(chainSymbol).chainType) {
        case index_1.ChainType.EVM: {
            if (provider) {
                return new evm_1.EvmBridgeService(provider, api, nodeRpcUrlsConfig);
            }
            else {
                const nodeRpcUrl = nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol);
                return new evm_1.EvmBridgeService(new web3_1.Web3(nodeRpcUrl), api, nodeRpcUrlsConfig);
            }
        }
        case index_1.ChainType.TRX: {
            if (provider) {
                return new trx_1.TronBridgeService(provider, api);
            }
            else {
                const nodeRpcUrl = nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol);
                return new trx_1.TronBridgeService(new tronweb_1.TronWeb({
                    fullHost: nodeRpcUrl,
                    solidityNode: nodeRpcUrl,
                    eventServer: nodeRpcUrl,
                }), api);
            }
        }
        case index_1.ChainType.SOLANA: {
            return new sol_1.SolanaBridgeService(nodeRpcUrlsConfig.getNodeRpcUrl(index_1.ChainSymbol.SOL), {
                wormholeMessengerProgramId: params.wormholeMessengerProgramId,
                solanaLookUpTable: params.solanaLookUpTable,
                cctpParams: params.cctpParams,
                jupiterParams: {
                    jupiterUrl: params.jupiterUrl,
                    jupiterApiKeyHeader: params.jupiterApiKeyHeader,
                    jupiterMaxAccounts: params.jupiterMaxAccounts,
                },
            }, api);
        }
        case index_1.ChainType.SRB: {
            return new srb_1.SrbBridgeService(nodeRpcUrlsConfig, params, api);
        }
        case index_1.ChainType.SUI: {
            return new sui_1.SuiBridgeService(nodeRpcUrlsConfig, api);
        }
    }
}
//# sourceMappingURL=index.js.map