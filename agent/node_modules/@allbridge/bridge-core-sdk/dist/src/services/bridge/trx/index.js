"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TronBridgeService = void 0;
const big_js_1 = require("big.js");
const chain_enums_1 = require("../../../chains/chain.enums");
const exceptions_1 = require("../../../exceptions");
const models_1 = require("../../../models");
const trx_1 = require("../../utils/trx");
const bridge_1 = require("../models/bridge");
const utils_1 = require("../utils");
class TronBridgeService extends bridge_1.ChainBridgeService {
    tronWeb;
    api;
    chainType = chain_enums_1.ChainType.TRX;
    constructor(tronWeb, api) {
        super();
        this.tronWeb = tronWeb;
        this.api = api;
    }
    async send(params) {
        const txSendParams = await (0, utils_1.prepareTxSendParams)(this.chainType, params, this.api);
        const rawTransaction = await this.buildRawTransactionSendFromParams(txSendParams);
        return await (0, trx_1.sendRawTransaction)(this.tronWeb, rawTransaction);
    }
    async buildRawTransactionSwap(params) {
        const txSwapParams = (0, utils_1.prepareTxSwapParams)(this.chainType, params);
        return await this.buildRawTransactionSwapFromParams(txSwapParams);
    }
    async buildRawTransactionSwapFromParams(params) {
        const { amount, contractAddress, fromAccountAddress, fromTokenAddress, toAccountAddress, toTokenAddress, minimumReceiveAmount, } = params;
        const parameters = [
            { type: "uint256", value: amount },
            { type: "bytes32", value: fromTokenAddress },
            { type: "bytes32", value: toTokenAddress },
            { type: "address", value: toAccountAddress },
            { type: "uint256", value: minimumReceiveAmount },
        ];
        const methodSignature = "swap(uint256,bytes32,bytes32,address,uint256)";
        return this.buildRawTransaction(contractAddress, methodSignature, parameters, "0", fromAccountAddress);
    }
    async buildRawTransactionSend(params) {
        const txSendParams = await (0, utils_1.prepareTxSendParams)(this.chainType, params, this.api);
        return this.buildRawTransactionSendFromParams(txSendParams);
    }
    async buildRawTransactionSendFromParams(params) {
        const { amount, contractAddress, fromAccountAddress, fromTokenAddress, toChainId, toAccountAddress, toTokenAddress, messenger, fee, gasFeePaymentMethod, extraGas, } = params;
        let totalFee = fee;
        if (extraGas) {
            totalFee = (0, big_js_1.Big)(totalFee).plus(extraGas).toFixed();
        }
        const nonce = (0, utils_1.getNonceBigInt)().toString();
        let parameters;
        let value;
        let methodSignature;
        if (messenger == models_1.Messenger.CCTP || messenger == models_1.Messenger.CCTP_V2) {
            if (gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
                parameters = [
                    { type: "uint256", value: amount },
                    { type: "bytes32", value: toAccountAddress },
                    { type: "uint256", value: toChainId },
                    { type: "uint256", value: totalFee },
                ];
                value = "0";
            }
            else {
                parameters = [
                    { type: "uint256", value: amount },
                    { type: "bytes32", value: toAccountAddress },
                    { type: "uint256", value: toChainId },
                    { type: "uint256", value: 0 },
                ];
                value = totalFee;
            }
            methodSignature = "bridge(uint256,bytes32,uint256,uint256)";
        }
        else {
            if (gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
                parameters = [
                    { type: "bytes32", value: fromTokenAddress },
                    { type: "uint256", value: amount },
                    { type: "bytes32", value: toAccountAddress },
                    { type: "uint256", value: toChainId },
                    { type: "bytes32", value: toTokenAddress },
                    { type: "uint256", value: nonce },
                    { type: "uint8", value: messenger },
                    { type: "uint256", value: totalFee },
                ];
                value = "0";
            }
            else {
                parameters = [
                    { type: "bytes32", value: fromTokenAddress },
                    { type: "uint256", value: amount },
                    { type: "bytes32", value: toAccountAddress },
                    { type: "uint256", value: toChainId },
                    { type: "bytes32", value: toTokenAddress },
                    { type: "uint256", value: nonce },
                    { type: "uint8", value: messenger },
                    { type: "uint256", value: 0 },
                ];
                value = totalFee;
            }
            methodSignature = "swapAndBridge(bytes32,uint256,bytes32,uint256,bytes32,uint256,uint8,uint256)";
        }
        return this.buildRawTransaction(contractAddress, methodSignature, parameters, value, fromAccountAddress);
    }
    async buildRawTransaction(contractAddress, methodSignature, parameters, value, fromAddress) {
        const transactionObject = await this.tronWeb.transactionBuilder.triggerSmartContract(contractAddress, methodSignature, {
            callValue: +value,
        }, parameters, fromAddress);
        if (!transactionObject?.result?.result) {
            throw new exceptions_1.SdkError("Unknown error: " + JSON.stringify(transactionObject, null, 2));
        }
        return transactionObject.transaction;
    }
}
exports.TronBridgeService = TronBridgeService;
//# sourceMappingURL=index.js.map