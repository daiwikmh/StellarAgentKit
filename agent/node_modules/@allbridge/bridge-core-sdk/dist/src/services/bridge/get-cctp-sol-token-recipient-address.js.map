{"version":3,"file":"get-cctp-sol-token-recipient-address.js","sourceRoot":"","sources":["../../../../src/services/bridge/get-cctp-sol-token-recipient-address.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,0EAiCC;AApED,8DAAgD;AAChD,6CAA4C;AAC5C,0DAAqD;AACrD,iDAA4C;AAC5C,oDAA6D;AAC7D,kEAAmE;AACnE,mCAAwC;AA4BxC,wBAAwB;AACjB,KAAK,UAAU,+BAA+B,CACnD,SAAoB,EACpB,gBAAwB,EACxB,uBAA+B,EAC/B,SAAiB;IAEjB,IAAI,sBAAkD,CAAC;IACvD,MAAM,eAAe,GAAG,IAAI,mBAAS,CAAC,gBAAgB,CAAC,CAAC;IACxD,MAAM,WAAW,GAAG,IAAI,mBAAS,CAAC,uBAAuB,CAAC,CAAC;IAC3D,MAAM,gBAAgB,GAAG,MAAM,IAAA,+BAAoB,EAAC,eAAe,EAAE,WAAW,CAAC,CAAC;IAClF,MAAM,QAAQ,GAAG,IAAA,qCAAmB,EAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;IAClE,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IAC7B,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,gBAAgB,CAAC,CAAC;IACnG,IAAI,WAAW,EAAE,SAAS,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE,CAAC;QACnD,sBAAsB,GAAG,IAAA,qBAAa,EAAC,gBAAgB,CAAC,QAAQ,EAAE,EAAE,uBAAS,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IACnG,CAAC;SAAM,CAAC;QACN,MAAM,aAAa,GAAG,MAAM,QAAQ,CAAC,UAAU,CAAC,uBAAuB,CAAC,eAAe,EAAE;YACvF,IAAI,EAAE,WAAW;SAClB,CAAC,CAAC;QACH,IAAI,aAAa,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;YACrD,sBAAsB,GAAG,IAAA,qBAAa,EAAC,gBAAgB,CAAC,QAAQ,EAAE,EAAE,uBAAS,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;QACnG,CAAC;aAAM,IAAI,aAAa,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC1C,MAAM,iBAAiB,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAEjD,IAAI,CAAC,iBAAiB,EAAE,MAAM,EAAE,CAAC;gBAC/B,MAAM,IAAI,qBAAQ,CAAC,oDAAoD,CAAC,CAAC;YAC3E,CAAC;YACD,sBAAsB,GAAG,IAAA,qBAAa,EAAC,iBAAiB,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE,uBAAS,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;QAC3G,CAAC;aAAM,CAAC;YACN,MAAM,IAAI,qBAAQ,CAAC,oCAAoC,CAAC,CAAC;QAC3D,CAAC;IACH,CAAC;IACD,OAAO,sBAAsB,CAAC;AAChC,CAAC","sourcesContent":["import * as anchor from \"@project-serum/anchor\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { ChainType } from \"../../chains/chain.enums\";\nimport { SdkError } from \"../../exceptions\";\nimport { getAssociatedAccount } from \"../utils/sol/accounts\";\nimport { buildAnchorProvider } from \"../utils/sol/anchor-provider\";\nimport { formatAddress } from \"./utils\";\n\n// 1. OVERLOADS\nexport function getCctpSolTokenRecipientAddress(\n  chainType: ChainType.EVM | ChainType.SUI,\n  toAccountAddress: string,\n  destinationTokenAddress: string,\n  solRpcUrl: string\n): Promise<string>;\nexport function getCctpSolTokenRecipientAddress(\n  chainType: ChainType.TRX,\n  toAccountAddress: string,\n  destinationTokenAddress: string,\n  solRpcUrl: string\n): Promise<Buffer>;\nexport function getCctpSolTokenRecipientAddress(\n  chainType: ChainType.SOLANA | ChainType.SRB,\n  toAccountAddress: string,\n  destinationTokenAddress: string,\n  solRpcUrl: string\n): Promise<number[]>;\nexport function getCctpSolTokenRecipientAddress(\n  chainType: ChainType,\n  toAccountAddress: string,\n  destinationTokenAddress: string,\n  solRpcUrl: string\n): Promise<string | number[] | Buffer>;\n\n// 2. COMMON Realization\nexport async function getCctpSolTokenRecipientAddress(\n  chainType: ChainType,\n  toAccountAddress: string,\n  destinationTokenAddress: string,\n  solRpcUrl: string\n): Promise<string | number[] | Buffer> {\n  let recipientWalletAddress: string | number[] | Buffer;\n  const receiverAccount = new PublicKey(toAccountAddress);\n  const receiveMint = new PublicKey(destinationTokenAddress);\n  const receiveUserToken = await getAssociatedAccount(receiverAccount, receiveMint);\n  const provider = buildAnchorProvider(solRpcUrl, toAccountAddress);\n  anchor.setProvider(provider);\n  const accountData = await anchor.Spl.token(provider).account.token.fetchNullable(receiveUserToken);\n  if (accountData?.authority.equals(receiverAccount)) {\n    recipientWalletAddress = formatAddress(receiveUserToken.toBase58(), ChainType.SOLANA, chainType);\n  } else {\n    const tokenAccounts = await provider.connection.getTokenAccountsByOwner(receiverAccount, {\n      mint: receiveMint,\n    });\n    if (tokenAccounts.value.length === 0 && !accountData) {\n      recipientWalletAddress = formatAddress(receiveUserToken.toBase58(), ChainType.SOLANA, chainType);\n    } else if (tokenAccounts.value.length > 0) {\n      const firstTokenAccount = tokenAccounts.value[0];\n\n      if (!firstTokenAccount?.pubkey) {\n        throw new SdkError(\"First token account or its public key is undefined\");\n      }\n      recipientWalletAddress = formatAddress(firstTokenAccount.pubkey.toBase58(), ChainType.SOLANA, chainType);\n    } else {\n      throw new SdkError(\"Associated account has wrong owner\");\n    }\n  }\n  return recipientWalletAddress;\n}\n"]}