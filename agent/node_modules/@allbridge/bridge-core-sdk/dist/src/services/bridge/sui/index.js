"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiBridgeService = void 0;
const client_1 = require("@mysten/sui/client");
const transactions_1 = require("@mysten/sui/transactions");
const utils_1 = require("@mysten/sui/utils");
const big_js_1 = require("big.js");
const models_1 = require("../../../models");
const bridge_1 = require("../../models/sui/bridge");
const functions_1 = require("../../models/sui/bridge/bridge-interface/functions");
const cctp_bridge_1 = require("../../models/sui/cctp-bridge");
const functions_2 = require("../../models/sui/cctp-bridge/cctp-bridge-interface/functions");
const utils_2 = require("../../models/sui/utils");
const functions_3 = require("../../models/sui/utils/bytes32/functions");
const paginated_1 = require("../../utils/sui/paginated");
const get_cctp_sol_token_recipient_address_1 = require("../get-cctp-sol-token-recipient-address");
const models_2 = require("../models");
const utils_3 = require("../utils");
class SuiBridgeService extends models_2.ChainBridgeService {
    nodeRpcUrlsConfig;
    api;
    chainType = models_1.ChainType.SUI;
    chainSymbol = models_1.ChainSymbol.SUI;
    client;
    constructor(nodeRpcUrlsConfig, api) {
        super();
        this.nodeRpcUrlsConfig = nodeRpcUrlsConfig;
        this.api = api;
        this.client = new client_1.SuiClient({
            url: nodeRpcUrlsConfig.getNodeRpcUrl(this.chainSymbol),
        });
    }
    send() {
        throw new models_1.SdkError("Method send not implemented.");
    }
    async buildRawTransactionSwap(params) {
        const suiAddresses = params.sourceToken.suiAddresses;
        if (!suiAddresses) {
            throw new models_1.SdkError("SUI token must contain 'suiAddresses'");
        }
        (0, bridge_1.setAddress)(suiAddresses.bridgeAddress, suiAddresses.bridgeAddressOrigin);
        const txSwapParams = (0, utils_3.prepareTxSwapParams)(this.chainType, params);
        return await this.buildRawTransactionSwapFromParams(txSwapParams, suiAddresses);
    }
    async buildRawTransactionSwapFromParams(params, suiAddresses) {
        const { amount, fromAccountAddress, fromTokenAddress, toTokenAddress, minimumReceiveAmount } = params;
        const tx = new transactions_1.Transaction();
        tx.setSender(fromAccountAddress);
        const args = {
            bridge: suiAddresses.bridgeObjectAddress,
            coin: (0, transactions_1.coinWithBalance)({ balance: BigInt(amount), type: fromTokenAddress }),
            receiveAmountMin: BigInt(minimumReceiveAmount),
        };
        const swapResult = (0, functions_1.swap)(tx, [fromTokenAddress, toTokenAddress], args);
        const coins = await (0, paginated_1.fetchAllPagesRecursive)((cursor) => this.client.getCoins({
            owner: params.toAccountAddress,
            coinType: toTokenAddress,
            cursor,
        }));
        if (coins.length === 0 || !coins[0]) {
            tx.transferObjects([swapResult], params.toAccountAddress);
        }
        else {
            tx.mergeCoins(coins[0].coinObjectId, [swapResult]);
        }
        return await tx.toJSON({ client: this.client });
    }
    async buildRawTransactionSend(params) {
        const txSendParams = await (0, utils_3.prepareTxSendParams)(this.chainType, params, this.api);
        const { messenger } = txSendParams;
        const suiAddresses = params.sourceToken.suiAddresses;
        if (!suiAddresses) {
            throw new models_1.SdkError("SUI token must contain 'suiAddresses'");
        }
        (0, bridge_1.setAddress)(suiAddresses.bridgeAddress, suiAddresses.bridgeAddressOrigin);
        (0, utils_2.setAddress)(suiAddresses.utilsAddress);
        switch (messenger) {
            case models_1.Messenger.ALLBRIDGE:
                return this.buildRawTransactionAllbridgeSend(txSendParams, suiAddresses);
            case models_1.Messenger.WORMHOLE:
                return this.buildRawTransactionWormholeSend(txSendParams, suiAddresses);
            case models_1.Messenger.CCTP:
            case models_1.Messenger.CCTP_V2:
                return this.buildRawTransactionCctpSend(params, txSendParams, suiAddresses);
        }
    }
    async buildRawTransactionAllbridgeSend(txSendParams, suiAddresses) {
        const { amount, fromAccountAddress, fromTokenAddress, toChainId, toAccountAddress, toTokenAddress, fee, gasFeePaymentMethod, extraGas, } = txSendParams;
        let totalFee = fee;
        if (extraGas) {
            totalFee = (0, big_js_1.Big)(totalFee).plus(extraGas).toFixed();
        }
        const tx = new transactions_1.Transaction();
        tx.setSender(fromAccountAddress);
        if (gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
            const amountWithoutFee = BigInt(amount) - BigInt(totalFee);
            const args = {
                bridge: suiAddresses.bridgeObjectAddress,
                messenger: suiAddresses.allbridgeMessengerObjectAddress,
                amount: (0, transactions_1.coinWithBalance)({ balance: amountWithoutFee, type: fromTokenAddress }),
                destinationChainId: toChainId,
                nonce: (0, utils_3.getNonceBigInt)(),
                recipient: (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(toAccountAddress)),
                receiveToken: (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(toTokenAddress)),
                gasOracle: suiAddresses.gasOracleObjectAddress,
                feeTokenCoin: (0, transactions_1.coinWithBalance)({ balance: BigInt(totalFee), type: fromTokenAddress }),
                feeSuiCoin: (0, transactions_1.coinWithBalance)({ balance: BigInt(0), useGasCoin: false }),
            };
            (0, functions_1.swapAndBridge)(tx, fromTokenAddress, args);
        }
        else {
            const totalFeeCoin = totalFee === "0"
                ? (0, transactions_1.coinWithBalance)({ balance: BigInt(totalFee), useGasCoin: false })
                : (0, transactions_1.coinWithBalance)({ balance: BigInt(totalFee) });
            const args = {
                bridge: suiAddresses.bridgeObjectAddress,
                messenger: suiAddresses.allbridgeMessengerObjectAddress,
                amount: (0, transactions_1.coinWithBalance)({ balance: BigInt(amount), type: fromTokenAddress }),
                destinationChainId: toChainId,
                nonce: (0, utils_3.getNonceBigInt)(),
                recipient: (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(toAccountAddress)),
                receiveToken: (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(toTokenAddress)),
                gasOracle: suiAddresses.gasOracleObjectAddress,
                feeTokenCoin: (0, transactions_1.coinWithBalance)({ balance: BigInt(0), type: fromTokenAddress }),
                feeSuiCoin: totalFeeCoin,
            };
            (0, functions_1.swapAndBridge)(tx, fromTokenAddress, args);
        }
        return await tx.toJSON({ client: this.client });
    }
    async buildRawTransactionWormholeSend(txSendParams, suiAddresses) {
        const { amount, fromAccountAddress, fromTokenAddress, toChainId, toAccountAddress, toTokenAddress, fee, gasFeePaymentMethod, extraGas, } = txSendParams;
        let totalFee = fee;
        if (extraGas) {
            totalFee = (0, big_js_1.Big)(totalFee).plus(extraGas).toFixed();
        }
        const tx = new transactions_1.Transaction();
        tx.setSender(fromAccountAddress);
        if (gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
            const amountWithoutFee = BigInt(amount) - BigInt(totalFee);
            const args = {
                bridge: suiAddresses.bridgeObjectAddress,
                messenger: suiAddresses.wormholeMessengerObjectAddress,
                wormholeState: suiAddresses.wormholeStateObjectAddress,
                theClock: utils_1.SUI_CLOCK_OBJECT_ID,
                amount: (0, transactions_1.coinWithBalance)({ balance: amountWithoutFee, type: fromTokenAddress }),
                destinationChainId: toChainId,
                nonce: (0, utils_3.getNonceBigInt)(),
                recipient: (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(toAccountAddress)),
                receiveToken: (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(toTokenAddress)),
                gasOracle: suiAddresses.gasOracleObjectAddress,
                feeTokenCoin: (0, transactions_1.coinWithBalance)({ balance: BigInt(totalFee), type: fromTokenAddress }),
                feeSuiCoin: (0, transactions_1.coinWithBalance)({ balance: BigInt(0), useGasCoin: false }),
            };
            (0, functions_1.swapAndBridgeWormhole)(tx, fromTokenAddress, args);
        }
        else {
            const totalFeeCoin = totalFee === "0"
                ? (0, transactions_1.coinWithBalance)({ balance: BigInt(totalFee), useGasCoin: false })
                : (0, transactions_1.coinWithBalance)({ balance: BigInt(totalFee) });
            const args = {
                bridge: suiAddresses.bridgeObjectAddress,
                messenger: suiAddresses.wormholeMessengerObjectAddress,
                wormholeState: suiAddresses.wormholeStateObjectAddress,
                theClock: utils_1.SUI_CLOCK_OBJECT_ID,
                amount: (0, transactions_1.coinWithBalance)({ balance: BigInt(amount), type: fromTokenAddress }),
                destinationChainId: toChainId,
                nonce: (0, utils_3.getNonceBigInt)(),
                recipient: (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(toAccountAddress)),
                receiveToken: (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(toTokenAddress)),
                gasOracle: suiAddresses.gasOracleObjectAddress,
                feeTokenCoin: (0, transactions_1.coinWithBalance)({ balance: BigInt(0), type: fromTokenAddress }),
                feeSuiCoin: totalFeeCoin,
            };
            (0, functions_1.swapAndBridgeWormhole)(tx, fromTokenAddress, args);
        }
        return await tx.toJSON({ client: this.client });
    }
    async buildRawTransactionCctpSend(params, txSendParams, suiAddresses) {
        const { amount, fromAccountAddress, fromTokenAddress, toChainId, toAccountAddress, fee, gasFeePaymentMethod, extraGas, } = txSendParams;
        (0, cctp_bridge_1.setAddress)(suiAddresses.cctpAddress, suiAddresses.cctpAddressOrigin);
        let totalFee = fee;
        if (extraGas) {
            totalFee = (0, big_js_1.Big)(totalFee).plus(extraGas).toFixed();
        }
        const tx = new transactions_1.Transaction();
        tx.setSender(fromAccountAddress);
        const recipientWalletAddress = (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(toAccountAddress));
        let recipient;
        if (params.destinationToken.chainType === models_1.ChainType.SOLANA) {
            const recipientStr = await (0, get_cctp_sol_token_recipient_address_1.getCctpSolTokenRecipientAddress)(this.chainType, params.toAccountAddress, params.destinationToken.tokenAddress, this.nodeRpcUrlsConfig.getNodeRpcUrl(models_1.ChainSymbol.SOL));
            recipient = (0, functions_3.fromHex)(tx, (0, utils_3.normalizeSuiHex)(recipientStr));
        }
        else {
            recipient = recipientWalletAddress;
        }
        if (gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
            const amountWithoutFee = BigInt(amount) - BigInt(totalFee);
            const args = {
                cctpBridge: suiAddresses.cctpObjectAddress,
                tokenMessengerMinterState: suiAddresses.cctpTokenMessengerMinterStateObjectAddress,
                messageTransmitterState: suiAddresses.cctpMessageTransmitterStateObjectAddress,
                treasury: suiAddresses.cctpTreasuryObjectAddress,
                denyList: suiAddresses.cctpDenyListObjectAddress,
                amount: (0, transactions_1.coinWithBalance)({ balance: amountWithoutFee, type: fromTokenAddress }),
                destinationChainId: toChainId,
                recipient: recipient,
                recipientWalletAddress: recipientWalletAddress,
                gasOracle: suiAddresses.gasOracleObjectAddress,
                feeTokenCoin: (0, transactions_1.coinWithBalance)({ balance: BigInt(totalFee), type: fromTokenAddress }),
                feeSuiCoin: (0, transactions_1.coinWithBalance)({ balance: BigInt(0), useGasCoin: false }),
            };
            (0, functions_2.bridge)(tx, fromTokenAddress, args);
        }
        else {
            const totalFeeCoin = totalFee === "0"
                ? (0, transactions_1.coinWithBalance)({ balance: BigInt(totalFee), useGasCoin: false })
                : (0, transactions_1.coinWithBalance)({ balance: BigInt(totalFee) });
            const args = {
                cctpBridge: suiAddresses.cctpObjectAddress,
                tokenMessengerMinterState: suiAddresses.cctpTokenMessengerMinterStateObjectAddress,
                messageTransmitterState: suiAddresses.cctpMessageTransmitterStateObjectAddress,
                treasury: suiAddresses.cctpTreasuryObjectAddress,
                denyList: suiAddresses.cctpDenyListObjectAddress,
                amount: (0, transactions_1.coinWithBalance)({ balance: BigInt(amount), type: fromTokenAddress }),
                destinationChainId: toChainId,
                recipient: recipient,
                recipientWalletAddress: recipientWalletAddress,
                gasOracle: suiAddresses.gasOracleObjectAddress,
                feeTokenCoin: (0, transactions_1.coinWithBalance)({ balance: BigInt(0), type: fromTokenAddress }),
                feeSuiCoin: totalFeeCoin,
            };
            (0, functions_2.bridge)(tx, fromTokenAddress, args);
        }
        return await tx.toJSON({ client: this.client });
    }
}
exports.SuiBridgeService = SuiBridgeService;
//# sourceMappingURL=index.js.map