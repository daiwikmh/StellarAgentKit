"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SrbBridgeService = void 0;
const stellar_sdk_1 = require("@stellar/stellar-sdk");
const big_js_1 = require("big.js");
const chain_enums_1 = require("../../../chains/chain.enums");
const exceptions_1 = require("../../../exceptions");
const index_1 = require("../../../index");
const models_1 = require("../../../models");
const bridge_contract_1 = require("../../models/srb/bridge-contract");
const models_2 = require("../models");
const utils_1 = require("../utils");
class SrbBridgeService extends models_2.ChainBridgeService {
    nodeRpcUrlsConfig;
    params;
    api;
    chainType = index_1.ChainType.SRB;
    constructor(nodeRpcUrlsConfig, params, api) {
        super();
        this.nodeRpcUrlsConfig = nodeRpcUrlsConfig;
        this.params = params;
        this.api = api;
    }
    async buildRawTransactionSend(params) {
        const txSendParams = await (0, utils_1.prepareTxSendParams)(this.chainType, params, this.api);
        return await this.buildRawTransactionSendFromParams(txSendParams);
    }
    async buildRawTransactionSendFromParams(params) {
        const { amount, contractAddress, fromAccountAddress, fromTokenAddress, toChainId, toAccountAddress, toTokenAddress, fee, gasFeePaymentMethod, extraGas, } = params;
        let totalFee = fee;
        if (extraGas) {
            totalFee = (0, big_js_1.Big)(totalFee).plus(extraGas).toFixed();
        }
        const contract = this.getContract(bridge_contract_1.BridgeContract, contractAddress, fromAccountAddress);
        let tx;
        if (gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
            tx = await contract.swap_and_bridge({
                sender: fromAccountAddress,
                token: stellar_sdk_1.Address.contract(Buffer.from(fromTokenAddress)).toString(),
                amount: BigInt(amount),
                recipient: Buffer.from(toAccountAddress),
                destination_chain_id: +toChainId,
                receive_token: Buffer.from(toTokenAddress),
                nonce: (0, utils_1.getNonceBigInt)(),
                gas_amount: BigInt(0),
                fee_token_amount: BigInt(totalFee),
            });
        }
        else {
            tx = await contract.swap_and_bridge({
                sender: fromAccountAddress,
                token: stellar_sdk_1.Address.contract(Buffer.from(fromTokenAddress)).toString(),
                amount: BigInt(amount),
                recipient: Buffer.from(toAccountAddress),
                destination_chain_id: +toChainId,
                receive_token: Buffer.from(toTokenAddress),
                nonce: (0, utils_1.getNonceBigInt)(),
                gas_amount: BigInt(totalFee),
                fee_token_amount: BigInt(0),
            });
        }
        return tx.toXDR();
    }
    async buildRawTransactionSwap(params) {
        const txSwapParams = (0, utils_1.prepareTxSwapParams)(this.chainType, params);
        return await this.buildRawTransactionSwapFromParams(txSwapParams);
    }
    async buildRawTransactionSwapFromParams(params) {
        const { amount, contractAddress, fromAccountAddress, fromTokenAddress, toAccountAddress, toTokenAddress, minimumReceiveAmount, } = params;
        const contract = this.getContract(bridge_contract_1.BridgeContract, contractAddress, fromAccountAddress);
        return (await contract.swap({
            sender: fromAccountAddress,
            amount: BigInt(amount),
            token: stellar_sdk_1.Address.contract(Buffer.from(fromTokenAddress)).toBuffer(),
            receive_token: Buffer.from(toTokenAddress),
            recipient: toAccountAddress,
            receive_amount_min: BigInt(minimumReceiveAmount),
        })).toXDR();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    send(params) {
        throw new exceptions_1.MethodNotSupportedError();
    }
    getContract(contract, address, sender) {
        const config = {
            publicKey: sender,
            contractId: address,
            networkPassphrase: this.params.sorobanNetworkPassphrase,
            rpcUrl: this.nodeRpcUrlsConfig.getNodeRpcUrl(chain_enums_1.ChainSymbol.SRB),
        };
        return new contract(config);
    }
}
exports.SrbBridgeService = SrbBridgeService;
//# sourceMappingURL=index.js.map