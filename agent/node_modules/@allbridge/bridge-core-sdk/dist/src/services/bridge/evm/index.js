"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmBridgeService = void 0;
const big_js_1 = require("big.js");
const models_1 = require("../../../models");
const Bridge_1 = __importDefault(require("../../models/abi/Bridge"));
const CctpBridge_1 = __importDefault(require("../../models/abi/CctpBridge"));
const get_cctp_sol_token_recipient_address_1 = require("../get-cctp-sol-token-recipient-address");
const models_2 = require("../models");
const utils_1 = require("../utils");
class EvmBridgeService extends models_2.ChainBridgeService {
    web3;
    api;
    nodeRpcUrlsConfig;
    chainType = models_1.ChainType.EVM;
    constructor(web3, api, nodeRpcUrlsConfig) {
        super();
        this.web3 = web3;
        this.api = api;
        this.nodeRpcUrlsConfig = nodeRpcUrlsConfig;
    }
    async send(params) {
        const rawTransaction = await this.buildRawTransactionSend(params);
        return this.sendRawTransaction(rawTransaction);
    }
    async buildRawTransactionSwap(params) {
        const txSwapParams = (0, utils_1.prepareTxSwapParams)(this.chainType, params);
        return await this.buildRawTransactionSwapFromParams(txSwapParams);
    }
    async buildRawTransactionSwapFromParams(params) {
        const { amount, contractAddress, fromAccountAddress, fromTokenAddress, toAccountAddress, toTokenAddress, minimumReceiveAmount, } = params;
        const bridgeContract = this.getBridgeContract(contractAddress);
        const swapMethod = bridgeContract.methods.swap(amount, fromTokenAddress, toTokenAddress, toAccountAddress, minimumReceiveAmount);
        return Promise.resolve({
            from: fromAccountAddress,
            to: contractAddress,
            data: swapMethod.encodeABI(),
        });
    }
    async buildRawTransactionSend(params) {
        const txSendParams = await (0, utils_1.prepareTxSendParams)(this.chainType, params, this.api);
        const { amount, contractAddress, fromAccountAddress, fromTokenAddress, toChainId, toAccountAddress, toTokenAddress, messenger, fee, gasFeePaymentMethod, extraGas, } = txSendParams;
        const nonce = "0x" + (0, utils_1.getNonce)().toString("hex");
        let sendMethod;
        let value;
        let totalFee = fee;
        if (extraGas) {
            totalFee = (0, big_js_1.Big)(totalFee).plus(extraGas).toFixed();
        }
        if (messenger === models_1.Messenger.CCTP || messenger === models_1.Messenger.CCTP_V2) {
            const cctp = await this.buildRawTransactionCctpSend(params, txSendParams, totalFee);
            sendMethod = cctp.sendMethod;
            value = cctp.value;
        }
        else {
            const bridgeContract = this.getBridgeContract(contractAddress);
            if (gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
                sendMethod = bridgeContract.methods.swapAndBridge(fromTokenAddress, amount, toAccountAddress, toChainId, toTokenAddress, nonce, messenger, totalFee);
                value = "0";
            }
            else {
                sendMethod = bridgeContract.methods.swapAndBridge(fromTokenAddress, amount, toAccountAddress, toChainId, toTokenAddress, nonce, messenger, 0);
                value = totalFee;
            }
        }
        return Promise.resolve({
            from: fromAccountAddress,
            to: contractAddress,
            value: value,
            data: sendMethod.encodeABI(),
        });
    }
    async buildRawTransactionCctpSend(params, txSendParams, totalFee) {
        const { amount, contractAddress, toChainId, toAccountAddress, gasFeePaymentMethod } = txSendParams;
        const cctpBridgeContract = this.getCctpBridgeContract(contractAddress);
        let sendMethod;
        let value;
        if (params.destinationToken.chainType === models_1.ChainType.SOLANA) {
            const recipient = await (0, get_cctp_sol_token_recipient_address_1.getCctpSolTokenRecipientAddress)(this.chainType, params.toAccountAddress, params.destinationToken.tokenAddress, this.nodeRpcUrlsConfig.getNodeRpcUrl(models_1.ChainSymbol.SOL));
            if (gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
                sendMethod = cctpBridgeContract.methods.bridgeWithWalletAddress(amount, recipient, toAccountAddress, toChainId, totalFee);
                value = "0";
            }
            else {
                sendMethod = cctpBridgeContract.methods.bridgeWithWalletAddress(amount, recipient, toAccountAddress, toChainId, 0);
                value = totalFee;
            }
        }
        else {
            if (gasFeePaymentMethod === models_1.FeePaymentMethod.WITH_STABLECOIN) {
                sendMethod = cctpBridgeContract.methods.bridge(amount, toAccountAddress, toChainId, totalFee);
                value = "0";
            }
            else {
                sendMethod = cctpBridgeContract.methods.bridge(amount, toAccountAddress, toChainId, 0);
                value = totalFee;
            }
        }
        return { sendMethod, value };
    }
    async sendRawTransaction(rawTransaction) {
        const estimateGas = await this.web3.eth.estimateGas(rawTransaction);
        // @ts-expect-error DISABLE SITE SUGGESTED GAS FEE IN METAMASK
        // prettier-ignore
        const feeOptions = { maxPriorityFeePerGas: null, maxFeePerGas: null };
        const { transactionHash } = await this.web3.eth.sendTransaction({
            ...rawTransaction,
            gas: estimateGas,
            ...feeOptions,
        });
        return { txId: transactionHash.toString() };
    }
    getBridgeContract(contractAddress) {
        return new this.web3.eth.Contract(Bridge_1.default.abi, contractAddress);
    }
    getCctpBridgeContract(contractAddress) {
        return new this.web3.eth.Contract(CctpBridge_1.default.abi, contractAddress);
    }
}
exports.EvmBridgeService = EvmBridgeService;
//# sourceMappingURL=index.js.map