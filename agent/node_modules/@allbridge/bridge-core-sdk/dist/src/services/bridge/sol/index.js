"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaBridgeService = void 0;
/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-unused-vars */
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const big_js_1 = require("big.js");
const chains_1 = require("../../../chains");
const core_api_model_1 = require("../../../client/core-api/core-api.model");
const exceptions_1 = require("../../../exceptions");
const models_1 = require("../../../models");
const calculation_1 = require("../../../utils/calculation");
const bridge_1 = require("../../models/sol/types/bridge");
const cctp_bridge_1 = require("../../models/sol/types/cctp_bridge");
const sol_1 = require("../../utils/sol");
const accounts_1 = require("../../utils/sol/accounts");
const anchor_provider_1 = require("../../utils/sol/anchor-provider");
const compute_budget_1 = require("../../utils/sol/compute-budget");
const bridge_2 = require("../models/bridge");
const utils_1 = require("../utils");
const jupiter_1 = require("./jupiter");
const COMPUTE_UNIT_LIMIT = 1000000;
const JUP_ADD_INDEX = 1.1;
class SolanaBridgeService extends bridge_2.ChainBridgeService {
    solanaRpcUrl;
    params;
    api;
    chainType = models_1.ChainType.SOLANA;
    jupiterService;
    constructor(solanaRpcUrl, params, api) {
        super();
        this.solanaRpcUrl = solanaRpcUrl;
        this.params = params;
        this.api = api;
        this.jupiterService = new jupiter_1.JupiterService(solanaRpcUrl, params.jupiterParams);
    }
    async buildRawTransactionSwap(params) {
        const txSwapParams = (0, utils_1.prepareTxSwapParams)(this.chainType, params);
        return await this.buildSwapTransaction(txSwapParams, params.sourceToken.poolAddress, params.destinationToken.poolAddress, params.txFeeParams);
    }
    async buildSwapTransaction(params, poolAddress, toPoolAddress, txFeeParams) {
        const { fromAccountAddress, amount, contractAddress, fromTokenAddress, toTokenAddress, toAccountAddress, minimumReceiveAmount, } = params;
        const account = fromAccountAddress;
        const bridgeAddress = contractAddress;
        const tokenAddress = fromTokenAddress;
        const receiveTokenAddress = toTokenAddress;
        const receivePoolAddress = toPoolAddress;
        const receiverOriginal = toAccountAddress;
        const userAccount = new web3_js_1.PublicKey(account);
        const provider = (0, anchor_provider_1.buildAnchorProvider)(this.solanaRpcUrl, userAccount.toString());
        const bridge = new anchor_1.Program(bridge_1.IDL, bridgeAddress, provider);
        const bridgeAuthority = await (0, accounts_1.getAuthorityAccount)(bridge.programId);
        const configAccount = await (0, accounts_1.getConfigAccount)(bridge.programId);
        const sendMint = new web3_js_1.PublicKey(tokenAddress);
        const sendBridgeToken = await (0, accounts_1.getBridgeTokenAccount)(sendMint, bridge.programId);
        const sendPool = new web3_js_1.PublicKey(poolAddress);
        const sendUserToken = await (0, accounts_1.getAssociatedAccount)(userAccount, sendMint);
        const receiverAccount = new web3_js_1.PublicKey(receiverOriginal);
        const receiveMint = new web3_js_1.PublicKey(receiveTokenAddress);
        const receiveBridgeToken = await (0, accounts_1.getBridgeTokenAccount)(receiveMint, bridge.programId);
        const receivePool = new web3_js_1.PublicKey(receivePoolAddress);
        const receiveUserToken = await (0, accounts_1.getAssociatedAccount)(receiverAccount, receiveMint);
        const preInstructions = [
            anchor_1.web3.ComputeBudgetProgram.setComputeUnitLimit({
                units: COMPUTE_UNIT_LIMIT,
            }),
        ];
        try {
            await (0, sol_1.getTokenAccountData)(receiveUserToken, provider);
        }
        catch (e) {
            const associatedProgram = anchor_1.Spl.associatedToken(provider);
            const createReceiveUserTokenInstruction = await associatedProgram.methods
                .create()
                .accounts({
                mint: receiveMint,
                owner: receiverAccount,
                associatedAccount: receiveUserToken,
            })
                .instruction();
            preInstructions.push(createReceiveUserTokenInstruction);
        }
        const transaction = await bridge.methods
            .swap(new anchor_1.BN(amount), new anchor_1.BN(minimumReceiveAmount || 0))
            .accounts({
            payer: userAccount,
            config: configAccount,
            bridgeAuthority,
            user: userAccount,
            sendBridgeToken,
            sendMint,
            sendPool,
            sendUserToken,
            receiveBridgeToken,
            receiveMint,
            receivePool,
            receiveUserToken,
        })
            .preInstructions(preInstructions)
            .transaction();
        const connection = provider.connection;
        transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        transaction.feePayer = userAccount;
        await (0, compute_budget_1.addUnitLimitAndUnitPriceToTx)(transaction, txFeeParams, this.solanaRpcUrl);
        return await this.convertToVersionedTransaction(transaction, connection);
    }
    async buildRawTransactionSend(params) {
        const txSendParams = await (0, utils_1.prepareTxSendParams)(this.chainType, params, this.api);
        let solTxSendParams = this.addPoolAddress(params, txSendParams);
        const isJupiterForStableCoin = solTxSendParams.gasFeePaymentMethod == models_1.FeePaymentMethod.WITH_STABLECOIN;
        let jupTx;
        if (isJupiterForStableCoin) {
            try {
                const { tx, solTxSendUpdatedParams } = await this.processJup(solTxSendParams, params, true);
                jupTx = tx;
                solTxSendParams = { ...solTxSendParams, ...solTxSendUpdatedParams };
            }
            catch (e) {
                try {
                    const { tx, solTxSendUpdatedParams } = await this.processJup(solTxSendParams, params, false);
                    jupTx = tx;
                    solTxSendParams = { ...solTxSendParams, ...solTxSendUpdatedParams };
                }
                catch (e) {
                    if (e instanceof exceptions_1.SdkRootError) {
                        throw e;
                    }
                    if (e instanceof Error && e.message) {
                        throw new exceptions_1.JupiterError(`Some error occurred during creation Jupiter swap transaction. ${e.message}`);
                    }
                    throw new exceptions_1.JupiterError("Some error occurred during creation Jupiter swap transaction");
                }
            }
        }
        let swapAndBridgeTx;
        let requiredMessageSigner = undefined;
        switch (txSendParams.messenger) {
            case core_api_model_1.Messenger.ALLBRIDGE: {
                const swapAndBridgeSolData = await this.prepareSwapAndBridgeData(solTxSendParams);
                swapAndBridgeTx = await this.buildSwapAndBridgeAllbridgeTransaction(swapAndBridgeSolData);
                break;
            }
            case core_api_model_1.Messenger.WORMHOLE: {
                const swapAndBridgeSolData = await this.prepareSwapAndBridgeData(solTxSendParams);
                const { transaction, messageAccount } = await this.buildSwapAndBridgeWormholeTransaction(swapAndBridgeSolData);
                swapAndBridgeTx = transaction;
                requiredMessageSigner = messageAccount;
                break;
            }
            case core_api_model_1.Messenger.CCTP:
            case core_api_model_1.Messenger.CCTP_V2: {
                const swapAndBridgeSolData = await this.prepareSwapAndBridgeCctpData(solTxSendParams);
                const { transaction, messageSentEventDataKeypair } = await this.buildSwapAndBridgeCctpTransaction(params.destinationToken.chainSymbol, swapAndBridgeSolData);
                swapAndBridgeTx = transaction;
                requiredMessageSigner = messageSentEventDataKeypair;
                break;
            }
        }
        if (isJupiterForStableCoin) {
            if (!jupTx) {
                throw new exceptions_1.JupiterError("Swap tx is absent");
            }
            swapAndBridgeTx = await this.jupiterService.amendJupiterWithSdkTx(jupTx, swapAndBridgeTx);
        }
        await (0, compute_budget_1.addUnitLimitAndUnitPriceToVersionedTx)(swapAndBridgeTx, params.txFeeParams, this.solanaRpcUrl);
        if (requiredMessageSigner) {
            swapAndBridgeTx.sign([requiredMessageSigner]);
        }
        return swapAndBridgeTx;
    }
    async processJup(solTxSendParams, params, exactOut) {
        const { fee, extraGas, gasFeePaymentMethod } = await this.convertStableCoinFeeAndExtraGasToNativeCurrency(params.sourceToken.decimals, solTxSendParams);
        let amountToProcess = exactOut ? (0, big_js_1.Big)(fee) : (0, big_js_1.Big)(solTxSendParams.fee);
        if (extraGas) {
            amountToProcess = amountToProcess.plus(extraGas);
        }
        if (!exactOut) {
            amountToProcess = amountToProcess.mul(JUP_ADD_INDEX);
        }
        const { tx, amountIn } = await this.jupiterService.getJupiterSwapTx(params.fromAccountAddress, params.sourceToken.tokenAddress, amountToProcess.toFixed(0), exactOut);
        let newAmount;
        if (exactOut) {
            if (!amountIn) {
                throw new exceptions_1.JupiterError("Cannot get inAmount");
            }
            newAmount = (0, big_js_1.Big)(solTxSendParams.amount).minus((0, big_js_1.Big)(amountIn).mul(JUP_ADD_INDEX)).toFixed(0);
        }
        else {
            newAmount = (0, big_js_1.Big)(solTxSendParams.amount).minus(amountToProcess).toFixed(0);
        }
        if ((0, big_js_1.Big)(newAmount).lte(0)) {
            throw new exceptions_1.AmountNotEnoughError(`Amount not enough to pay fee, ${(0, calculation_1.convertIntAmountToFloat)((0, big_js_1.Big)(newAmount).minus(1).neg(), params.sourceToken.decimals).toFixed()} stables is missing`);
        }
        return {
            tx: tx,
            solTxSendUpdatedParams: {
                amount: newAmount,
                fee: fee,
                extraGas: extraGas,
                gasFeePaymentMethod: gasFeePaymentMethod,
            },
        };
    }
    addPoolAddress(params, txSendParams) {
        return {
            ...txSendParams,
            poolAddress: params.sourceToken.poolAddress,
        };
    }
    async convertStableCoinFeeAndExtraGasToNativeCurrency(tokenDecimals, solTxSendParams) {
        if (solTxSendParams.gasFeePaymentMethod == models_1.FeePaymentMethod.WITH_STABLECOIN) {
            const sourceNativeTokenPrice = (await this.api.getReceiveTransactionCost({
                sourceChainId: solTxSendParams.fromChainId,
                destinationChainId: solTxSendParams.toChainId,
                messenger: solTxSendParams.messenger,
            })).sourceNativeTokenPrice;
            const fee = (0, big_js_1.Big)(solTxSendParams.fee)
                .div(sourceNativeTokenPrice)
                .mul((0, big_js_1.Big)(10).pow(chains_1.Chains.getChainDecimalsByType(models_1.ChainType.SOLANA) - tokenDecimals))
                .toFixed(0);
            let extraGas;
            if (solTxSendParams.extraGas) {
                extraGas = (0, big_js_1.Big)(solTxSendParams.extraGas)
                    .div(sourceNativeTokenPrice)
                    .mul((0, big_js_1.Big)(10).pow(chains_1.Chains.getChainDecimalsByType(models_1.ChainType.SOLANA) - tokenDecimals))
                    .toFixed(0);
            }
            return { fee, extraGas, gasFeePaymentMethod: models_1.FeePaymentMethod.WITH_NATIVE_CURRENCY };
        }
        return {
            fee: solTxSendParams.fee,
            extraGas: solTxSendParams.extraGas,
            gasFeePaymentMethod: models_1.FeePaymentMethod.WITH_NATIVE_CURRENCY,
        };
    }
    getExtraGasInstruction(extraGas, userAccount, configAccount) {
        return anchor_1.web3.SystemProgram.transfer({
            fromPubkey: userAccount,
            toPubkey: configAccount,
            lamports: +extraGas,
        });
    }
    async prepareSwapAndBridgeData(txSendParams) {
        const { amount, contractAddress, fromChainId, fromAccountAddress, fromTokenAddress, toChainId, toAccountAddress, toTokenAddress, poolAddress, extraGas, } = txSendParams;
        const tokenAddress = fromTokenAddress;
        const account = fromAccountAddress;
        const destinationChainId = toChainId;
        const receiveTokenAddress = toTokenAddress;
        const receiverInBuffer32 = toAccountAddress;
        const bridgeAddress = contractAddress;
        const sourceChainId = fromChainId;
        const provider = (0, anchor_provider_1.buildAnchorProvider)(this.solanaRpcUrl, account);
        const bridge = new anchor_1.Program(bridge_1.IDL, bridgeAddress, provider);
        const nonce = Array.from((0, utils_1.getNonce)());
        const poolAccount = new web3_js_1.PublicKey(poolAddress);
        const vUsdAmount = await (0, sol_1.getVUsdAmount)(amount, bridge, poolAccount);
        const lockAccount = await (0, accounts_1.getLockAccount)(nonce, bridge.programId);
        const bridgeAuthority = await (0, accounts_1.getAuthorityAccount)(bridge.programId);
        const userToken = await (0, accounts_1.getAssociatedAccount)(new web3_js_1.PublicKey(account), new web3_js_1.PublicKey(tokenAddress));
        const bridgeTokenAccount = await (0, accounts_1.getBridgeTokenAccount)(new web3_js_1.PublicKey(tokenAddress), bridge.programId);
        const chainBridgeAccount = await (0, accounts_1.getChainBridgeAccount)(destinationChainId, bridge.programId);
        const otherBridgeTokenAccount = await (0, accounts_1.getOtherChainTokenAccount)(destinationChainId, Buffer.from(receiveTokenAddress), bridge.programId);
        const configAccount = await (0, accounts_1.getConfigAccount)(bridge.programId);
        const configAccountInfo = await bridge.account.config.fetch(configAccount);
        const priceAccount = await (0, accounts_1.getPriceAccount)(destinationChainId, configAccountInfo.gasOracleProgramId);
        const thisGasPriceAccount = await (0, accounts_1.getPriceAccount)(sourceChainId, configAccountInfo.gasOracleProgramId);
        const message = (0, sol_1.getMessage)({
            amount: vUsdAmount,
            recipient: Buffer.from(receiverInBuffer32),
            nonce: Buffer.from(nonce),
            receiveToken: Buffer.from(receiveTokenAddress),
            destinationChainId,
            sourceChainId,
            chainBridge: (await (0, accounts_1.getAuthorityAccount)(bridge.programId)).toBuffer(),
        });
        const swapAndBridgeData = {};
        swapAndBridgeData.bridge = bridge;
        swapAndBridgeData.amount = new anchor_1.BN(amount);
        swapAndBridgeData.vusdAmount = new anchor_1.BN(vUsdAmount);
        swapAndBridgeData.nonce = nonce;
        swapAndBridgeData.recipient = Array.from(receiverInBuffer32);
        swapAndBridgeData.receiveToken = Array.from(receiveTokenAddress);
        swapAndBridgeData.poolAccount = poolAccount;
        swapAndBridgeData.lockAccount = lockAccount;
        swapAndBridgeData.bridgeAuthority = bridgeAuthority;
        swapAndBridgeData.userToken = userToken;
        swapAndBridgeData.bridgeTokenAccount = bridgeTokenAccount;
        swapAndBridgeData.chainBridgeAccount = chainBridgeAccount;
        swapAndBridgeData.otherBridgeTokenAccount = otherBridgeTokenAccount;
        swapAndBridgeData.userAccount = new web3_js_1.PublicKey(account);
        swapAndBridgeData.destinationChainId = destinationChainId;
        // @ts-expect-error
        swapAndBridgeData.mint = new web3_js_1.PublicKey(tokenAddress);
        swapAndBridgeData.config = configAccount;
        swapAndBridgeData.configAccountInfo = configAccountInfo;
        swapAndBridgeData.gasPrice = priceAccount;
        swapAndBridgeData.thisGasPrice = thisGasPriceAccount;
        swapAndBridgeData.message = message;
        if (extraGas) {
            swapAndBridgeData.extraGasInstruction = this.getExtraGasInstruction(extraGas, swapAndBridgeData.userAccount, configAccount);
        }
        return swapAndBridgeData;
    }
    async buildSwapAndBridgeAllbridgeTransaction(swapAndBridgeData) {
        const { bridge, vusdAmount, nonce, recipient, receiveToken, poolAccount, lockAccount, bridgeAuthority, userToken, bridgeTokenAccount, chainBridgeAccount, otherBridgeTokenAccount, userAccount, destinationChainId, mint, config, configAccountInfo, gasPrice, thisGasPrice, message, extraGasInstruction, } = swapAndBridgeData;
        const allbridgeMessengerProgramId = configAccountInfo.allbridgeMessengerProgramId;
        const messengerGasUsageAccount = await (0, accounts_1.getGasUsageAccount)(destinationChainId, allbridgeMessengerProgramId);
        const messengerConfig = await (0, accounts_1.getConfigAccount)(allbridgeMessengerProgramId);
        const sentMessageAccount = await (0, accounts_1.getSendMessageAccount)(message, allbridgeMessengerProgramId);
        const instructions = [];
        if (extraGasInstruction) {
            instructions.push(extraGasInstruction);
        }
        const transaction = await bridge.methods
            .swapAndBridge({
            vusdAmount,
            nonce,
            destinationChainId,
            recipient,
            receiveToken,
        })
            .accounts({
            mint,
            user: userAccount,
            config,
            lock: lockAccount,
            pool: poolAccount,
            gasPrice,
            thisGasPrice,
            bridgeAuthority,
            userToken,
            bridgeToken: bridgeTokenAccount,
            chainBridge: chainBridgeAccount,
            messenger: allbridgeMessengerProgramId,
            messengerGasUsage: messengerGasUsageAccount,
            messengerConfig,
            sentMessageAccount,
            otherBridgeToken: otherBridgeTokenAccount,
        })
            .preInstructions([
            anchor_1.web3.ComputeBudgetProgram.setComputeUnitLimit({
                units: COMPUTE_UNIT_LIMIT,
            }),
        ])
            .postInstructions(instructions)
            .transaction();
        const connection = (0, anchor_provider_1.buildAnchorProvider)(this.solanaRpcUrl, userAccount.toString()).connection;
        transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        transaction.feePayer = userAccount;
        return await this.convertToVersionedTransaction(transaction, connection);
    }
    async convertToVersionedTransaction(tx, connection) {
        const allbridgeTableAccount = await connection
            .getAddressLookupTable(new web3_js_1.PublicKey(this.params.solanaLookUpTable))
            .then((res) => res.value);
        if (!allbridgeTableAccount) {
            throw new exceptions_1.SdkError("Cannot find allbridgeLookupTableAccount");
        }
        const messageV0 = new anchor_1.web3.TransactionMessage({
            payerKey: tx.feePayer,
            recentBlockhash: tx.recentBlockhash,
            instructions: tx.instructions,
        }).compileToV0Message([allbridgeTableAccount]);
        return new anchor_1.web3.VersionedTransaction(messageV0);
    }
    async buildSwapAndBridgeWormholeTransaction(swapAndBridgeData) {
        const { bridge, vusdAmount, nonce, recipient, receiveToken, poolAccount, lockAccount, bridgeAuthority, userToken, bridgeTokenAccount, chainBridgeAccount, otherBridgeTokenAccount, userAccount, destinationChainId, mint, config, configAccountInfo, gasPrice, thisGasPrice, message, extraGasInstruction, } = swapAndBridgeData;
        const wormholeProgramId = this.params.wormholeMessengerProgramId;
        const [whBridgeAccount] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("Bridge")], new web3_js_1.PublicKey(wormholeProgramId));
        const [whFeeCollectorAccount] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("fee_collector")], new web3_js_1.PublicKey(wormholeProgramId));
        const [whSequenceAccount] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("Sequence"), bridgeAuthority.toBuffer()], new web3_js_1.PublicKey(wormholeProgramId));
        const messengerGasUsageAccount = await (0, accounts_1.getGasUsageAccount)(destinationChainId, configAccountInfo.wormholeMessengerProgramId);
        const wormholeMessengerConfigAccount = await (0, accounts_1.getConfigAccount)(configAccountInfo.wormholeMessengerProgramId);
        const messageAccount = web3_js_1.Keypair.generate();
        const provider = (0, anchor_provider_1.buildAnchorProvider)(this.solanaRpcUrl, userAccount.toString());
        const bridgeAccountInfo = await provider.connection.getAccountInfo(whBridgeAccount);
        if (bridgeAccountInfo == null) {
            throw new exceptions_1.SdkError("Cannot fetch wormhole bridge account info");
        }
        const feeLamports = new anchor_1.BN(bridgeAccountInfo.data.slice(16, 24), "le").toString();
        const feeInstruction = web3_js_1.SystemProgram.transfer({
            fromPubkey: userAccount,
            toPubkey: whFeeCollectorAccount,
            lamports: +feeLamports,
        });
        const instructions = [];
        if (extraGasInstruction) {
            instructions.push(extraGasInstruction);
        }
        const accounts = {
            mint,
            user: userAccount,
            config,
            lock: lockAccount,
            pool: poolAccount,
            gasPrice,
            thisGasPrice,
            bridgeAuthority,
            userToken,
            bridgeToken: bridgeTokenAccount,
            chainBridge: chainBridgeAccount,
            otherBridgeToken: otherBridgeTokenAccount,
            messengerGasUsage: messengerGasUsageAccount,
            wormholeProgram: wormholeProgramId,
            bridge: whBridgeAccount,
            message: messageAccount.publicKey,
            wormholeMessenger: configAccountInfo.wormholeMessengerProgramId,
            sequence: whSequenceAccount,
            feeCollector: whFeeCollectorAccount,
            wormholeMessengerConfig: wormholeMessengerConfigAccount,
            clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
        };
        const transaction = await bridge.methods
            .swapAndBridgeWormhole({
            vusdAmount,
            nonce: nonce,
            destinationChainId,
            recipient,
            receiveToken,
        })
            .accounts(accounts)
            .preInstructions([
            anchor_1.web3.ComputeBudgetProgram.setComputeUnitLimit({
                units: COMPUTE_UNIT_LIMIT,
            }),
            feeInstruction,
        ])
            .postInstructions(instructions)
            .signers([messageAccount])
            .transaction();
        transaction.recentBlockhash = (await provider.connection.getLatestBlockhash()).blockhash;
        transaction.feePayer = userAccount;
        return { transaction: await this.convertToVersionedTransaction(transaction, provider.connection), messageAccount };
    }
    async prepareSwapAndBridgeCctpData(txSendParams) {
        const { contractAddress, amount, fromAccountAddress, fromTokenAddress, toChainId, toAccountAddress, toTokenAddress, extraGas, } = txSendParams;
        const cctpAddress = contractAddress;
        if (!cctpAddress) {
            throw new exceptions_1.CCTPDoesNotSupportedError("Such route does not support CCTP protocol");
        }
        const CHAIN_ID = 4;
        const account = fromAccountAddress;
        const receiveTokenAddress = toTokenAddress;
        const receiverInBuffer32 = toAccountAddress;
        const provider = (0, anchor_provider_1.buildAnchorProvider)(this.solanaRpcUrl, account);
        const cctpBridge = new anchor_1.Program(cctp_bridge_1.IDL, cctpAddress, provider);
        const mint = new web3_js_1.PublicKey(fromTokenAddress);
        const cctpBridgeAccount = await (0, accounts_1.getCctpBridgeAccount)(mint, cctpBridge.programId);
        const userAccount = new web3_js_1.PublicKey(account);
        const configAccountInfo = await cctpBridge.account.cctpBridge.fetch(cctpBridgeAccount);
        const swapAndBridgeData = {};
        swapAndBridgeData.cctpBridge = cctpBridge;
        swapAndBridgeData.cctpBridgeAccount = cctpBridgeAccount;
        swapAndBridgeData.cctpAddressAccount = new web3_js_1.PublicKey(cctpAddress);
        swapAndBridgeData.amount = new anchor_1.BN(amount);
        swapAndBridgeData.recipient = Array.from(receiverInBuffer32);
        swapAndBridgeData.receiveToken = Array.from(receiveTokenAddress);
        swapAndBridgeData.userToken = await (0, accounts_1.getAssociatedAccount)(userAccount, mint);
        swapAndBridgeData.bridgeAuthority = await (0, accounts_1.getCctpAuthorityAccount)(cctpBridgeAccount, cctpBridge.programId);
        swapAndBridgeData.bridgeTokenAccount = await (0, accounts_1.getCctpBridgeTokenAccount)(mint, cctpBridge.programId);
        swapAndBridgeData.chainBridgeAccount = await (0, accounts_1.getChainBridgeAccount)(toChainId, cctpBridge.programId);
        swapAndBridgeData.userAccount = userAccount;
        swapAndBridgeData.destinationChainId = toChainId;
        swapAndBridgeData.mint = mint;
        swapAndBridgeData.gasPrice = await (0, accounts_1.getPriceAccount)(toChainId, configAccountInfo.gasOracleProgramId);
        swapAndBridgeData.thisGasPrice = await (0, accounts_1.getPriceAccount)(CHAIN_ID, configAccountInfo.gasOracleProgramId);
        swapAndBridgeData.provider = provider;
        if (extraGas) {
            swapAndBridgeData.extraGasInstruction = this.getExtraGasInstruction(extraGas, swapAndBridgeData.userAccount, cctpBridgeAccount);
        }
        return swapAndBridgeData;
    }
    async buildSwapAndBridgeCctpTransaction(destinationChainSymbol, swapAndBridgeData) {
        const { cctpBridge, cctpBridgeAccount, amount, recipient, receiveToken, bridgeAuthority, userToken, bridgeTokenAccount, chainBridgeAccount, userAccount, destinationChainId, mint, gasPrice, thisGasPrice, extraGasInstruction, provider, } = swapAndBridgeData;
        const domain = this.params.cctpParams.cctpDomains[destinationChainSymbol];
        const cctpTransmitterProgramIdAddress = this.params.cctpParams.cctpTransmitterProgramId;
        const cctpTokenMessengerMinterAddress = this.params.cctpParams.cctpTokenMessengerMinter;
        if (domain == undefined || !cctpTransmitterProgramIdAddress || !cctpTokenMessengerMinterAddress) {
            throw new exceptions_1.SdkError("CCTP is not configured");
        }
        const cctpTransmitterProgramId = new web3_js_1.PublicKey(cctpTransmitterProgramIdAddress);
        const cctpTokenMessengerMinter = new web3_js_1.PublicKey(cctpTokenMessengerMinterAddress);
        const { messageTransmitterAccount, tokenMessenger, tokenMessengerEventAuthority, tokenMinter, localToken, remoteTokenMessengerKey, authorityPda, } = (0, accounts_1.getCctpAccounts)(domain, mint, cctpTransmitterProgramId, cctpTokenMessengerMinter);
        const instructions = [];
        if (extraGasInstruction) {
            instructions.push(extraGasInstruction);
        }
        const messageSentEventDataKeypair = web3_js_1.Keypair.generate();
        const lockAccount = (0, accounts_1.getCctpLockAccount)(cctpBridge.programId, messageSentEventDataKeypair.publicKey);
        const tx = await cctpBridge.methods
            .bridge({
            amount,
            destinationChainId,
            recipient,
            receiveToken,
        })
            .accounts({
            mint: mint,
            user: userAccount,
            cctpBridge: cctpBridgeAccount,
            messageSentEventData: messageSentEventDataKeypair.publicKey,
            lock: lockAccount,
            cctpMessenger: cctpTokenMessengerMinter,
            messageTransmitterProgram: cctpTransmitterProgramId,
            messageTransmitterAccount: messageTransmitterAccount,
            tokenMessenger: tokenMessenger,
            tokenMinter: tokenMinter,
            localToken: localToken,
            remoteTokenMessengerKey: remoteTokenMessengerKey,
            authorityPda: authorityPda,
            eventAuthority: tokenMessengerEventAuthority,
            bridgeToken: bridgeTokenAccount,
            gasPrice: gasPrice,
            thisGasPrice: thisGasPrice,
            chainBridge: chainBridgeAccount,
            userToken,
            bridgeAuthority: bridgeAuthority,
        })
            .preInstructions([
            anchor_1.web3.ComputeBudgetProgram.setComputeUnitLimit({
                units: 2000000,
            }),
        ])
            .postInstructions(instructions)
            .transaction();
        const connection = provider.connection;
        tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        tx.feePayer = userAccount;
        return { transaction: await this.convertToVersionedTransaction(tx, connection), messageSentEventDataKeypair };
    }
    send(params) {
        throw new exceptions_1.MethodNotSupportedError();
    }
}
exports.SolanaBridgeService = SolanaBridgeService;
//# sourceMappingURL=index.js.map