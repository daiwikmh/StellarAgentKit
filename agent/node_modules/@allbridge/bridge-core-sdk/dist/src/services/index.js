"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllbridgeCoreSdkService = exports.NodeRpcUrlsConfig = void 0;
const big_js_1 = require("big.js");
const chains_1 = require("../chains");
const api_client_1 = require("../client/core-api/api-client");
const api_client_caching_1 = require("../client/core-api/api-client-caching");
const core_api_model_1 = require("../client/core-api/core-api.model");
const core_client_base_1 = require("../client/core-api/core-client-base");
const core_client_filtered_1 = require("../client/core-api/core-client-filtered");
const core_client_pool_info_caching_1 = require("../client/core-api/core-client-pool-info-caching");
const configs_1 = require("../configs");
const index_1 = require("../index");
const models_1 = require("../models");
const calculation_1 = require("../utils/calculation");
const constants_1 = require("../utils/calculation/constants");
const swap_and_bridge_details_1 = require("../utils/calculation/swap-and-bridge-details");
const swap_and_bridge_fee_calc_1 = require("../utils/calculation/swap-and-bridge-fee-calc");
const utils_1 = require("../utils/utils");
const bridge_1 = require("./bridge");
const utils_2 = require("./bridge/utils");
const liquidity_pool_1 = require("./liquidity-pool");
const token_1 = require("./token");
class NodeRpcUrlsConfig {
    nodeRpcUrls;
    constructor(nodeRpcUrls) {
        this.nodeRpcUrls = nodeRpcUrls;
    }
    getNodeRpcUrl(chainSymbol) {
        const nodeRpcUrl = this.nodeRpcUrls[chainSymbol];
        if (nodeRpcUrl !== undefined) {
            return nodeRpcUrl;
        }
        else {
            throw new models_1.NodeRpcUrlNotInitializedError(chainSymbol);
        }
    }
}
exports.NodeRpcUrlsConfig = NodeRpcUrlsConfig;
class AllbridgeCoreSdkService {
    api;
    tokenService;
    params;
    bridge;
    pool;
    constructor(nodeRpcUrlsConfig, params = configs_1.mainnet) {
        chains_1.Chains.addChainsProperties(params.additionalChainsProperties);
        const apiClient = new api_client_1.ApiClientImpl(params);
        const apiClientCaching = new api_client_caching_1.ApiClientCaching(apiClient);
        const coreClient = new core_client_base_1.AllbridgeCoreClientImpl(apiClientCaching);
        const coreClientPoolInfoCaching = new core_client_pool_info_caching_1.AllbridgeCoreClientPoolInfoCaching(coreClient);
        this.api = new core_client_filtered_1.AllbridgeCoreClientFilteredImpl(coreClientPoolInfoCaching, params);
        this.tokenService = new token_1.DefaultTokenService(this.api, nodeRpcUrlsConfig, params);
        this.bridge = new bridge_1.DefaultBridgeService(this.api, nodeRpcUrlsConfig, params, this.tokenService);
        this.pool = new liquidity_pool_1.DefaultLiquidityPoolService(this.api, nodeRpcUrlsConfig, params, this.tokenService);
        this.params = params;
    }
    async chainDetailsMap(type) {
        return this.api.getChainDetailsMap(type);
    }
    async tokens(type) {
        return this.api.tokens(type);
    }
    async tokensByChain(chainSymbol, type) {
        const map = await this.api.getChainDetailsMap(type);
        const chainDetails = map[chainSymbol];
        if (!chainDetails) {
            return [];
        }
        return chainDetails.tokens;
    }
    async getTransferStatus(chainSymbol, txId) {
        return this.api.getTransferStatus(chainSymbol, txId);
    }
    async getGasBalance(chainSymbol, address) {
        return this.api.getGasBalance(chainSymbol, address);
    }
    async checkAddress() {
        return new Promise((resolve) => {
            resolve({
                status: core_api_model_1.AddressStatus.OK,
                gasBalance: null,
            });
        });
    }
    async getPendingStatusInfo(amount, amountFormat, sourceToken, destToken) {
        (0, utils_1.validateAmountGtZero)(amount);
        let amountInTokenPrecision;
        if (amountFormat == models_1.AmountFormat.FLOAT) {
            (0, utils_1.validateAmountDecimals)("amount", amount, sourceToken.decimals);
            amountInTokenPrecision = (0, calculation_1.convertFloatAmountToInt)(amount, sourceToken.decimals).toFixed();
        }
        else {
            amountInTokenPrecision = amount;
        }
        const vUsdAmountInt = (0, calculation_1.swapToVUsd)(amountInTokenPrecision, sourceToken, await (0, utils_1.getPoolInfoByToken)(this.api, sourceToken));
        const destPoolInfo = await (0, utils_1.getPoolInfoByToken)(this.api, destToken);
        const amountResultIntFormatted = this.getAmountFromVUsdFormatted(vUsdAmountInt, destToken, destPoolInfo);
        let pendingInfoDTO;
        const pendingInfo = await this.api.getPendingInfo();
        for (const tokenAddress in pendingInfo[destToken.chainSymbol]) {
            const info = pendingInfo[destToken.chainSymbol];
            if (!info) {
                throw new index_1.SdkError("Cannot find pending info for " + destToken.chainSymbol);
            }
            pendingInfoDTO = info[tokenAddress];
        }
        if (pendingInfoDTO) {
            const destPoolAfterPending = (0, calculation_1.getSwapFromVUsdPoolInfo)(pendingInfoDTO.totalSentAmount, destPoolInfo);
            const amountResultIntAfterPendingFormatted = this.getAmountFromVUsdFormatted(vUsdAmountInt, destToken, destPoolAfterPending);
            let estimatedAmount;
            if ((0, big_js_1.Big)(amountResultIntAfterPendingFormatted.int).gt(amountResultIntFormatted.int)) {
                estimatedAmount = { min: amountResultIntFormatted, max: amountResultIntAfterPendingFormatted };
            }
            else {
                estimatedAmount = { min: amountResultIntAfterPendingFormatted, max: amountResultIntFormatted };
            }
            return {
                pendingTxs: pendingInfoDTO.pendingTxs,
                pendingAmount: {
                    [models_1.AmountFormat.INT]: (0, calculation_1.convertAmountPrecision)(pendingInfoDTO.totalSentAmount, constants_1.SYSTEM_PRECISION, destToken.decimals).toFixed(0),
                    [models_1.AmountFormat.FLOAT]: (0, calculation_1.convertIntAmountToFloat)(pendingInfoDTO.totalSentAmount, constants_1.SYSTEM_PRECISION).toFixed(),
                },
                estimatedAmount,
            };
        }
        return {
            pendingTxs: 0,
            pendingAmount: {
                [models_1.AmountFormat.INT]: "0",
                [models_1.AmountFormat.FLOAT]: "0",
            },
            estimatedAmount: {
                min: amountResultIntFormatted,
                max: amountResultIntFormatted,
            },
        };
    }
    async getTokenBalance(params, provider) {
        return this.tokenService.getTokenBalance(params, provider);
    }
    async getNativeTokenBalance(params, provider) {
        return this.tokenService.getNativeTokenBalance(params, provider);
    }
    async calculateFeePercentOnSourceChain(amountFloat, sourceChainToken) {
        (0, utils_1.validateAmountGtZero)(amountFloat);
        (0, utils_1.validateAmountDecimals)("amountFloat", amountFloat, sourceChainToken.decimals);
        const amountInt = (0, calculation_1.convertFloatAmountToInt)(amountFloat, sourceChainToken.decimals);
        if (amountInt.eq(0)) {
            return 0;
        }
        const vUsdInSystemPrecision = (0, calculation_1.swapToVUsd)(amountInt, sourceChainToken, await (0, utils_1.getPoolInfoByToken)(this.api, sourceChainToken));
        const vUsdInSourcePrecision = (0, calculation_1.fromSystemPrecision)(vUsdInSystemPrecision, sourceChainToken.decimals);
        return (0, calculation_1.getFeePercent)(amountInt, vUsdInSourcePrecision);
    }
    async calculateFeePercentOnDestinationChain(amountFloat, sourceChainToken, destinationChainToken) {
        (0, utils_1.validateAmountGtZero)(amountFloat);
        (0, utils_1.validateAmountDecimals)("amountFloat", amountFloat, sourceChainToken.decimals);
        const amountInt = (0, calculation_1.convertFloatAmountToInt)(amountFloat, sourceChainToken.decimals);
        if (amountInt.eq(0)) {
            return 0;
        }
        const vUsdInSystemPrecision = (0, calculation_1.swapToVUsd)(amountInt, sourceChainToken, await (0, utils_1.getPoolInfoByToken)(this.api, sourceChainToken));
        const usd = (0, calculation_1.swapFromVUsd)(vUsdInSystemPrecision, destinationChainToken, await (0, utils_1.getPoolInfoByToken)(this.api, destinationChainToken));
        const vUsdInDestinationPrecision = (0, calculation_1.fromSystemPrecision)(vUsdInSystemPrecision, destinationChainToken.decimals);
        return (0, calculation_1.getFeePercent)(vUsdInDestinationPrecision, usd);
    }
    async getAmountToBeReceivedAndGasFeeOptions(amountToSendFloat, sourceChainToken, destinationChainToken, messenger) {
        (0, utils_1.validateAmountGtZero)(amountToSendFloat);
        (0, utils_1.validateAmountDecimals)("amountToSendFloat", amountToSendFloat, sourceChainToken.decimals);
        return {
            amountToSendFloat: (0, big_js_1.Big)(amountToSendFloat).toFixed(),
            amountToBeReceivedFloat: await this.getAmountToBeReceived(amountToSendFloat, sourceChainToken, destinationChainToken, messenger),
            gasFeeOptions: await this.getGasFeeOptions(sourceChainToken, destinationChainToken, messenger),
        };
    }
    async getAmountToSendAndGasFeeOptions(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, messenger) {
        (0, utils_1.validateAmountGtZero)(amountToBeReceivedFloat);
        (0, utils_1.validateAmountDecimals)("amountToBeReceivedFloat", amountToBeReceivedFloat, destinationChainToken.decimals);
        return {
            amountToSendFloat: await this.getAmountToSend(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, messenger),
            amountToBeReceivedFloat: (0, big_js_1.Big)(amountToBeReceivedFloat).toFixed(),
            gasFeeOptions: await this.getGasFeeOptions(sourceChainToken, destinationChainToken, messenger),
        };
    }
    async getAmountToBeReceived(amountToSendFloat, sourceChainToken, destinationChainToken, messenger) {
        const sourcePool = await (0, utils_1.getPoolInfoByToken)(this.api, sourceChainToken);
        const destPool = await (0, utils_1.getPoolInfoByToken)(this.api, destinationChainToken);
        return this.getAmountToBeReceivedFromPools(amountToSendFloat, sourceChainToken, destinationChainToken, sourcePool, destPool, messenger);
    }
    async getAmountToBeReceivedFromChain(amountToSendFloat, sourceChainToken, destinationChainToken, messenger, sourceProvider, destinationProvider) {
        const sourcePool = await this.pool.getPoolInfoFromChain(sourceChainToken, sourceProvider);
        const destPool = await this.pool.getPoolInfoFromChain(destinationChainToken, destinationProvider);
        return this.getAmountToBeReceivedFromPools(amountToSendFloat, sourceChainToken, destinationChainToken, sourcePool, destPool, messenger);
    }
    getAmountToBeReceivedFromPools(amountToSendFloat, sourceChainToken, destinationChainToken, sourcePool, destinationPool, messenger) {
        (0, utils_1.validateAmountGtZero)(amountToSendFloat);
        (0, utils_1.validateAmountDecimals)("amountToSendFloat", amountToSendFloat, sourceChainToken.decimals);
        const amountToSend = (0, calculation_1.convertFloatAmountToInt)(amountToSendFloat, sourceChainToken.decimals);
        if (messenger && messenger == core_api_model_1.Messenger.CCTP) {
            if (!sourceChainToken.cctpAddress || !destinationChainToken.cctpAddress || !sourceChainToken.cctpFeeShare) {
                throw new models_1.CCTPDoesNotSupportedError("Such route does not support CCTP protocol");
            }
            const result = amountToSend.mul((0, big_js_1.Big)(1).minus(sourceChainToken.cctpFeeShare)).round(0, big_js_1.Big.roundUp);
            const resultInDestPrecision = (0, calculation_1.convertAmountPrecision)(result, sourceChainToken.decimals, destinationChainToken.decimals).round(0);
            return (0, calculation_1.convertIntAmountToFloat)(resultInDestPrecision, destinationChainToken.decimals).toFixed();
        }
        if (messenger && messenger == core_api_model_1.Messenger.CCTP_V2) {
            if (!sourceChainToken.cctpV2Address || !destinationChainToken.cctpV2Address || !sourceChainToken.cctpV2FeeShare) {
                throw new models_1.CCTPDoesNotSupportedError("Such route does not support CCTP V2 protocol");
            }
            const result = amountToSend.mul((0, big_js_1.Big)(1).minus(sourceChainToken.cctpV2FeeShare)).round(0, big_js_1.Big.roundUp);
            const resultInDestPrecision = (0, calculation_1.convertAmountPrecision)(result, sourceChainToken.decimals, destinationChainToken.decimals).round(0);
            return (0, calculation_1.convertIntAmountToFloat)(resultInDestPrecision, destinationChainToken.decimals).toFixed();
        }
        const vUsd = (0, calculation_1.swapToVUsd)(amountToSend, sourceChainToken, sourcePool);
        return this.getAmountFromVUsdFormatted(vUsd, destinationChainToken, destinationPool).float;
    }
    async getAmountToSend(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, messenger) {
        const sourcePool = await (0, utils_1.getPoolInfoByToken)(this.api, sourceChainToken);
        const destPool = await (0, utils_1.getPoolInfoByToken)(this.api, destinationChainToken);
        return this.getAmountToSendFromPools(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, sourcePool, destPool, messenger);
    }
    async getAmountToSendFromChain(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, messenger, sourceProvider, destinationProvider) {
        const sourcePool = await this.pool.getPoolInfoFromChain(sourceChainToken, sourceProvider);
        const destPool = await this.pool.getPoolInfoFromChain(destinationChainToken, destinationProvider);
        return this.getAmountToSendFromPools(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, sourcePool, destPool, messenger);
    }
    getAmountToSendFromPools(amountToBeReceivedFloat, sourceChainToken, destinationChainToken, sourcePool, destinationPool, messenger) {
        (0, utils_1.validateAmountGtZero)(amountToBeReceivedFloat);
        (0, utils_1.validateAmountDecimals)("amountToBeReceivedFloat", amountToBeReceivedFloat, destinationChainToken.decimals);
        const amountToBeReceived = (0, calculation_1.convertFloatAmountToInt)(amountToBeReceivedFloat, destinationChainToken.decimals);
        if (messenger && messenger == core_api_model_1.Messenger.CCTP) {
            if (!sourceChainToken.cctpAddress || !destinationChainToken.cctpAddress || !sourceChainToken.cctpFeeShare) {
                throw new models_1.CCTPDoesNotSupportedError("Such route does not support CCTP protocol");
            }
            const result = amountToBeReceived.div((0, big_js_1.Big)(1).minus(sourceChainToken.cctpFeeShare)).round(0, big_js_1.Big.roundDown);
            const resultInSourcePrecision = (0, calculation_1.convertAmountPrecision)(result, destinationChainToken.decimals, sourceChainToken.decimals).round(0);
            return (0, calculation_1.convertIntAmountToFloat)(resultInSourcePrecision, sourceChainToken.decimals).toFixed();
        }
        if (messenger && messenger == core_api_model_1.Messenger.CCTP_V2) {
            if (!sourceChainToken.cctpV2Address || !destinationChainToken.cctpV2Address || !sourceChainToken.cctpV2FeeShare) {
                throw new models_1.CCTPDoesNotSupportedError("Such route does not support CCTP V2 protocol");
            }
            const result = amountToBeReceived.div((0, big_js_1.Big)(1).minus(sourceChainToken.cctpV2FeeShare)).round(0, big_js_1.Big.roundDown);
            const resultInSourcePrecision = (0, calculation_1.convertAmountPrecision)(result, destinationChainToken.decimals, sourceChainToken.decimals).round(0);
            return (0, calculation_1.convertIntAmountToFloat)(resultInSourcePrecision, sourceChainToken.decimals).toFixed();
        }
        const vUsd = (0, calculation_1.swapFromVUsdReverse)(amountToBeReceived, destinationChainToken, destinationPool);
        const resultInt = (0, calculation_1.swapToVUsdReverse)(vUsd, sourceChainToken, sourcePool);
        if ((0, big_js_1.Big)(resultInt).lte(0)) {
            throw new models_1.InsufficientPoolLiquidityError();
        }
        return (0, calculation_1.convertIntAmountToFloat)(resultInt, sourceChainToken.decimals).toFixed();
    }
    async getGasFeeOptions(sourceChainToken, destinationChainToken, messenger) {
        return (0, utils_2.getGasFeeOptions)(sourceChainToken.allbridgeChainId, sourceChainToken.chainType, destinationChainToken.allbridgeChainId, sourceChainToken.decimals, messenger, this.api);
    }
    getAverageTransferTime(sourceChainToken, destinationChainToken, messenger) {
        return sourceChainToken.transferTime?.[destinationChainToken.chainSymbol]?.[messenger] ?? null;
    }
    async getPoolInfoByToken(token) {
        return await this.api.getPoolInfoByKey({ chainSymbol: token.chainSymbol, poolAddress: token.poolAddress });
    }
    async refreshPoolInfo(tokens) {
        if (tokens) {
            const tokensArray = tokens instanceof Array ? tokens : [tokens];
            const poolKeys = tokensArray.map((t) => {
                return { chainSymbol: t.chainSymbol, poolAddress: t.poolAddress };
            });
            return this.api.refreshPoolInfo(poolKeys);
        }
        return this.api.refreshPoolInfo();
    }
    aprInPercents(apr) {
        return (0, calculation_1.aprInPercents)(apr);
    }
    async getExtraGasMaxLimits(sourceChainToken, destinationChainToken) {
        return await (0, utils_2.getExtraGasMaxLimits)(sourceChainToken, destinationChainToken, this.api);
    }
    async getVUsdFromAmount(amount, amountFormat, sourceToken) {
        (0, utils_1.validateAmountGtZero)(amount);
        let amountInTokenPrecision;
        if (amountFormat == models_1.AmountFormat.FLOAT) {
            (0, utils_1.validateAmountDecimals)("amount", amount, sourceToken.decimals);
            amountInTokenPrecision = (0, calculation_1.convertFloatAmountToInt)(amount, sourceToken.decimals).toFixed();
        }
        else {
            amountInTokenPrecision = amount;
        }
        const vUsdAmount = (0, calculation_1.swapToVUsd)(amountInTokenPrecision, sourceToken, await (0, utils_1.getPoolInfoByToken)(this.api, sourceToken));
        return {
            [models_1.AmountFormat.INT]: vUsdAmount,
            [models_1.AmountFormat.FLOAT]: (0, calculation_1.convertIntAmountToFloat)(vUsdAmount, constants_1.SYSTEM_PRECISION).toFixed(),
        };
    }
    async getAmountFromVUsd(vUsdAmount, destToken) {
        return this.getAmountFromVUsdFormatted(vUsdAmount, destToken, await (0, utils_1.getPoolInfoByToken)(this.api, destToken));
    }
    getAmountFromVUsdFormatted(vUsdAmountInt, destToken, destPoolInfo) {
        (0, utils_1.validateAmountGtZero)(vUsdAmountInt);
        const amountResultInt = (0, calculation_1.swapFromVUsd)(vUsdAmountInt, destToken, destPoolInfo);
        if ((0, big_js_1.Big)(amountResultInt).lt(0)) {
            throw new models_1.InsufficientPoolLiquidityError();
        }
        return {
            [models_1.AmountFormat.INT]: amountResultInt,
            [models_1.AmountFormat.FLOAT]: (0, calculation_1.convertIntAmountToFloat)(amountResultInt, destToken.decimals).toFixed(),
        };
    }
    async swapAndBridgeFeeCalculation(amountInTokenPrecision, sourceToken, destToken) {
        return (0, swap_and_bridge_fee_calc_1.swapAndBridgeFeeCalculation)(amountInTokenPrecision, {
            decimals: sourceToken.decimals,
            feeShare: sourceToken.feeShare,
            poolInfo: await (0, utils_1.getPoolInfoByToken)(this.api, sourceToken),
        }, {
            decimals: destToken.decimals,
            feeShare: destToken.feeShare,
            poolInfo: await (0, utils_1.getPoolInfoByToken)(this.api, destToken),
        });
    }
    async swapAndBridgeFeeCalculationReverse(amountInTokenPrecision, sourceToken, destToken) {
        const result = (0, swap_and_bridge_fee_calc_1.swapAndBridgeFeeCalculationReverse)(amountInTokenPrecision, {
            decimals: sourceToken.decimals,
            feeShare: sourceToken.feeShare,
            poolInfo: await (0, utils_1.getPoolInfoByToken)(this.api, sourceToken),
        }, {
            decimals: destToken.decimals,
            feeShare: destToken.feeShare,
            poolInfo: await (0, utils_1.getPoolInfoByToken)(this.api, destToken),
        });
        const newAmount = result.swapFromVUsdCalcResult.amountIncludingCommissionInTokenPrecision;
        if ((0, big_js_1.Big)(newAmount).lt(0)) {
            throw new models_1.InsufficientPoolLiquidityError();
        }
        return result;
    }
    async getSendAmountDetails(amount, amountFormat, sourceToken, destToken) {
        (0, utils_1.validateAmountGtZero)(amount);
        let amountInTokenPrecision;
        if (amountFormat == models_1.AmountFormat.FLOAT) {
            (0, utils_1.validateAmountDecimals)("amount", amount, sourceToken.decimals);
            amountInTokenPrecision = (0, calculation_1.convertFloatAmountToInt)(amount, sourceToken.decimals).toFixed();
        }
        else {
            amountInTokenPrecision = amount;
        }
        return (0, swap_and_bridge_details_1.getSendAmountDetails)(amountInTokenPrecision, sourceToken, await (0, utils_1.getPoolInfoByToken)(this.api, sourceToken), destToken, await (0, utils_1.getPoolInfoByToken)(this.api, destToken));
    }
}
exports.AllbridgeCoreSdkService = AllbridgeCoreSdkService;
//# sourceMappingURL=index.js.map