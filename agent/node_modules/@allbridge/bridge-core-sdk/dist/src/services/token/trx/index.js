"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TronTokenService = exports.MAX_AMOUNT = void 0;
const exceptions_1 = require("../../../exceptions");
const models_1 = require("../../../models");
const ERC20_1 = __importDefault(require("../../models/abi/ERC20"));
const utils_1 = require("../../utils");
const trx_1 = require("../../utils/trx");
const token_1 = require("../models/token");
exports.MAX_AMOUNT = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
class TronTokenService extends token_1.ChainTokenService {
    tronWeb;
    api;
    chainType = models_1.ChainType.TRX;
    constructor(tronWeb, api) {
        super();
        this.tronWeb = tronWeb;
        this.api = api;
    }
    async getAllowance(params) {
        const { token: { tokenAddress }, owner, } = params;
        const tokenContract = await this.getContract(tokenAddress);
        const allowance = await tokenContract.methods.allowance(owner, params.spender).call();
        return allowance.toString();
    }
    async getTokenBalance(params) {
        const contract = await this.getContract(params.token.tokenAddress);
        const balance = await contract.balanceOf(params.account).call();
        return balance.toString();
    }
    async getNativeTokenBalance(params) {
        return (await this.tronWeb.trx.getBalance(params.account)).toString();
    }
    async approve(params) {
        const rawTransaction = await this.buildRawTransactionApprove(params);
        return await (0, trx_1.sendRawTransaction)(this.tronWeb, rawTransaction);
    }
    async buildRawTransactionApprove(params) {
        const { tokenAddress, spender, owner, amount } = params;
        const amountHex = amount == undefined ? exports.MAX_AMOUNT : (0, utils_1.amountToHex)(amount);
        const parameter = [
            { type: "address", value: spender },
            { type: "uint256", value: amountHex },
        ];
        const value = "0";
        const methodSignature = "approve(address,uint256)";
        return this.buildRawTransaction(tokenAddress, methodSignature, parameter, value, owner);
    }
    getContract(contractAddress) {
        return this.tronWeb.contract(ERC20_1.default.abi, contractAddress);
    }
    async buildRawTransaction(contractAddress, methodSignature, parameters, value, fromAddress) {
        const transactionObject = await this.tronWeb.transactionBuilder.triggerSmartContract(contractAddress, methodSignature, {
            callValue: +value,
        }, parameters, fromAddress);
        if (!transactionObject?.result?.result) {
            throw new exceptions_1.SdkError("Unknown error: " + JSON.stringify(transactionObject, null, 2));
        }
        return transactionObject.transaction;
    }
}
exports.TronTokenService = TronTokenService;
//# sourceMappingURL=index.js.map