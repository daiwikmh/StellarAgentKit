"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmTokenService = exports.MAX_AMOUNT = void 0;
const chain_enums_1 = require("../../../chains/chain.enums");
const ERC20_1 = __importDefault(require("../../models/abi/ERC20"));
const utils_1 = require("../../utils");
const models_1 = require("../models");
exports.MAX_AMOUNT = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
const USDT_TOKEN_ADDRESS = "0xdac17f958d2ee523a2206206994597c13d831ec7";
const POLYGON_GAS_LIMIT = 100_000;
class EvmTokenService extends models_1.ChainTokenService {
    web3;
    api;
    chainType = chain_enums_1.ChainType.EVM;
    constructor(web3, api) {
        super();
        this.web3 = web3;
        this.api = api;
    }
    getAllowance(params) {
        const tokenAddress = params.token.tokenAddress;
        const owner = params.owner;
        const spender = params.spender;
        return this.getAllowanceByTokenAddress(tokenAddress, owner, spender);
    }
    getAllowanceByTokenAddress(tokenAddress, owner, spender) {
        const tokenContract = this.getERC20Contract(tokenAddress);
        return tokenContract.methods.allowance(owner, spender).call();
    }
    async getTokenBalance(params) {
        return await this.getERC20Contract(params.token.tokenAddress).methods.balanceOf(params.account).call();
    }
    async getNativeTokenBalance(params) {
        return (await this.web3.eth.getBalance(params.account)).toString();
    }
    async approve(params) {
        if (this.isUsdt(params.tokenAddress)) {
            const allowance = await this.getAllowanceByTokenAddress(params.tokenAddress, params.owner, params.spender);
            if (allowance !== "0") {
                const rawTransaction = await this.buildRawTransactionApprove({
                    ...params,
                    amount: "0",
                });
                await this.sendRawTransaction(rawTransaction, params.chainSymbol);
            }
        }
        const rawTransaction = await this.buildRawTransactionApprove(params);
        return await this.sendRawTransaction(rawTransaction, params.chainSymbol);
    }
    isUsdt(tokenAddress) {
        return tokenAddress.toLowerCase() === USDT_TOKEN_ADDRESS;
    }
    buildRawTransactionApprove(params) {
        const { tokenAddress, spender, owner, amount } = params;
        const tokenContract = this.getERC20Contract(tokenAddress);
        const approveMethod = tokenContract.methods.approve(spender, amount == undefined ? exports.MAX_AMOUNT : (0, utils_1.amountToHex)(amount));
        return Promise.resolve({
            from: owner,
            to: tokenAddress,
            value: "0",
            data: approveMethod.encodeABI(),
        });
    }
    async sendRawTransaction(rawTransaction, chainSymbol) {
        const transactionConfig = rawTransaction;
        // prettier-ignore
        const feeOptions = { maxPriorityFeePerGas: undefined, maxFeePerGas: undefined };
        if (chainSymbol === chain_enums_1.ChainSymbol.POL) {
            transactionConfig.gas = POLYGON_GAS_LIMIT;
        }
        else {
            transactionConfig.gas = await this.web3.eth.estimateGas(rawTransaction);
        }
        const { transactionHash } = await this.web3.eth.sendTransaction({
            ...transactionConfig,
            ...feeOptions,
        });
        return { txId: transactionHash.toString() };
    }
    getERC20Contract(contractAddress) {
        return new this.web3.eth.Contract(ERC20_1.default.abi, contractAddress);
    }
}
exports.EvmTokenService = EvmTokenService;
//# sourceMappingURL=index.js.map