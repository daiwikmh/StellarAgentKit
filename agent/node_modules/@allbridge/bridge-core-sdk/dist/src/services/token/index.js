"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultTokenService = void 0;
const big_js_1 = require("big.js");
const tronweb_1 = require("tronweb");
const web3_1 = require("web3");
const chains_1 = require("../../chains");
const index_1 = require("../../index");
const models_1 = require("../../models");
const calculation_1 = require("../../utils/calculation");
const utils_1 = require("../../utils/utils");
const evm_1 = require("./evm");
const sol_1 = require("./sol");
const srb_1 = require("./srb");
const sui_1 = require("./sui");
const trx_1 = require("./trx");
class DefaultTokenService {
    api;
    nodeRpcUrlsConfig;
    params;
    constructor(api, nodeRpcUrlsConfig, params) {
        this.api = api;
        this.nodeRpcUrlsConfig = nodeRpcUrlsConfig;
        this.params = params;
    }
    async getAllowance(params, provider) {
        const allowanceInt = await this.getChainTokenService(params.token.chainSymbol, params.owner, provider).getAllowance(params);
        return (0, calculation_1.convertIntAmountToFloat)(allowanceInt, params.token.decimals).toFixed();
    }
    async checkAllowance(params, provider) {
        (0, utils_1.validateAmountGtZero)(params.amount);
        (0, utils_1.validateAmountDecimals)("amount", params.amount, params.token.decimals);
        return this.getChainTokenService(params.token.chainSymbol, params.owner, provider).checkAllowance(this.prepareCheckAllowanceParams(params));
    }
    async approve(provider, approveData) {
        if (approveData.amount) {
            (0, utils_1.validateAmountGtZero)(approveData.amount);
            (0, utils_1.validateAmountDecimals)("amount", approveData.amount, approveData.token.decimals);
        }
        return this.getChainTokenService(approveData.token.chainSymbol, approveData.owner, provider).approve(this.prepareApproveParams(approveData));
    }
    async buildRawTransactionApprove(approveData, provider) {
        if (approveData.amount) {
            (0, utils_1.validateAmountGtZero)(approveData.amount);
            (0, utils_1.validateAmountDecimals)("amount", approveData.amount, approveData.token.decimals);
        }
        return this.getChainTokenService(approveData.token.chainSymbol, approveData.owner, provider).buildRawTransactionApprove(this.prepareApproveParams(approveData));
    }
    async getTokenBalance(params, provider) {
        const tokenBalance = await this.getChainTokenService(params.token.chainSymbol, params.account, provider).getTokenBalance(params);
        if (params.token.decimals) {
            return (0, calculation_1.convertIntAmountToFloat)(tokenBalance, params.token.decimals).toFixed();
        }
        return tokenBalance;
    }
    async getNativeTokenBalance(params, provider) {
        const tokenBalance = await this.getChainTokenService(params.chainSymbol, params.account, provider).getNativeTokenBalance(params);
        return {
            [models_1.AmountFormat.INT]: tokenBalance,
            [models_1.AmountFormat.FLOAT]: (0, calculation_1.convertIntAmountToFloat)(tokenBalance, chains_1.Chains.getChainDecimalsByType(chains_1.Chains.getChainProperty(params.chainSymbol).chainType)).toFixed(),
        };
    }
    getChainTokenService(chainSymbol, ownerAddress, provider) {
        switch (chains_1.Chains.getChainProperty(chainSymbol).chainType) {
            case index_1.ChainType.EVM: {
                if (provider) {
                    return new evm_1.EvmTokenService(provider, this.api);
                }
                else {
                    const nodeRpcUrl = this.nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol);
                    return new evm_1.EvmTokenService(new web3_1.Web3(nodeRpcUrl), this.api);
                }
            }
            case index_1.ChainType.TRX: {
                if (provider) {
                    return new trx_1.TronTokenService(provider, this.api);
                }
                else {
                    const nodeRpcUrl = this.nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol);
                    const tronWeb = new tronweb_1.TronWeb({ fullHost: nodeRpcUrl });
                    tronWeb.setAddress(ownerAddress);
                    return new trx_1.TronTokenService(tronWeb, this.api);
                }
            }
            case index_1.ChainType.SOLANA: {
                const nodeRpcUrl = this.nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol);
                return new sol_1.SolanaTokenService(nodeRpcUrl, this.api);
            }
            case index_1.ChainType.SRB: {
                return new srb_1.SrbTokenService(this.nodeRpcUrlsConfig, this.params, this.api);
            }
            case index_1.ChainType.SUI: {
                return new sui_1.SuiTokenService(this.nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol), this.api);
            }
        }
    }
    prepareCheckAllowanceParams(params) {
        return {
            ...params,
            amount: (0, calculation_1.convertFloatAmountToInt)(params.amount, params.token.decimals),
        };
    }
    prepareApproveParams(approveData) {
        return {
            tokenAddress: approveData.token.tokenAddress,
            owner: approveData.owner,
            spender: approveData.spender,
            chainSymbol: approveData.token.chainSymbol,
            amount: approveData.amount == undefined ? undefined : (0, big_js_1.Big)(approveData.amount).toFixed(),
        };
    }
}
exports.DefaultTokenService = DefaultTokenService;
//# sourceMappingURL=index.js.map