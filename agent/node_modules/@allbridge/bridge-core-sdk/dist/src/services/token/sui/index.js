"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiTokenService = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const client_1 = require("@mysten/sui/client");
const chain_enums_1 = require("../../../chains/chain.enums");
const exceptions_1 = require("../../../exceptions");
const paginated_1 = require("../../utils/sui/paginated");
const models_1 = require("../models");
class SuiTokenService extends models_1.ChainTokenService {
    suiRpcUrl;
    api;
    chainType = chain_enums_1.ChainType.SUI;
    suiClient;
    constructor(suiRpcUrl, api) {
        super();
        this.suiRpcUrl = suiRpcUrl;
        this.api = api;
        this.suiClient = new client_1.SuiClient({
            url: this.suiRpcUrl,
        });
    }
    approve(params) {
        throw new exceptions_1.MethodNotSupportedError();
    }
    buildRawTransactionApprove(params) {
        throw new exceptions_1.MethodNotSupportedError();
    }
    getAllowance(params) {
        throw new exceptions_1.MethodNotSupportedError();
    }
    async getTokenBalance(params) {
        if (!params.token.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI token must contain 'originTokenAddress'");
        }
        const balance = await this.suiClient.getBalance({
            owner: params.account,
            coinType: params.token.originTokenAddress,
        });
        return balance.totalBalance;
    }
    async getNativeTokenBalance(params) {
        const coinsData = await (0, paginated_1.fetchAllPagesRecursive)((cursor) => this.suiClient.getCoins({
            owner: params.account,
            cursor,
        }));
        if (coinsData.length === 0) {
            return "0";
        }
        return coinsData.reduce((total, element) => total + BigInt(element.balance), BigInt(0)).toString();
    }
}
exports.SuiTokenService = SuiTokenService;
//# sourceMappingURL=index.js.map