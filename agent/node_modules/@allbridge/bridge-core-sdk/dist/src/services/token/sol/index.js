"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaTokenService = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const chain_enums_1 = require("../../../chains/chain.enums");
const exceptions_1 = require("../../../exceptions");
const sol_1 = require("../../utils/sol");
const accounts_1 = require("../../utils/sol/accounts");
const token_1 = require("../models/token");
class SolanaTokenService extends token_1.ChainTokenService {
    solanaRpcUrl;
    api;
    chainType = chain_enums_1.ChainType.SOLANA;
    constructor(solanaRpcUrl, api) {
        super();
        this.solanaRpcUrl = solanaRpcUrl;
        this.api = api;
    }
    approve(params) {
        throw new exceptions_1.MethodNotSupportedError();
    }
    buildRawTransactionApprove(params) {
        throw new exceptions_1.MethodNotSupportedError();
    }
    buildAnchorProvider(accountAddress) {
        const connection = new web3_js_1.Connection(this.solanaRpcUrl, "confirmed");
        const publicKey = new web3_js_1.PublicKey(accountAddress);
        return new anchor_1.AnchorProvider(connection, 
        // @ts-expect-error enough wallet for fetch actions
        { publicKey: publicKey }, {
            preflightCommitment: "confirmed",
            commitment: "confirmed",
        });
    }
    getAllowance(params) {
        throw new exceptions_1.MethodNotSupportedError();
    }
    async getTokenBalance(params) {
        const { account, token } = params;
        try {
            const associatedAccount = await (0, accounts_1.getAssociatedAccount)(new web3_js_1.PublicKey(account), new web3_js_1.PublicKey(token.tokenAddress));
            const accountData = await (0, sol_1.getTokenAccountData)(associatedAccount, this.buildAnchorProvider(account));
            return accountData.amount.toString();
        }
        catch (e) {
            if (e instanceof Error) {
                e.message.startsWith("Account does not exist");
                return "0";
            }
            throw e;
        }
    }
    async getNativeTokenBalance(params) {
        return (await this.buildAnchorProvider(params.account).connection.getBalance(new web3_js_1.PublicKey(params.account))).toString();
    }
}
exports.SolanaTokenService = SolanaTokenService;
//# sourceMappingURL=index.js.map