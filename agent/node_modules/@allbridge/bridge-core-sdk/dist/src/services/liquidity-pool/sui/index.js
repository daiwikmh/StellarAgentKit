"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiPoolService = void 0;
const client_1 = require("@mysten/sui/client");
const transactions_1 = require("@mysten/sui/transactions");
const chain_enums_1 = require("../../../chains/chain.enums");
const exceptions_1 = require("../../../exceptions");
const calculation_1 = require("../../../utils/calculation");
const reified_1 = require("../../models/sui/_framework/reified");
const bridge_1 = require("../../models/sui/bridge");
const functions_1 = require("../../models/sui/bridge/bridge-interface/functions");
const structs_1 = require("../../models/sui/bridge/pool/structs");
const structs_2 = require("../../models/sui/bridge/user-deposit/structs");
const coins_1 = require("../../utils/sui/coins");
const paginated_1 = require("../../utils/sui/paginated");
const view_1 = require("../../utils/sui/view");
const models_1 = require("../models");
class SuiPoolService extends models_1.ChainPoolService {
    suiRpcUrl;
    api;
    chainType = chain_enums_1.ChainType.SUI;
    client;
    constructor(suiRpcUrl, api) {
        super();
        this.suiRpcUrl = suiRpcUrl;
        this.api = api;
        this.client = new client_1.SuiClient({
            url: suiRpcUrl,
        });
    }
    async getUserBalanceInfo(accountAddress, token) {
        if (!token.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI token must contain 'originTokenAddress'");
        }
        const suiAddresses = token.suiAddresses;
        if (!suiAddresses) {
            throw new exceptions_1.SdkError("SUI token must contain 'suiAddresses'");
        }
        (0, bridge_1.setAddress)(suiAddresses.bridgeAddress, suiAddresses.bridgeAddressOrigin);
        const deposits = await this.fetchDeposits(accountAddress, token.originTokenAddress);
        const total = deposits.reduce((total, element) => {
            if (element.data) {
                total.lpAmount += BigInt(element.data.content.fields.lp_amount);
                total.rewardDebt += BigInt(element.data.content.fields.reward_debt);
                return total;
            }
            else {
                throw new exceptions_1.SdkError("Deposits fetch failed");
            }
        }, { lpAmount: BigInt(0), rewardDebt: BigInt(0) });
        return new models_1.UserBalance({ lpAmount: total.lpAmount.toString(), rewardDebt: total.rewardDebt.toString() });
    }
    async fetchDeposits(accountAddress, tokenAddress) {
        return await (0, paginated_1.fetchAllPagesRecursive)((cursor) => this.client.getOwnedObjects({
            owner: accountAddress,
            filter: { StructType: structs_2.UserDeposit.phantom((0, reified_1.phantom)(tokenAddress)).phantomType },
            options: { showContent: true },
            cursor,
        }));
    }
    async getPoolInfoFromChain(token) {
        const suiAddresses = token.suiAddresses;
        if (!suiAddresses) {
            throw new exceptions_1.SdkError("SUI token must contain 'suiAddresses'");
        }
        (0, bridge_1.setAddress)(suiAddresses.bridgeAddress, suiAddresses.bridgeAddressOrigin);
        if (!token.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI token must contain 'originTokenAddress'");
        }
        const P = 48;
        const tx = new transactions_1.Transaction();
        (0, functions_1.pool)(tx, token.originTokenAddress, suiAddresses.bridgeObjectAddress);
        const res = await (0, view_1.suiView)(this.client, tx, structs_1.Pool.reified((0, reified_1.phantom)(token.originTokenAddress)));
        const tokenBalance = res.state.tokenBalance;
        const vUsdBalance = res.state.vusdBalance;
        const imbalance = (0, calculation_1.calculatePoolInfoImbalance)({ tokenBalance, vUsdBalance });
        return {
            dValue: res.state.d,
            aValue: res.state.a,
            totalLpAmount: res.rewards.lpSupply,
            vUsdBalance: vUsdBalance,
            tokenBalance: tokenBalance,
            accRewardPerShareP: res.rewards.accRewardPerShareP,
            p: P,
            imbalance,
        };
    }
    async buildRawTransactionDeposit(params) {
        const suiAddresses = params.token.suiAddresses;
        if (!suiAddresses) {
            throw new exceptions_1.SdkError("SUI token must contain 'suiAddresses'");
        }
        (0, bridge_1.setAddress)(suiAddresses.bridgeAddress, suiAddresses.bridgeAddressOrigin);
        if (!params.token.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI token must contain 'originTokenAddress'");
        }
        const coins = await (0, paginated_1.fetchAllPagesRecursive)((cursor) => this.client.getCoins({
            owner: params.accountAddress,
            coinType: params.token.originTokenAddress,
            cursor,
        }));
        if (coins.length === 0 || !coins[0]) {
            throw new exceptions_1.InvalidAmountError("No coins to deposit");
        }
        const firstCoin = coins[0];
        const tx = new transactions_1.Transaction();
        tx.setSender(params.accountAddress);
        const { depositObj, isNewDeposit } = await this.getDepositObject(params.accountAddress, params.token.originTokenAddress, tx);
        const [amountCoin] = (0, coins_1.getCoinsWithAmounts)([params.amount], coins, tx);
        if (!amountCoin) {
            throw new exceptions_1.InvalidAmountError("No coins to deposit");
        }
        if (!params.token.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI token must contain 'originTokenAddress'");
        }
        const rewards = (0, functions_1.deposit)(tx, params.token.originTokenAddress, {
            bridge: suiAddresses.bridgeObjectAddress,
            userDeposit: depositObj,
            coin: amountCoin,
        });
        tx.mergeCoins(firstCoin.coinObjectId, [rewards]);
        if (isNewDeposit) {
            tx.transferObjects([depositObj], params.accountAddress);
        }
        return await tx.toJSON({ client: this.client });
    }
    async getDepositObject(accountAddress, tokenAddress, tx) {
        const deposits = await this.fetchDeposits(accountAddress, tokenAddress);
        if (deposits.length === 0 || !deposits[0]) {
            const tokenType = (0, reified_1.phantom)(tokenAddress).phantomType;
            const depositObj = (0, functions_1.newUserDeposit)(tx, tokenType);
            return { depositObj, isNewDeposit: true };
        }
        else {
            if (deposits[0].data?.objectId) {
                return { depositObj: deposits[0].data.objectId, isNewDeposit: false };
            }
            else {
                throw new exceptions_1.SdkError("Something went wrong while deposit");
            }
        }
    }
    async buildRawTransactionWithdraw(params) {
        const suiAddresses = params.token.suiAddresses;
        if (!suiAddresses) {
            throw new exceptions_1.SdkError("SUI token must contain 'suiAddresses'");
        }
        (0, bridge_1.setAddress)(suiAddresses.bridgeAddress, suiAddresses.bridgeAddressOrigin);
        if (!params.token.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI token must contain 'originTokenAddress'");
        }
        const tokenType = (0, reified_1.phantom)(params.token.originTokenAddress).phantomType;
        const tx = new transactions_1.Transaction();
        tx.setSender(params.accountAddress);
        const { depositObj, isNewDeposit } = await this.getDepositObject(params.accountAddress, params.token.originTokenAddress, tx);
        if (isNewDeposit) {
            throw new exceptions_1.InvalidAmountError("No deposit found");
        }
        const rewards = (0, functions_1.withdraw)(tx, tokenType, {
            bridge: suiAddresses.bridgeObjectAddress,
            userDeposit: depositObj,
            amountLp: BigInt(params.amount),
        });
        const coins = await (0, paginated_1.fetchAllPagesRecursive)((cursor) => this.client.getCoins({
            owner: params.accountAddress,
            coinType: params.token.originTokenAddress,
            cursor,
        }));
        if (!rewards[0] || !rewards[1]) {
            throw new exceptions_1.SdkError("No rewards found");
        }
        if (coins[0]) {
            tx.mergeCoins(coins[0].coinObjectId, [rewards[0], rewards[1]]);
        }
        else {
            tx.mergeCoins(rewards[0], [rewards[1]]);
            tx.transferObjects([rewards[0]], params.accountAddress);
        }
        return await tx.toJSON({ client: this.client });
    }
    async buildRawTransactionClaimRewards(params) {
        const suiAddresses = params.token.suiAddresses;
        if (!suiAddresses) {
            throw new exceptions_1.SdkError("SUI token must contain 'suiAddresses'");
        }
        (0, bridge_1.setAddress)(suiAddresses.bridgeAddress, suiAddresses.bridgeAddressOrigin);
        if (!params.token.originTokenAddress) {
            throw new exceptions_1.SdkError("SUI token must contain 'originTokenAddress'");
        }
        const tokenType = (0, reified_1.phantom)(params.token.originTokenAddress).phantomType;
        const tx = new transactions_1.Transaction();
        tx.setSender(params.accountAddress);
        const { depositObj, isNewDeposit } = await this.getDepositObject(params.accountAddress, params.token.originTokenAddress, tx);
        if (isNewDeposit) {
            throw new exceptions_1.InvalidAmountError("No deposit found");
        }
        const reward = (0, functions_1.claimReward)(tx, tokenType, {
            bridge: suiAddresses.bridgeObjectAddress,
            userDeposit: depositObj,
        });
        const coins = await (0, paginated_1.fetchAllPagesRecursive)((cursor) => this.client.getCoins({
            owner: params.accountAddress,
            coinType: params.token.originTokenAddress,
            cursor,
        }));
        if (coins[0]) {
            tx.mergeCoins(coins[0].coinObjectId, [reward]);
        }
        else {
            tx.transferObjects([reward], params.accountAddress);
        }
        return await tx.toJSON({ client: this.client });
    }
}
exports.SuiPoolService = SuiPoolService;
//# sourceMappingURL=index.js.map