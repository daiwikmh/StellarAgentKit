"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SrbPoolService = void 0;
const index_1 = require("../../../index");
const models_1 = require("../../../models");
const calculation_1 = require("../../../utils/calculation");
const pool_contract_1 = require("../../models/srb/pool-contract");
const utils_1 = require("../../models/srb/utils");
const models_2 = require("../models");
class SrbPoolService extends models_2.ChainPoolService {
    nodeRpcUrlsConfig;
    params;
    api;
    chainType = index_1.ChainType.SRB;
    P = 48;
    constructor(nodeRpcUrlsConfig, params, api) {
        super();
        this.nodeRpcUrlsConfig = nodeRpcUrlsConfig;
        this.params = params;
        this.api = api;
    }
    async getUserBalanceInfo(accountAddress, token) {
        const poolContract = this.getContract(token.poolAddress);
        const result = await poolContract.get_user_deposit({ user: accountAddress });
        if ((0, utils_1.isErrorSorobanResult)(result)) {
            throw new models_1.SdkError();
        }
        const viewResultSoroban = (0, utils_1.getViewResultSoroban)(result);
        if (!viewResultSoroban) {
            throw new models_1.SdkError();
        }
        const userDeposit = viewResultSoroban.unwrap();
        return new models_2.UserBalance({
            lpAmount: userDeposit.lp_amount.toString(),
            rewardDebt: userDeposit.reward_debt.toString(),
        });
    }
    async getPoolInfoFromChain(token) {
        const poolContract = this.getContract(token.poolAddress);
        const result = await poolContract.get_pool();
        if ((0, utils_1.isErrorSorobanResult)(result)) {
            throw new models_1.SdkError();
        }
        const viewResultSoroban = (0, utils_1.getViewResultSoroban)(result);
        if (!viewResultSoroban) {
            throw new models_1.SdkError();
        }
        const pool = viewResultSoroban.unwrap();
        return {
            aValue: pool.a.toString(),
            accRewardPerShareP: pool.acc_reward_per_share_p.toString(),
            dValue: pool.d.toString(),
            tokenBalance: pool.token_balance.toString(),
            p: this.P,
            totalLpAmount: pool.total_lp_amount.toString(),
            vUsdBalance: pool.v_usd_balance.toString(),
            imbalance: (0, calculation_1.calculatePoolInfoImbalance)({
                tokenBalance: pool.token_balance.toString(),
                vUsdBalance: pool.v_usd_balance.toString(),
            }),
        };
    }
    async buildRawTransactionDeposit(params) {
        const poolContract = this.getContract(params.token.poolAddress, params.accountAddress);
        return (await poolContract.deposit({
            sender: params.accountAddress,
            amount: BigInt(params.amount),
        })).toXDR();
    }
    async buildRawTransactionWithdraw(params) {
        const poolContract = this.getContract(params.token.poolAddress, params.accountAddress);
        return (await poolContract.withdraw({
            sender: params.accountAddress,
            amount_lp: BigInt(params.amount),
        })).toXDR();
    }
    async buildRawTransactionClaimRewards(params) {
        const poolContract = this.getContract(params.token.poolAddress, params.accountAddress);
        return (await poolContract.claim_rewards({
            sender: params.accountAddress,
        })).toXDR();
    }
    getContract(address, sender) {
        const config = {
            publicKey: sender,
            contractId: address,
            networkPassphrase: this.params.sorobanNetworkPassphrase,
            rpcUrl: this.nodeRpcUrlsConfig.getNodeRpcUrl(index_1.ChainSymbol.SRB),
        };
        return new pool_contract_1.PoolContract(config);
    }
}
exports.SrbPoolService = SrbPoolService;
//# sourceMappingURL=index.js.map