"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultLiquidityPoolService = void 0;
exports.getChainPoolService = getChainPoolService;
const big_js_1 = require("big.js");
const timed_cache_1 = __importDefault(require("timed-cache"));
const tronweb_1 = require("tronweb");
const web3_1 = require("web3");
const chains_1 = require("../../chains");
const index_1 = require("../../index");
const calculation_1 = require("../../utils/calculation");
const constants_1 = require("../../utils/calculation/constants");
const utils_1 = require("../../utils/utils");
const calculation_2 = require("../utils/calculation");
const evm_1 = require("./evm");
const raw_pool_transaction_builder_1 = require("./raw-pool-transaction-builder");
const sol_1 = require("./sol");
const srb_1 = require("./srb");
const sui_1 = require("./sui");
const trx_1 = require("./trx");
class DefaultLiquidityPoolService {
    api;
    nodeRpcUrlsConfig;
    params;
    tokenService;
    rawTxBuilder;
    cache;
    constructor(api, nodeRpcUrlsConfig, params, tokenService) {
        this.api = api;
        this.nodeRpcUrlsConfig = nodeRpcUrlsConfig;
        this.params = params;
        this.tokenService = tokenService;
        this.rawTxBuilder = new raw_pool_transaction_builder_1.DefaultRawPoolTransactionBuilder(api, nodeRpcUrlsConfig, this.params, tokenService);
        const ttl = params.cachePoolInfoChainSec > 0 ? params.cachePoolInfoChainSec * 1000 : 20 * 1000;
        this.cache = new timed_cache_1.default({ defaultTtl: ttl });
    }
    async getAllowance(a, b) {
        if (b) {
            const provider = a;
            const params = b;
            return await this.tokenService.getAllowance({ ...params, spender: params.token.poolAddress }, provider);
        }
        else {
            const params = a;
            return await this.tokenService.getAllowance({ ...params, spender: params.token.poolAddress });
        }
    }
    async checkAllowance(a, b) {
        if (b) {
            const provider = a;
            const params = b;
            return this.tokenService.checkAllowance({ ...params, spender: params.token.poolAddress }, provider);
        }
        else {
            const params = a;
            return this.tokenService.checkAllowance({ ...params, spender: params.token.poolAddress });
        }
    }
    async approve(provider, approveData) {
        return this.tokenService.approve(provider, { ...approveData, spender: approveData.token.poolAddress });
    }
    async getAmountToBeDeposited(amount, token, provider) {
        (0, utils_1.validateAmountGtZero)(amount);
        (0, utils_1.validateAmountDecimals)("amount", amount, token.decimals);
        const pool = await this.getPoolInfoFromChain(token, provider);
        const { vUsdBalance, tokenBalance, aValue, dValue } = pool;
        const vUsd = (0, calculation_2.depositAmountToVUsd)(amount, aValue, dValue, tokenBalance, vUsdBalance);
        return (0, calculation_1.convertIntAmountToFloat)(vUsd, constants_1.SYSTEM_PRECISION).toFixed();
    }
    async getAmountToBeWithdrawn(amount, accountAddress, token, provider) {
        (0, utils_1.validateAmountGtZero)(amount);
        (0, utils_1.validateAmountDecimals)("amount", amount, token.decimals);
        const pool = await this.getPoolInfoFromChain(token, provider);
        const tokenAmountInSP = (0, calculation_2.vUsdToWithdrawalAmount)(amount);
        const tokenAmount = (0, calculation_1.fromSystemPrecision)(tokenAmountInSP, token.decimals);
        const userBalanceInfo = await this.getUserBalanceInfo(accountAddress, token, provider);
        const earned = userBalanceInfo.earned(pool) || "0";
        const commonAmount = (0, big_js_1.Big)(tokenAmount).plus(earned).toFixed();
        return (0, calculation_1.convertIntAmountToFloat)(commonAmount, token.decimals).toFixed();
    }
    async getUserBalanceInfo(accountAddress, token, provider) {
        return getChainPoolService(token.chainSymbol, this.api, this.nodeRpcUrlsConfig, this.params, provider).getUserBalanceInfo(accountAddress, token);
    }
    async getPoolInfoFromChain(token, provider) {
        const poolKey = { chainSymbol: token.chainSymbol, poolAddress: token.poolAddress };
        const fromCache = this.cache.get(poolKey);
        if (fromCache) {
            return fromCache;
        }
        else {
            const poolInfo = await getChainPoolService(token.chainSymbol, this.api, this.nodeRpcUrlsConfig, this.params, provider).getPoolInfoFromChain(token);
            this.cache.put(poolKey, poolInfo);
            this.api.cachePut({ chainSymbol: token.chainSymbol, poolAddress: token.poolAddress }, poolInfo);
            return poolInfo;
        }
    }
}
exports.DefaultLiquidityPoolService = DefaultLiquidityPoolService;
function getChainPoolService(chainSymbol, api, nodeRpcUrlsConfig, params, provider) {
    switch (chains_1.Chains.getChainProperty(chainSymbol).chainType) {
        case index_1.ChainType.EVM: {
            if (provider) {
                return new evm_1.EvmPoolService(provider, api);
            }
            else {
                const nodeRpcUrl = nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol);
                const web3 = new web3_1.Web3(nodeRpcUrl);
                web3.defaultReturnFormat = { number: web3_1.FMT_NUMBER.STR, bytes: web3_1.FMT_BYTES.HEX };
                return new evm_1.EvmPoolService(web3, api);
            }
        }
        case index_1.ChainType.TRX: {
            const nodeRpcUrl = nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol);
            const tronJsonRpc = params.tronJsonRpc;
            if (provider) {
                return new trx_1.TronPoolService(provider, api, tronJsonRpc);
            }
            else {
                const tronWeb = new tronweb_1.TronWeb({ fullHost: nodeRpcUrl });
                return new trx_1.TronPoolService(tronWeb, api, tronJsonRpc);
            }
        }
        case index_1.ChainType.SOLANA: {
            const nodeRpcUrl = nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol);
            return new sol_1.SolanaPoolService(nodeRpcUrl, api);
        }
        case index_1.ChainType.SRB: {
            return new srb_1.SrbPoolService(nodeRpcUrlsConfig, params, api);
        }
        case index_1.ChainType.SUI: {
            return new sui_1.SuiPoolService(nodeRpcUrlsConfig.getNodeRpcUrl(chainSymbol), api);
        }
    }
}
//# sourceMappingURL=index.js.map