"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaPoolService = void 0;
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const chain_enums_1 = require("../../../chains/chain.enums");
const calculation_1 = require("../../../utils/calculation");
const bridge_1 = require("../../models/sol/types/bridge");
const sol_1 = require("../../utils/sol");
const accounts_1 = require("../../utils/sol/accounts");
const compute_budget_1 = require("../../utils/sol/compute-budget");
const models_1 = require("../models");
const pool_1 = require("../models/pool");
class SolanaPoolService extends pool_1.ChainPoolService {
    solanaRpcUrl;
    api;
    chainType = chain_enums_1.ChainType.SOLANA;
    P = 48;
    constructor(solanaRpcUrl, api) {
        super();
        this.solanaRpcUrl = solanaRpcUrl;
        this.api = api;
    }
    async getUserBalanceInfo(accountAddress, token) {
        const provider = this.buildAnchorProvider(accountAddress);
        const bridge = this.getBridge(token.bridgeAddress, provider);
        const poolAccount = new web3_js_1.PublicKey(token.poolAddress);
        const poolAccountInfo = await bridge.account.pool.fetch(poolAccount);
        try {
            const userDepositAccount = await (0, accounts_1.getUserDepositAccount)(new web3_js_1.PublicKey(accountAddress), poolAccountInfo.mint, bridge.programId);
            const { lpAmount, rewardDebt } = await bridge.account.userDeposit.fetch(userDepositAccount);
            return new models_1.UserBalance({
                lpAmount: lpAmount.toString(),
                rewardDebt: rewardDebt.toString(),
            });
        }
        catch (ignoreError) {
            return new models_1.UserBalance({ lpAmount: "0", rewardDebt: "0" });
        }
    }
    async getPoolInfoFromChain(token) {
        const provider = this.buildAnchorProvider(token.bridgeAddress);
        const pool = await this.getBridge(token.bridgeAddress, provider).account.pool.fetch(token.poolAddress);
        const vUsdBalance = pool.vUsdBalance.toString();
        const tokenBalance = pool.tokenBalance.toString();
        const imbalance = (0, calculation_1.calculatePoolInfoImbalance)({ tokenBalance, vUsdBalance });
        return {
            dValue: pool.d.toString(),
            aValue: pool.a.toString(),
            totalLpAmount: pool.totalLpAmount.toString(),
            vUsdBalance,
            tokenBalance,
            accRewardPerShareP: pool.accRewardPerShareP.toString(),
            p: this.P,
            imbalance,
        };
    }
    async buildRawTransactionDeposit(params) {
        const { bridge, accounts, preInstructions } = await this.prepareDataForTransaction(params);
        const tx = await bridge.methods
            .deposit(new anchor_1.BN(params.amount))
            .accounts(accounts)
            .preInstructions(preInstructions)
            .transaction();
        tx.recentBlockhash = (await this.buildAnchorProvider(params.accountAddress).connection.getLatestBlockhash()).blockhash;
        tx.feePayer = new web3_js_1.PublicKey(params.accountAddress);
        await (0, compute_budget_1.addUnitLimitAndUnitPriceToTx)(tx, params.txFeeParams, this.solanaRpcUrl);
        return tx;
    }
    async buildRawTransactionWithdraw(params) {
        const { bridge, accounts, preInstructions } = await this.prepareDataForTransaction(params);
        const tx = await bridge.methods
            .withdraw(new anchor_1.BN(params.amount))
            .accounts(accounts)
            .preInstructions(preInstructions)
            .transaction();
        tx.recentBlockhash = (await this.buildAnchorProvider(params.accountAddress).connection.getLatestBlockhash()).blockhash;
        tx.feePayer = new web3_js_1.PublicKey(params.accountAddress);
        await (0, compute_budget_1.addUnitLimitAndUnitPriceToTx)(tx, params.txFeeParams, this.solanaRpcUrl);
        return tx;
    }
    async buildRawTransactionClaimRewards(params) {
        const { bridge, accounts, preInstructions } = await this.prepareDataForTransaction(params);
        const tx = await bridge.methods.claimRewards().accounts(accounts).preInstructions(preInstructions).transaction();
        tx.recentBlockhash = (await this.buildAnchorProvider(params.accountAddress).connection.getLatestBlockhash()).blockhash;
        tx.feePayer = new web3_js_1.PublicKey(params.accountAddress);
        await (0, compute_budget_1.addUnitLimitAndUnitPriceToTx)(tx, params.txFeeParams, this.solanaRpcUrl);
        return tx;
    }
    async prepareDataForTransaction(params) {
        const provider = this.buildAnchorProvider(params.accountAddress);
        const bridge = this.getBridge(params.token.bridgeAddress, provider);
        const { accounts, preInstructions } = await this._getLPTransactionData(bridge, params.token.poolAddress, params.accountAddress, provider);
        return { bridge, accounts, preInstructions };
    }
    getBridge(bridgeAddress, provider) {
        return new anchor_1.Program(bridge_1.IDL, bridgeAddress, provider);
    }
    buildAnchorProvider(accountAddress) {
        const connection = new web3_js_1.Connection(this.solanaRpcUrl, "confirmed");
        const publicKey = new web3_js_1.PublicKey(accountAddress);
        return new anchor_1.AnchorProvider(connection, 
        // @ts-expect-error enough wallet for fetch actions
        { publicKey: publicKey }, {
            preflightCommitment: "confirmed",
            commitment: "confirmed",
        });
    }
    async _getLPTransactionData(bridge, poolAddress, account, provider) {
        const user = new web3_js_1.PublicKey(account);
        const configAccount = await (0, accounts_1.getConfigAccount)(bridge.programId);
        const bridgeAuthority = await (0, accounts_1.getAuthorityAccount)(bridge.programId);
        const poolAccount = new web3_js_1.PublicKey(poolAddress);
        const poolAccountInfo = await bridge.account.pool.fetch(poolAccount);
        const tokenMintAccount = poolAccountInfo.mint;
        const userToken = await (0, accounts_1.getAssociatedAccount)(user, tokenMintAccount);
        const bridgeTokenAccount = await (0, accounts_1.getBridgeTokenAccount)(tokenMintAccount, bridge.programId);
        const userDepositAccount = await (0, accounts_1.getUserDepositAccount)(user, tokenMintAccount, bridge.programId);
        const preInstructions = [
            anchor_1.web3.ComputeBudgetProgram.setComputeUnitLimit({
                units: 1000000,
            }),
        ];
        try {
            await (0, sol_1.getTokenAccountData)(userToken, provider);
        }
        catch (ignoreError) {
            const associatedProgram = anchor_1.Spl.associatedToken(provider);
            const createUserTokenInstruction = await associatedProgram.methods
                .create()
                .accounts({
                mint: tokenMintAccount,
                owner: user,
                associatedAccount: userToken,
            })
                .instruction();
            preInstructions.push(createUserTokenInstruction);
        }
        try {
            await bridge.account.userDeposit.fetch(userDepositAccount);
        }
        catch (ignoreError) {
            const instruction = await bridge.methods
                .initDepositAccount()
                .accounts({
                mint: tokenMintAccount,
                user,
                userDeposit: userDepositAccount,
            })
                .instruction();
            preInstructions.push(instruction);
        }
        const accounts = {
            mint: tokenMintAccount,
            user,
            config: configAccount,
            pool: poolAccount,
            bridgeAuthority: bridgeAuthority,
            userDeposit: userDepositAccount,
            userToken,
            bridgeToken: bridgeTokenAccount,
        };
        return { accounts, preInstructions };
    }
}
exports.SolanaPoolService = SolanaPoolService;
//# sourceMappingURL=index.js.map