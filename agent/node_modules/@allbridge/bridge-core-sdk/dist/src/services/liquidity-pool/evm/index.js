"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmPoolService = void 0;
const web3_1 = require("web3");
const chain_enums_1 = require("../../../chains/chain.enums");
const calculation_1 = require("../../../utils/calculation");
const utils_1 = require("../../../utils/utils");
const Pool_1 = __importDefault(require("../../models/abi/Pool"));
const models_1 = require("../models");
class EvmPoolService extends models_1.ChainPoolService {
    web3;
    api;
    chainType = chain_enums_1.ChainType.EVM;
    P = 52;
    constructor(web3, api) {
        super();
        this.web3 = web3;
        this.api = api;
    }
    async getUserBalanceInfo(accountAddress, token) {
        let userBalanceInfo;
        try {
            userBalanceInfo = await (0, utils_1.promiseWithTimeout)(this.getUserBalanceInfoByBatch(accountAddress, token), `Cannot get UserBalanceInfo for ${token.name} on ${token.chainSymbol}`, 5000);
        }
        catch (ignoreError) {
            userBalanceInfo = await (0, utils_1.promiseWithTimeoutAndRetries)(() => this.getUserBalanceInfoPerProperty(accountAddress, token), `Cannot get UserBalanceInfo for ${token.name} on ${token.chainSymbol}`, 5, 2000);
        }
        return userBalanceInfo;
    }
    async getPoolInfoFromChain(token) {
        let poolInfo;
        try {
            poolInfo = await (0, utils_1.promiseWithTimeout)(this.getPoolInfoByBatch(token), `Cannot get PoolInfo for ${token.name} on ${token.chainSymbol}`, 5000);
        }
        catch (ignoreError) {
            poolInfo = await (0, utils_1.promiseWithTimeoutAndRetries)(() => this.getPoolInfoPerProperty(token), `Cannot get PoolInfo for ${token.name} on ${token.chainSymbol}`, 5, 2000);
        }
        return poolInfo;
    }
    async getUserBalanceInfoByBatch(accountAddress, token) {
        const batch = new this.web3.eth.BatchRequest();
        const poolContract = this.getPoolContract(token.poolAddress);
        const userRewardDebtAbi = poolContract.methods.userRewardDebt(accountAddress).encodeABI();
        const balanceOfAbi = poolContract.methods.balanceOf(accountAddress).encodeABI();
        batch.add({
            method: "eth_call",
            params: [{ to: token.poolAddress, data: userRewardDebtAbi }, "latest"],
        });
        batch.add({
            method: "eth_call",
            params: [{ to: token.poolAddress, data: balanceOfAbi }, "latest"],
        });
        const [rewardDebtResult, lpAmountResult] = await batch.execute();
        if (rewardDebtResult && lpAmountResult && !rewardDebtResult.error && !lpAmountResult.error) {
            return new models_1.UserBalance({
                lpAmount: web3_1.Web3.utils.toBigInt(lpAmountResult.result).toString(),
                rewardDebt: web3_1.Web3.utils.toBigInt(rewardDebtResult.result).toString(),
            });
        }
        throw new Error("Batched failed");
    }
    async getUserBalanceInfoPerProperty(accountAddress, token) {
        const rewardDebt = (await this.getPoolContract(token.poolAddress).methods.userRewardDebt(accountAddress).call()).toString();
        const lpAmount = (await this.getPoolContract(token.poolAddress).methods.balanceOf(accountAddress).call()).toString();
        return new models_1.UserBalance({ lpAmount, rewardDebt });
    }
    async getPoolInfoByBatch(token) {
        const batch = new this.web3.eth.BatchRequest();
        const poolContract = this.getPoolContract(token.poolAddress);
        const aAbi = poolContract.methods.a().encodeABI();
        const dAbi = poolContract.methods.d().encodeABI();
        const tokenBalanceAbi = poolContract.methods.tokenBalance().encodeABI();
        const vUsdBalanceAbi = poolContract.methods.vUsdBalance().encodeABI();
        const totalSupplyAbi = poolContract.methods.totalSupply().encodeABI();
        const accRewardPerSharePAbi = poolContract.methods.accRewardPerShareP().encodeABI();
        batch.add({
            method: "eth_call",
            params: [{ to: token.poolAddress, data: aAbi }, "latest"],
        });
        batch.add({
            method: "eth_call",
            params: [{ to: token.poolAddress, data: dAbi }, "latest"],
        });
        batch.add({
            method: "eth_call",
            params: [{ to: token.poolAddress, data: tokenBalanceAbi }, "latest"],
        });
        batch.add({
            method: "eth_call",
            params: [{ to: token.poolAddress, data: vUsdBalanceAbi }, "latest"],
        });
        batch.add({
            method: "eth_call",
            params: [{ to: token.poolAddress, data: totalSupplyAbi }, "latest"],
        });
        batch.add({
            method: "eth_call",
            params: [{ to: token.poolAddress, data: accRewardPerSharePAbi }, "latest"],
        });
        const [aResult, dResult, tokenBalanceResult, vUsdBalanceResult, totalSupplyResult, accRewardPerSharePResult] = await batch.execute();
        if (aResult &&
            dResult &&
            tokenBalanceResult &&
            vUsdBalanceResult &&
            totalSupplyResult &&
            accRewardPerSharePResult &&
            !aResult.error &&
            !dResult.error &&
            !tokenBalanceResult.error &&
            !vUsdBalanceResult.error &&
            !totalSupplyResult.error &&
            !accRewardPerSharePResult.error) {
            const tokenBalanceStr = web3_1.Web3.utils.toBigInt(tokenBalanceResult.result).toString();
            const vUsdBalanceStr = web3_1.Web3.utils.toBigInt(vUsdBalanceResult.result).toString();
            const imbalance = (0, calculation_1.calculatePoolInfoImbalance)({ tokenBalance: tokenBalanceStr, vUsdBalance: vUsdBalanceStr });
            return {
                aValue: web3_1.Web3.utils.toBigInt(aResult.result).toString(),
                dValue: web3_1.Web3.utils.toBigInt(dResult.result).toString(),
                tokenBalance: tokenBalanceStr,
                vUsdBalance: vUsdBalanceStr,
                totalLpAmount: web3_1.Web3.utils.toBigInt(totalSupplyResult.result).toString(),
                accRewardPerShareP: web3_1.Web3.utils.toBigInt(accRewardPerSharePResult.result).toString(),
                p: this.P,
                imbalance,
            };
        }
        throw new Error("Batched failed");
    }
    async getPoolInfoPerProperty(token) {
        const poolContract = this.getPoolContract(token.poolAddress);
        const aValue = (await poolContract.methods.a().call()).toString();
        const dValue = (await poolContract.methods.d().call()).toString();
        const tokenBalance = (await poolContract.methods.tokenBalance().call()).toString();
        const vUsdBalance = (await poolContract.methods.vUsdBalance().call()).toString();
        const totalLpAmount = (await poolContract.methods.totalSupply().call()).toString();
        const accRewardPerShareP = (await poolContract.methods.accRewardPerShareP().call()).toString();
        const imbalance = (0, calculation_1.calculatePoolInfoImbalance)({ tokenBalance, vUsdBalance });
        return {
            aValue,
            dValue,
            tokenBalance,
            vUsdBalance,
            totalLpAmount,
            accRewardPerShareP,
            p: this.P,
            imbalance,
        };
    }
    async buildRawTransactionDeposit(params) {
        return Promise.resolve({
            ...this.buildTxParams(params),
            data: this.getPoolContract(params.token.poolAddress).methods.deposit(params.amount).encodeABI(),
        });
    }
    async buildRawTransactionWithdraw(params) {
        return Promise.resolve({
            ...this.buildTxParams(params),
            data: this.getPoolContract(params.token.poolAddress).methods.withdraw(params.amount).encodeABI(),
        });
    }
    async buildRawTransactionClaimRewards(params) {
        return Promise.resolve({
            ...this.buildTxParams(params),
            data: this.getPoolContract(params.token.poolAddress).methods.claimRewards().encodeABI(),
        });
    }
    buildTxParams(params) {
        return {
            from: params.accountAddress,
            to: params.token.poolAddress,
            value: "0",
        };
    }
    getPoolContract(contractAddress) {
        return new this.web3.eth.Contract(Pool_1.default.abi, contractAddress);
    }
}
exports.EvmPoolService = EvmPoolService;
//# sourceMappingURL=index.js.map