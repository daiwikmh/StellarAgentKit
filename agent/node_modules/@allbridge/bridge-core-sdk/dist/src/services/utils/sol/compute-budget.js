"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addUnitLimitAndUnitPriceToTx = addUnitLimitAndUnitPriceToTx;
exports.addUnitLimitAndUnitPriceToVersionedTx = addUnitLimitAndUnitPriceToVersionedTx;
const web3_js_1 = require("@solana/web3.js");
const big_js_1 = require("big.js");
const exceptions_1 = require("../../../exceptions");
const calculation_1 = require("../../../utils/calculation");
const utils_1 = require("../../../utils/sol/utils");
const models_1 = require("../../models");
async function addUnitLimitAndUnitPriceToTx(transaction, txFeeParams, solanaRpcUrl) {
    const connection = new web3_js_1.Connection(solanaRpcUrl, "confirmed");
    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
    const simUnitsConsumed = (await connection.simulateTransaction(transaction)).value.unitsConsumed;
    await addUnitLimitAndUnitPriceToInstructions(transaction.instructions, simUnitsConsumed, txFeeParams, connection);
}
async function addUnitLimitAndUnitPriceToVersionedTx(transaction, txFeeParams, solanaRpcUrl) {
    const connection = new web3_js_1.Connection(solanaRpcUrl, "confirmed");
    const addressLookupTableAccounts = await (0, utils_1.fetchAddressLookupTableAccountsFromTx)(transaction, connection);
    const message = web3_js_1.TransactionMessage.decompile(transaction.message, {
        addressLookupTableAccounts: addressLookupTableAccounts,
    });
    if (transaction.serialize().length > 1232) {
        throw new exceptions_1.TxTooLargeError();
    }
    // const simUnitsConsumed = (await connection.simulateTransaction(transaction, { replaceRecentBlockhash: true })).value
    //   .unitsConsumed!;
    const simUnitsConsumed = 769230; // 1000000/1.3
    await addUnitLimitAndUnitPriceToInstructions(message.instructions, simUnitsConsumed, txFeeParams, connection);
    transaction.message = message.compileToV0Message(addressLookupTableAccounts);
}
async function addUnitLimitAndUnitPriceToInstructions(instructions, simUnitsConsumed, txFeeParams, connection) {
    if (simUnitsConsumed > 0) {
        const units = updateUnitLimit(simUnitsConsumed, instructions);
        if (txFeeParams?.solana) {
            const solanaTxFee = txFeeParams.solana;
            if (solanaTxFee === models_1.SolanaAutoTxFee) {
                await updateUnitPrice(instructions, connection);
            }
            else if ("pricePerUnitInMicroLamports" in solanaTxFee) {
                await updateUnitPrice(instructions, connection, solanaTxFee.pricePerUnitInMicroLamports);
            }
            else {
                const pricePerUnitInMicroLamports = (0, big_js_1.Big)(solanaTxFee.extraFeeInLamports)
                    .div(units)
                    .mul((0, calculation_1.toPowBase10)(6))
                    .toFixed(0);
                await updateUnitPrice(instructions, connection, pricePerUnitInMicroLamports);
            }
        }
    }
}
function updateUnitLimit(simUnitsConsumed, instructions) {
    const computeUnitLimitIndex = instructions.findIndex((instruction) => instruction.programId.equals(web3_js_1.ComputeBudgetProgram.programId) &&
        web3_js_1.ComputeBudgetInstruction.decodeInstructionType(instruction) === "SetComputeUnitLimit");
    const units = Number((simUnitsConsumed * 1.3).toFixed(0));
    const computeUnitLimitInstruction = web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
        units: units,
    });
    if (computeUnitLimitIndex >= 0) {
        instructions[computeUnitLimitIndex] = computeUnitLimitInstruction;
    }
    else {
        instructions.push(computeUnitLimitInstruction);
    }
    return units.toString();
}
async function updateUnitPrice(instructions, connection, pricePerUnitInMicroLamports) {
    const computeUnitPriceIndex = instructions.findIndex((instruction) => instruction.programId.equals(web3_js_1.ComputeBudgetProgram.programId) &&
        web3_js_1.ComputeBudgetInstruction.decodeInstructionType(instruction) === "SetComputeUnitPrice");
    const unitPrice = pricePerUnitInMicroLamports
        ? BigInt(pricePerUnitInMicroLamports)
        : BigInt(await getAveragePrioritizationFee(connection));
    const computeUnitPriceInstruction = web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
        microLamports: unitPrice,
    });
    if (computeUnitPriceIndex >= 0) {
        instructions[computeUnitPriceIndex] = computeUnitPriceInstruction;
    }
    else {
        instructions.push(computeUnitPriceInstruction);
    }
    return unitPrice.toString();
}
async function getAveragePrioritizationFee(connection) {
    const prioritizationFees = await connection.getRecentPrioritizationFees();
    let sum = 0;
    for (const prioritizationFee of prioritizationFees) {
        sum += prioritizationFee.prioritizationFee;
    }
    return (sum / prioritizationFees.length).toFixed(0);
}
//# sourceMappingURL=compute-budget.js.map