"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAssociatedAccount = getAssociatedAccount;
exports.getConfigAccount = getConfigAccount;
exports.getLockAccount = getLockAccount;
exports.getPriceAccount = getPriceAccount;
exports.getAuthorityAccount = getAuthorityAccount;
exports.getCctpAuthorityAccount = getCctpAuthorityAccount;
exports.getBridgeTokenAccount = getBridgeTokenAccount;
exports.getOtherChainTokenAccount = getOtherChainTokenAccount;
exports.getChainBridgeAccount = getChainBridgeAccount;
exports.getGasUsageAccount = getGasUsageAccount;
exports.getSendMessageAccount = getSendMessageAccount;
exports.getUserDepositAccount = getUserDepositAccount;
exports.getCctpBridgeAccount = getCctpBridgeAccount;
exports.getCctpBridgeTokenAccount = getCctpBridgeTokenAccount;
exports.getCctpLockAccount = getCctpLockAccount;
exports.getCctpAccounts = getCctpAccounts;
const anchor = __importStar(require("@project-serum/anchor"));
const web3_js_1 = require("@solana/web3.js");
async function getAssociatedAccount(publicKey, mintAccount) {
    return anchor.utils.token.associatedAddress({
        mint: mintAccount,
        owner: publicKey,
    });
}
async function getConfigAccount(programId) {
    const [configPda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("config")], programId);
    return configPda;
}
async function getLockAccount(nonce, bridgeProgramId) {
    const [lockPda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("lock"), Uint8Array.from(nonce)], bridgeProgramId);
    return lockPda;
}
async function getPriceAccount(chainId, gasOracleProgramId) {
    const [pricePda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("price_v2"), Uint8Array.from([chainId])], gasOracleProgramId);
    return pricePda;
}
async function getAuthorityAccount(bridgeProgramId) {
    const configAccount = await getConfigAccount(bridgeProgramId);
    const [poolAuthority] = await web3_js_1.PublicKey.findProgramAddress([configAccount.toBuffer()], bridgeProgramId);
    return poolAuthority;
}
async function getCctpAuthorityAccount(cctpBridgeAccount, cctpBridgeProgramId) {
    const [poolAuthority] = await web3_js_1.PublicKey.findProgramAddress([cctpBridgeAccount.toBuffer()], cctpBridgeProgramId);
    return poolAuthority;
}
async function getBridgeTokenAccount(mintAccount, bridgeProgramId) {
    const [poolPda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("token"), mintAccount.toBytes()], bridgeProgramId);
    return poolPda;
}
async function getOtherChainTokenAccount(chainId, token, bridgeProgramId) {
    const [otherChainTokenPda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("other_bridge_token"), Buffer.from([chainId]), token], bridgeProgramId);
    return otherChainTokenPda;
}
async function getChainBridgeAccount(chainId, bridgeProgramId) {
    const [chainBridgePda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("chain_bridge"), Uint8Array.from([chainId])], bridgeProgramId);
    return chainBridgePda;
}
async function getGasUsageAccount(chainId, messengerProgramId) {
    const [chainBridgePda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("gas_usage"), Uint8Array.from([chainId])], messengerProgramId);
    return chainBridgePda;
}
async function getSendMessageAccount(messageWithSigner, messengerProgramId) {
    const [sentMessagePda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("sent_message"), messageWithSigner], messengerProgramId);
    return sentMessagePda;
}
async function getUserDepositAccount(userPublicKey, tokenMintAccount, bridgeProgramId) {
    const [userDepositPda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("user_deposit"), tokenMintAccount.toBytes(), userPublicKey.toBytes()], bridgeProgramId);
    return userDepositPda;
}
async function getCctpBridgeAccount(mintAccount, cctpBridgeProgramId) {
    const [configPda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("cctp_bridge"), mintAccount.toBytes()], cctpBridgeProgramId);
    return configPda;
}
async function getCctpBridgeTokenAccount(token, cctpBridgeProgramId) {
    const [poolPda] = await web3_js_1.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode("token"), token.toBytes()], cctpBridgeProgramId);
    return poolPda;
}
function getCctpLockAccount(cctpBridgeProgramId, messageSentEventDataAccount) {
    const [tokenMessengerEventAuthority] = web3_js_1.PublicKey.findProgramAddressSync([anchor.utils.bytes.utf8.encode("lock"), messageSentEventDataAccount.toBuffer()], cctpBridgeProgramId);
    return tokenMessengerEventAuthority;
}
function getCctpAccounts(domain, mintAccount, cctpTransmitterProgramId, cctpTokenMessengerMinter) {
    const messageTransmitterAccount = findProgramAddress("message_transmitter", cctpTransmitterProgramId);
    const tokenMessenger = findProgramAddress("token_messenger", cctpTokenMessengerMinter);
    const tokenMessengerEventAuthority = findProgramAddress("__event_authority", cctpTokenMessengerMinter);
    const tokenMinter = findProgramAddress("token_minter", cctpTokenMessengerMinter);
    const localToken = findProgramAddress("local_token", cctpTokenMessengerMinter, [mintAccount]);
    const remoteTokenMessengerKey = findProgramAddress("remote_token_messenger", cctpTokenMessengerMinter, [
        domain.toString(),
    ]);
    const authorityPda = findProgramAddress("sender_authority", cctpTokenMessengerMinter);
    return {
        messageTransmitterAccount,
        tokenMessenger,
        tokenMessengerEventAuthority,
        tokenMinter,
        localToken,
        remoteTokenMessengerKey,
        authorityPda,
    };
}
function findProgramAddress(label, programId, extraSeeds = []) {
    const seeds = [Buffer.from(anchor.utils.bytes.utf8.encode(label))];
    for (const extraSeed of extraSeeds) {
        if (typeof extraSeed === "string") {
            seeds.push(Buffer.from(anchor.utils.bytes.utf8.encode(extraSeed)));
        }
        else if (Array.isArray(extraSeed)) {
            seeds.push(Buffer.from(Uint8Array.from(extraSeed)));
        }
        else if (Buffer.isBuffer(extraSeed)) {
            seeds.push(Buffer.from(Uint8Array.from(extraSeed)));
        }
        else {
            seeds.push(Buffer.from(Uint8Array.from(extraSeed.toBuffer())));
        }
    }
    const res = web3_js_1.PublicKey.findProgramAddressSync(seeds, programId);
    return res[0];
}
//# sourceMappingURL=accounts.js.map