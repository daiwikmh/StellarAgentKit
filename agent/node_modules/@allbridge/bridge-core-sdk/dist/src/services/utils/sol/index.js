"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTokenAccountData = getTokenAccountData;
exports.getVUsdAmount = getVUsdAmount;
exports.getMessage = getMessage;
const anchor_1 = require("@project-serum/anchor");
/* eslint-disable-next-line  import/no-named-as-default */
const big_js_1 = __importDefault(require("big.js"));
const web3_1 = require("web3");
const exceptions_1 = require("../../../exceptions");
const calculation_1 = require("../../../utils/calculation");
async function getTokenAccountData(account, provider) {
    return await anchor_1.Spl.token(provider).account.token.fetch(account);
}
async function getVUsdAmount(amount, bridge, poolAccount) {
    const poolAccountInfo = await bridge.account.pool.fetch(poolAccount);
    const decimals = poolAccountInfo.decimals;
    const feeShare = (0, big_js_1.default)(poolAccountInfo.feeShareBp.toString()).div(10000).toFixed();
    const poolInfo = {
        aValue: poolAccountInfo.a.toString(),
        dValue: poolAccountInfo.d.toString(),
        totalLpAmount: poolAccountInfo.totalLpAmount.toString(),
        tokenBalance: poolAccountInfo.tokenBalance.toString(),
        vUsdBalance: poolAccountInfo.vUsdBalance.toString(),
        accRewardPerShareP: poolAccountInfo.accRewardPerShareP.toString(),
    };
    return (0, calculation_1.swapToVUsd)(amount, { decimals, feeShare }, poolInfo);
}
function getMessage(args) {
    const amount = args.amount;
    const recipient = "0x" + args.recipient.toString("hex");
    const sourceChainId = args.sourceChainId;
    const destinationsChainId = args.destinationChainId;
    const receiveToken = "0x" + args.receiveToken.toString("hex");
    const nonce = "0x" + args.nonce.toString("hex");
    const messenger = 1;
    const chainBridge = "0x" + args.chainBridge.toString("hex");
    const message = web3_1.Web3.utils.encodePacked({ t: "uint256", v: amount }, { t: "bytes32", v: recipient }, { t: "uint256", v: sourceChainId }, { t: "bytes32", v: receiveToken }, { t: "uint256", v: nonce }, { t: "uint8", v: messenger });
    if (!message) {
        throw new exceptions_1.SdkError("message cannot be undefined");
    }
    const hash = web3_1.Web3.utils.keccak256(Buffer.from(message.replace("0x", ""), "hex"));
    const hashBuffer = Buffer.from(hash.replace("0x", ""), "hex");
    hashBuffer[0] = sourceChainId;
    hashBuffer[1] = destinationsChainId;
    const messageWithSigner = web3_1.Web3.utils.encodePacked({ t: "bytes32", v: "0x" + hashBuffer.toString("hex") }, { t: "bytes32", v: chainBridge });
    if (!messageWithSigner) {
        throw new exceptions_1.InvalidTxError("messageWithSigner cannot be undefined");
    }
    const hashWithSigner = web3_1.Web3.utils.keccak256(Buffer.from(messageWithSigner.replace("0x", ""), "hex"));
    const hashWithSignerBuffer = Buffer.from(hashWithSigner.replace("0x", ""), "hex");
    hashWithSignerBuffer[0] = hashBuffer[0];
    hashWithSignerBuffer[1] = hashBuffer[1];
    return hashWithSignerBuffer;
}
//# sourceMappingURL=index.js.map