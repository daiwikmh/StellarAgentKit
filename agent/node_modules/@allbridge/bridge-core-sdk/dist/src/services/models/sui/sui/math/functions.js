"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.max = max;
exports.diff = diff;
exports.divideAndRoundUp = divideAndRoundUp;
exports.min = min;
exports.pow = pow;
exports.sqrt = sqrt;
exports.sqrtU128 = sqrtU128;
// @ts-nocheck
const __1 = require("..");
const util_1 = require("../../_framework/util");
function max(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::math::max`,
        arguments: [(0, util_1.pure)(tx, args.x, `u64`), (0, util_1.pure)(tx, args.y, `u64`)],
    });
}
function diff(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::math::diff`,
        arguments: [(0, util_1.pure)(tx, args.x, `u64`), (0, util_1.pure)(tx, args.y, `u64`)],
    });
}
function divideAndRoundUp(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::math::divide_and_round_up`,
        arguments: [(0, util_1.pure)(tx, args.x, `u64`), (0, util_1.pure)(tx, args.y, `u64`)],
    });
}
function min(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::math::min`,
        arguments: [(0, util_1.pure)(tx, args.x, `u64`), (0, util_1.pure)(tx, args.y, `u64`)],
    });
}
function pow(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::math::pow`,
        arguments: [(0, util_1.pure)(tx, args.base, `u64`), (0, util_1.pure)(tx, args.exponent, `u8`)],
    });
}
function sqrt(tx, x) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::math::sqrt`,
        arguments: [(0, util_1.pure)(tx, x, `u64`)],
    });
}
function sqrtU128(tx, x) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::math::sqrt_u128`,
        arguments: [(0, util_1.pure)(tx, x, `u128`)],
    });
}
//# sourceMappingURL=functions.js.map