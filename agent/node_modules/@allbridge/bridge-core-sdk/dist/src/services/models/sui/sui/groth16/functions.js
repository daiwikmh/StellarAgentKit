"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bls12381 = bls12381;
exports.bn254 = bn254;
exports.prepareVerifyingKey = prepareVerifyingKey;
exports.prepareVerifyingKeyInternal = prepareVerifyingKeyInternal;
exports.proofPointsFromBytes = proofPointsFromBytes;
exports.publicProofInputsFromBytes = publicProofInputsFromBytes;
exports.pvkFromBytes = pvkFromBytes;
exports.pvkToBytes = pvkToBytes;
exports.verifyGroth16Proof = verifyGroth16Proof;
exports.verifyGroth16ProofInternal = verifyGroth16ProofInternal;
// @ts-nocheck
const __1 = require("..");
const util_1 = require("../../_framework/util");
function bls12381(tx) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::bls12381`,
        arguments: [],
    });
}
function bn254(tx) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::bn254`,
        arguments: [],
    });
}
function prepareVerifyingKey(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::prepare_verifying_key`,
        arguments: [(0, util_1.obj)(tx, args.curve), (0, util_1.pure)(tx, args.verifyingKey, `vector<u8>`)],
    });
}
function prepareVerifyingKeyInternal(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::prepare_verifying_key_internal`,
        arguments: [(0, util_1.pure)(tx, args.curve, `u8`), (0, util_1.pure)(tx, args.verifyingKey, `vector<u8>`)],
    });
}
function proofPointsFromBytes(tx, bytes) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::proof_points_from_bytes`,
        arguments: [(0, util_1.pure)(tx, bytes, `vector<u8>`)],
    });
}
function publicProofInputsFromBytes(tx, bytes) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::public_proof_inputs_from_bytes`,
        arguments: [(0, util_1.pure)(tx, bytes, `vector<u8>`)],
    });
}
function pvkFromBytes(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::pvk_from_bytes`,
        arguments: [
            (0, util_1.pure)(tx, args.vkGammaAbcG1Bytes, `vector<u8>`),
            (0, util_1.pure)(tx, args.alphaG1BetaG2Bytes, `vector<u8>`),
            (0, util_1.pure)(tx, args.gammaG2NegPcBytes, `vector<u8>`),
            (0, util_1.pure)(tx, args.deltaG2NegPcBytes, `vector<u8>`),
        ],
    });
}
function pvkToBytes(tx, pvk) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::pvk_to_bytes`,
        arguments: [(0, util_1.obj)(tx, pvk)],
    });
}
function verifyGroth16Proof(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::verify_groth16_proof`,
        arguments: [
            (0, util_1.obj)(tx, args.curve),
            (0, util_1.obj)(tx, args.preparedVerifyingKey),
            (0, util_1.obj)(tx, args.publicProofInputs),
            (0, util_1.obj)(tx, args.proofPoints),
        ],
    });
}
function verifyGroth16ProofInternal(tx, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::groth16::verify_groth16_proof_internal`,
        arguments: [
            (0, util_1.pure)(tx, args.curve, `u8`),
            (0, util_1.pure)(tx, args.vkGammaAbcG1Bytes, `vector<u8>`),
            (0, util_1.pure)(tx, args.alphaG1BetaG2Bytes, `vector<u8>`),
            (0, util_1.pure)(tx, args.gammaG2NegPcBytes, `vector<u8>`),
            (0, util_1.pure)(tx, args.deltaG2NegPcBytes, `vector<u8>`),
            (0, util_1.pure)(tx, args.publicProofInputs, `vector<u8>`),
            (0, util_1.pure)(tx, args.proofPoints, `vector<u8>`),
        ],
    });
}
//# sourceMappingURL=functions.js.map