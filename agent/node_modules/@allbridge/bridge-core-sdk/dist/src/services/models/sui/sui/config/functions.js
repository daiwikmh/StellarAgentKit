"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.new_ = new_;
exports.transfer = transfer;
exports.existsWithType = existsWithType;
exports.addForNextEpoch = addForNextEpoch;
exports.borrowForNextEpochMut = borrowForNextEpochMut;
exports.existsWithTypeForNextEpoch = existsWithTypeForNextEpoch;
exports.readSetting = readSetting;
exports.readSettingForNextEpoch = readSettingForNextEpoch;
exports.readSettingImpl = readSettingImpl;
exports.removeForNextEpoch = removeForNextEpoch;
exports.share = share;
// @ts-nocheck
const __1 = require("..");
const util_1 = require("../../_framework/util");
const structs_1 = require("../object/structs");
function new_(tx, typeArg, cap) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::new`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.generic)(tx, `${typeArg}`, cap)],
    });
}
function transfer(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::transfer`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, args.config), (0, util_1.pure)(tx, args.owner, `address`)],
    });
}
function existsWithType(tx, typeArgs, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::exists_with_type`,
        typeArguments: typeArgs,
        arguments: [(0, util_1.obj)(tx, args.config), (0, util_1.generic)(tx, `${typeArgs[1]}`, args.name)],
    });
}
function addForNextEpoch(tx, typeArgs, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::add_for_next_epoch`,
        typeArguments: typeArgs,
        arguments: [
            (0, util_1.obj)(tx, args.config),
            (0, util_1.generic)(tx, `${typeArgs[0]}`, args.cap),
            (0, util_1.generic)(tx, `${typeArgs[1]}`, args.name),
            (0, util_1.generic)(tx, `${typeArgs[2]}`, args.value),
        ],
    });
}
function borrowForNextEpochMut(tx, typeArgs, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::borrow_for_next_epoch_mut`,
        typeArguments: typeArgs,
        arguments: [
            (0, util_1.obj)(tx, args.config),
            (0, util_1.generic)(tx, `${typeArgs[0]}`, args.cap),
            (0, util_1.generic)(tx, `${typeArgs[1]}`, args.name),
        ],
    });
}
function existsWithTypeForNextEpoch(tx, typeArgs, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::exists_with_type_for_next_epoch`,
        typeArguments: typeArgs,
        arguments: [(0, util_1.obj)(tx, args.config), (0, util_1.generic)(tx, `${typeArgs[1]}`, args.name)],
    });
}
function readSetting(tx, typeArgs, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::read_setting`,
        typeArguments: typeArgs,
        arguments: [(0, util_1.pure)(tx, args.config, `${structs_1.ID.$typeName}`), (0, util_1.generic)(tx, `${typeArgs[0]}`, args.name)],
    });
}
function readSettingForNextEpoch(tx, typeArgs, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::read_setting_for_next_epoch`,
        typeArguments: typeArgs,
        arguments: [(0, util_1.obj)(tx, args.config), (0, util_1.generic)(tx, `${typeArgs[1]}`, args.name)],
    });
}
function readSettingImpl(tx, typeArgs, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::read_setting_impl`,
        typeArguments: typeArgs,
        arguments: [(0, util_1.pure)(tx, args.config, `address`), (0, util_1.pure)(tx, args.name, `address`), (0, util_1.pure)(tx, args.currentEpoch, `u64`)],
    });
}
function removeForNextEpoch(tx, typeArgs, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::remove_for_next_epoch`,
        typeArguments: typeArgs,
        arguments: [
            (0, util_1.obj)(tx, args.config),
            (0, util_1.generic)(tx, `${typeArgs[0]}`, args.cap),
            (0, util_1.generic)(tx, `${typeArgs[1]}`, args.name),
        ],
    });
}
function share(tx, typeArg, config) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::config::share`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, config)],
    });
}
//# sourceMappingURL=functions.js.map