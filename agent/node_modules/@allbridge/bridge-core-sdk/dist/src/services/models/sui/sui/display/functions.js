"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = add;
exports.remove = remove;
exports.new_ = new_;
exports.version = version;
exports.addInternal = addInternal;
exports.addMultiple = addMultiple;
exports.fields = fields;
exports.createAndKeep = createAndKeep;
exports.createInternal = createInternal;
exports.edit = edit;
exports.isAuthorized = isAuthorized;
exports.newWithFields = newWithFields;
exports.updateVersion = updateVersion;
// @ts-nocheck
const __1 = require("..");
const structs_1 = require("../../_dependencies/source/0x1/string/structs");
const util_1 = require("../../_framework/util");
function add(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::add`,
        typeArguments: [typeArg],
        arguments: [
            (0, util_1.obj)(tx, args.self),
            (0, util_1.pure)(tx, args.name, `${structs_1.String.$typeName}`),
            (0, util_1.pure)(tx, args.value, `${structs_1.String.$typeName}`),
        ],
    });
}
function remove(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::remove`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, args.self), (0, util_1.pure)(tx, args.name, `${structs_1.String.$typeName}`)],
    });
}
function new_(tx, typeArg, pub) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::new`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, pub)],
    });
}
function version(tx, typeArg, d) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::version`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, d)],
    });
}
function addInternal(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::add_internal`,
        typeArguments: [typeArg],
        arguments: [
            (0, util_1.obj)(tx, args.display),
            (0, util_1.pure)(tx, args.name, `${structs_1.String.$typeName}`),
            (0, util_1.pure)(tx, args.value, `${structs_1.String.$typeName}`),
        ],
    });
}
function addMultiple(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::add_multiple`,
        typeArguments: [typeArg],
        arguments: [
            (0, util_1.obj)(tx, args.self),
            (0, util_1.pure)(tx, args.fields, `vector<${structs_1.String.$typeName}>`),
            (0, util_1.pure)(tx, args.values, `vector<${structs_1.String.$typeName}>`),
        ],
    });
}
function fields(tx, typeArg, d) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::fields`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, d)],
    });
}
function createAndKeep(tx, typeArg, pub) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::create_and_keep`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, pub)],
    });
}
function createInternal(tx, typeArg) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::create_internal`,
        typeArguments: [typeArg],
        arguments: [],
    });
}
function edit(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::edit`,
        typeArguments: [typeArg],
        arguments: [
            (0, util_1.obj)(tx, args.self),
            (0, util_1.pure)(tx, args.name, `${structs_1.String.$typeName}`),
            (0, util_1.pure)(tx, args.value, `${structs_1.String.$typeName}`),
        ],
    });
}
function isAuthorized(tx, typeArg, pub) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::is_authorized`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, pub)],
    });
}
function newWithFields(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::new_with_fields`,
        typeArguments: [typeArg],
        arguments: [
            (0, util_1.obj)(tx, args.pub),
            (0, util_1.pure)(tx, args.fields, `vector<${structs_1.String.$typeName}>`),
            (0, util_1.pure)(tx, args.values, `vector<${structs_1.String.$typeName}>`),
        ],
    });
}
function updateVersion(tx, typeArg, display) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::display::update_version`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, display)],
    });
}
//# sourceMappingURL=functions.js.map