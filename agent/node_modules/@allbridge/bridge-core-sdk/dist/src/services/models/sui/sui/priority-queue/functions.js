"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.insert = insert;
exports.new_ = new_;
exports.createEntries = createEntries;
exports.maxHeapifyRecursive = maxHeapifyRecursive;
exports.newEntry = newEntry;
exports.popMax = popMax;
exports.priorities = priorities;
exports.restoreHeapRecursive = restoreHeapRecursive;
// @ts-nocheck
const __1 = require("..");
const util_1 = require("../../_framework/util");
const structs_1 = require("./structs");
function insert(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::priority_queue::insert`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, args.pq), (0, util_1.pure)(tx, args.priority, `u64`), (0, util_1.generic)(tx, `${typeArg}`, args.value)],
    });
}
function new_(tx, typeArg, entries) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::priority_queue::new`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.vector)(tx, `${structs_1.Entry.$typeName}<${typeArg}>`, entries)],
    });
}
function createEntries(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::priority_queue::create_entries`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.pure)(tx, args.p, `vector<u64>`), (0, util_1.vector)(tx, `${typeArg}`, args.v)],
    });
}
function maxHeapifyRecursive(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::priority_queue::max_heapify_recursive`,
        typeArguments: [typeArg],
        arguments: [
            (0, util_1.vector)(tx, `${structs_1.Entry.$typeName}<${typeArg}>`, args.v),
            (0, util_1.pure)(tx, args.len, `u64`),
            (0, util_1.pure)(tx, args.i, `u64`),
        ],
    });
}
function newEntry(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::priority_queue::new_entry`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.pure)(tx, args.priority, `u64`), (0, util_1.generic)(tx, `${typeArg}`, args.value)],
    });
}
function popMax(tx, typeArg, pq) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::priority_queue::pop_max`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, pq)],
    });
}
function priorities(tx, typeArg, pq) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::priority_queue::priorities`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, pq)],
    });
}
function restoreHeapRecursive(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::priority_queue::restore_heap_recursive`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.vector)(tx, `${structs_1.Entry.$typeName}<${typeArg}>`, args.v), (0, util_1.pure)(tx, args.i, `u64`)],
    });
}
//# sourceMappingURL=functions.js.map