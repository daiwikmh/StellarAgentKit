"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.join = join;
exports.split = split;
exports.divideAndKeep = divideAndKeep;
exports.joinVec = joinVec;
exports.joinVecAndTransfer = joinVecAndTransfer;
exports.keep = keep;
exports.splitAndTransfer = splitAndTransfer;
exports.splitVec = splitVec;
// @ts-nocheck
const __1 = require("..");
const util_1 = require("../../_framework/util");
const structs_1 = require("../coin/structs");
function join(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::pay::join`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, args.self), (0, util_1.obj)(tx, args.coin)],
    });
}
function split(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::pay::split`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, args.coin), (0, util_1.pure)(tx, args.splitAmount, `u64`)],
    });
}
function divideAndKeep(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::pay::divide_and_keep`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, args.self), (0, util_1.pure)(tx, args.n, `u64`)],
    });
}
function joinVec(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::pay::join_vec`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, args.self), (0, util_1.vector)(tx, `${structs_1.Coin.$typeName}<${typeArg}>`, args.coins)],
    });
}
function joinVecAndTransfer(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::pay::join_vec_and_transfer`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.vector)(tx, `${structs_1.Coin.$typeName}<${typeArg}>`, args.coins), (0, util_1.pure)(tx, args.receiver, `address`)],
    });
}
function keep(tx, typeArg, c) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::pay::keep`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, c)],
    });
}
function splitAndTransfer(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::pay::split_and_transfer`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, args.c), (0, util_1.pure)(tx, args.amount, `u64`), (0, util_1.pure)(tx, args.recipient, `address`)],
    });
}
function splitVec(tx, typeArg, args) {
    return tx.moveCall({
        target: `${__1.PUBLISHED_AT}::pay::split_vec`,
        typeArguments: [typeArg],
        arguments: [(0, util_1.obj)(tx, args.self), (0, util_1.pure)(tx, args.splitAmounts, `vector<u64>`)],
    });
}
//# sourceMappingURL=functions.js.map