import { contract } from "@stellar/stellar-sdk";
import u128 = contract.u128;
import u32 = contract.u32;
import u256 = contract.u256;
import AssembledTransaction = contract.AssembledTransaction;
import Result = contract.Result;
import Option = contract.Option;
import ContractClient = contract.Client;
import ContractClientOptions = contract.ClientOptions;
export interface Swapped {
    receive_amount: u128;
    receive_token: Buffer;
    recipient: string;
    send_amount: u128;
    send_token: Buffer;
    sender: string;
}
export interface TokensSent {
    amount: u128;
    destination_chain_id: u32;
    nonce: u256;
    receive_token: Buffer;
    recipient: Buffer;
}
export interface TokensReceived {
    amount: u128;
    message: Buffer;
    nonce: u256;
    recipient: Buffer;
}
export interface ReceiveFee {
    bridge_transaction_cost: u128;
    extra_gas: u128;
    message_transaction_cost: u128;
}
export interface BridgingFeeFromTokens {
    fee_token_amount: u128;
    gas: u128;
}
export interface AnotherBridge {
    address: Buffer;
    tokens: Map<Buffer, boolean>;
}
export interface Bridge {
    /**
     * precomputed values of the scaling factor required for paying the bridging fee with stable tokens
     */
    bridging_fee_conversion_factor: Map<string, u128>;
    can_swap: boolean;
    /**
     * precomputed values to divide by to change the precision from the Gas Oracle precision to the token precision
     */
    from_gas_oracle_factor: Map<string, u128>;
    messenger: string;
    pools: Map<Buffer, string>;
    rebalancer: string;
}
export type DataKey = {
    tag: "OtherBridge";
    values: readonly [u32];
} | {
    tag: "SentMessage";
    values: readonly [Buffer];
} | {
    tag: "ReceivedMessage";
    values: readonly [Buffer];
};
export type Admin = readonly [string];
export type GasOracleAddress = readonly [string];
export type GasUsage = readonly [Map<u32, u128>];
export type NativeToken = readonly [string];
export type StopAuthority = readonly [string];
export declare const Errors: {
    0: {
        message: string;
    };
    1: {
        message: string;
    };
    2: {
        message: string;
    };
    3: {
        message: string;
    };
    4: {
        message: string;
    };
    5: {
        message: string;
    };
    6: {
        message: string;
    };
    7: {
        message: string;
    };
    8: {
        message: string;
    };
    9: {
        message: string;
    };
    10: {
        message: string;
    };
    11: {
        message: string;
    };
    12: {
        message: string;
    };
    103: {
        message: string;
    };
    104: {
        message: string;
    };
    105: {
        message: string;
    };
    106: {
        message: string;
    };
    107: {
        message: string;
    };
    108: {
        message: string;
    };
    109: {
        message: string;
    };
    203: {
        message: string;
    };
    204: {
        message: string;
    };
    205: {
        message: string;
    };
    206: {
        message: string;
    };
    207: {
        message: string;
    };
    208: {
        message: string;
    };
    209: {
        message: string;
    };
    210: {
        message: string;
    };
    211: {
        message: string;
    };
    212: {
        message: string;
    };
    214: {
        message: string;
    };
    215: {
        message: string;
    };
    216: {
        message: string;
    };
    217: {
        message: string;
    };
    218: {
        message: string;
    };
    300: {
        message: string;
    };
    301: {
        message: string;
    };
    302: {
        message: string;
    };
    303: {
        message: string;
    };
    400: {
        message: string;
    };
};
export interface BridgeContract {
    /**
     * Construct and simulate a initialize transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    initialize: ({ admin, messenger, gas_oracle, native_token, }: {
        admin: string;
        messenger: string;
        gas_oracle: string;
        native_token: string;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a swap_and_bridge transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    swap_and_bridge: ({ sender, token, amount, recipient, destination_chain_id, receive_token, nonce, gas_amount, fee_token_amount, }: {
        sender: string;
        token: string;
        amount: u128;
        recipient: Buffer;
        destination_chain_id: u32;
        receive_token: Buffer;
        nonce: u256;
        gas_amount: u128;
        fee_token_amount: u128;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a receive_tokens transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    receive_tokens: ({ sender, amount, recipient, source_chain_id, receive_token, nonce, receive_amount_min, extra_gas, }: {
        sender: string;
        amount: u128;
        recipient: string;
        source_chain_id: u32;
        receive_token: Buffer;
        nonce: u256;
        receive_amount_min: u128;
        extra_gas: Option<u128>;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a swap transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    swap: ({ sender, amount, token, receive_token, recipient, receive_amount_min, }: {
        sender: string;
        amount: u128;
        token: Buffer;
        receive_token: Buffer;
        recipient: string;
        receive_amount_min: u128;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a stop_swap transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    stop_swap: (options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a start_swap transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    start_swap: (options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a set_gas_oracle transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    set_gas_oracle: ({ new_address }: {
        new_address: string;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a set_stop_authority transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    set_stop_authority: ({ stop_authority }: {
        stop_authority: string;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a set_rebalancer transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    set_rebalancer: ({ rebalancer }: {
        rebalancer: string;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a set_messenger transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    set_messenger: ({ messenger }: {
        messenger: string;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a set_gas_usage transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    set_gas_usage: ({ chain_id, gas_usage }: {
        chain_id: u32;
        gas_usage: u128;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a register_bridge transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    register_bridge: ({ chain_id, bridge_address }: {
        chain_id: u32;
        bridge_address: Buffer;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a add_bridge_token transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    add_bridge_token: ({ chain_id, token_address }: {
        chain_id: u32;
        token_address: Buffer;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a remove_bridge_token transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    remove_bridge_token: ({ chain_id, token_address }: {
        chain_id: u32;
        token_address: Buffer;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a add_pool transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    add_pool: ({ pool, token }: {
        pool: string;
        token: string;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a withdraw_gas_tokens transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    withdraw_gas_tokens: ({ sender, amount }: {
        sender: string;
        amount: u128;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a withdraw_bridging_fee_in_tokens transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    withdraw_bridging_fee_in_tokens: ({ sender, token_address }: {
        sender: string;
        token_address: string;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a has_processed_message transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    has_processed_message: ({ message }: {
        message: Buffer;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<boolean>>>;
    /**
     * Construct and simulate a has_received_message transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    has_received_message: ({ message }: {
        message: Buffer;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<boolean>>>;
    /**
     * Construct and simulate a get_pool_address transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    get_pool_address: ({ token_address }: {
        token_address: Buffer;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<string>>>;
    /**
     * Construct and simulate a get_config transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    get_config: (options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<Bridge>>>;
    /**
     * Construct and simulate a get_stop_authority transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    get_stop_authority: (options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<string>>>;
    /**
     * Construct and simulate a get_transaction_cost transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    get_transaction_cost: ({ chain_id }: {
        chain_id: u32;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<u128>>>;
    /**
     * Construct and simulate a get_gas_usage transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    get_gas_usage: ({ chain_id }: {
        chain_id: u32;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<u128>>>;
    /**
     * Construct and simulate a get_admin transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    get_admin: (options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<string>>>;
    /**
     * Construct and simulate a get_gas_oracle transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    get_gas_oracle: (options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<string>>>;
    /**
     * Construct and simulate a get_another_bridge transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    get_another_bridge: ({ chain_id }: {
        chain_id: u32;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<AnotherBridge>>>;
    /**
     * Construct and simulate a set_admin transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    set_admin: ({ new_admin }: {
        new_admin: string;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
    /**
     * Construct and simulate a upgrade transaction. Returns an `AssembledTransaction` object which will have a `Result` field containing the Result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
     */
    upgrade: ({ new_wasm_hash }: {
        new_wasm_hash: Buffer;
    }, options?: {
        /**
         * The fee to pay for the transaction. Default: BASE_FEE
         */
        fee?: number;
        /**
         * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
         */
        timeoutInSeconds?: number;
        /**
         * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
         */
        simulate?: boolean;
    }) => Promise<AssembledTransaction<Result<void>>>;
}
export declare class BridgeContract extends ContractClient {
    readonly options: ContractClientOptions;
    constructor(options: ContractClientOptions);
    readonly fromJSON: {
        initialize: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        swap_and_bridge: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        receive_tokens: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        swap: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        stop_swap: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        start_swap: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        set_gas_oracle: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        set_stop_authority: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        set_rebalancer: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        set_messenger: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        set_gas_usage: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        register_bridge: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        add_bridge_token: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        remove_bridge_token: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        add_pool: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        withdraw_gas_tokens: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        withdraw_bridging_fee_in_tokens: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        has_processed_message: (json: string) => contract.AssembledTransaction<contract.Result<boolean, contract.ErrorMessage>>;
        has_received_message: (json: string) => contract.AssembledTransaction<contract.Result<boolean, contract.ErrorMessage>>;
        get_pool_address: (json: string) => contract.AssembledTransaction<contract.Result<string, contract.ErrorMessage>>;
        get_config: (json: string) => contract.AssembledTransaction<contract.Result<Bridge, contract.ErrorMessage>>;
        get_stop_authority: (json: string) => contract.AssembledTransaction<contract.Result<string, contract.ErrorMessage>>;
        get_transaction_cost: (json: string) => contract.AssembledTransaction<contract.Result<bigint, contract.ErrorMessage>>;
        get_gas_usage: (json: string) => contract.AssembledTransaction<contract.Result<bigint, contract.ErrorMessage>>;
        get_admin: (json: string) => contract.AssembledTransaction<contract.Result<string, contract.ErrorMessage>>;
        get_gas_oracle: (json: string) => contract.AssembledTransaction<contract.Result<string, contract.ErrorMessage>>;
        get_another_bridge: (json: string) => contract.AssembledTransaction<contract.Result<AnotherBridge, contract.ErrorMessage>>;
        set_admin: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
        upgrade: (json: string) => contract.AssembledTransaction<contract.Result<void, contract.ErrorMessage>>;
    };
}
