{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../../src/services/models/sui/_framework/util.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-nocheck\n\nimport { bcs, BcsType } from \"@mysten/sui/bcs\";\nimport {\n  Transaction,\n  TransactionArgument,\n  TransactionObjectArgument,\n  TransactionObjectInput,\n} from \"@mysten/sui/transactions\";\n\nexport interface FieldsWithTypes {\n  fields: Record<string, any>;\n  type: string;\n}\n\nexport type ObjectId = string;\n\nexport type PureArg = bigint | string | number | boolean | null | TransactionArgument | Array<PureArg>;\nexport type GenericArg =\n  | TransactionObjectInput\n  | PureArg\n  | Array<TransactionObjectInput>\n  | Array<PureArg>\n  | Array<GenericArg>;\n\nexport function splitGenericParameters(str: string, genericSeparators: [string, string] = [\"<\", \">\"]) {\n  const [left, right] = genericSeparators;\n  const tok: string[] = [];\n  let word = \"\";\n  let nestedAngleBrackets = 0;\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    if (char === left) {\n      nestedAngleBrackets++;\n    }\n    if (char === right) {\n      nestedAngleBrackets--;\n    }\n    if (nestedAngleBrackets === 0 && char === \",\") {\n      tok.push(word.trim());\n      word = \"\";\n      continue;\n    }\n    word += char;\n  }\n\n  tok.push(word.trim());\n\n  return tok;\n}\n\nexport function parseTypeName(name: string): {\n  typeName: string;\n  typeArgs: string[];\n} {\n  if (typeof name !== \"string\") {\n    throw new Error(`Illegal type passed as a name of the type: ${name}`);\n  }\n\n  const [left, right] = [\"<\", \">\"];\n\n  const l_bound = name.indexOf(left);\n  const r_bound = Array.from(name).reverse().indexOf(right);\n\n  // if there are no generics - exit gracefully.\n  if (l_bound === -1 && r_bound === -1) {\n    return { typeName: name, typeArgs: [] };\n  }\n\n  // if one of the bounds is not defined - throw an Error.\n  if (l_bound === -1 || r_bound === -1) {\n    throw new Error(`Unclosed generic in name '${name}'`);\n  }\n\n  const typeName = name.slice(0, l_bound);\n  const typeArgs = splitGenericParameters(name.slice(l_bound + 1, name.length - r_bound - 1), [left, right]);\n\n  return { typeName, typeArgs };\n}\n\nexport function isTransactionArgument(arg: GenericArg): arg is TransactionArgument {\n  if (!arg || typeof arg !== \"object\" || Array.isArray(arg)) {\n    return false;\n  }\n\n  return \"GasCoin\" in arg || \"Input\" in arg || \"Result\" in arg || \"NestedResult\" in arg;\n}\n\nexport function obj(tx: Transaction, arg: TransactionObjectInput) {\n  return isTransactionArgument(arg) ? arg : tx.object(arg);\n}\n\nexport function pure(tx: Transaction, arg: PureArg, type: string): TransactionArgument {\n  if (isTransactionArgument(arg)) {\n    return obj(tx, arg);\n  }\n\n  function getBcsForType(type: string): BcsType<any> {\n    const { typeName, typeArgs } = parseTypeName(type);\n    switch (typeName) {\n      case \"bool\":\n        return bcs.Bool;\n      case \"u8\":\n        return bcs.U8;\n      case \"u16\":\n        return bcs.U16;\n      case \"u32\":\n        return bcs.U32;\n      case \"u64\":\n        return bcs.U64;\n      case \"u128\":\n        return bcs.U128;\n      case \"u256\":\n        return bcs.U256;\n      case \"address\":\n        return bcs.Address;\n      case \"0x1::string::String\":\n      case \"0x1::ascii::String\":\n        return bcs.String;\n      case \"0x2::object::ID\":\n        return bcs.Address;\n      case \"0x1::option::Option\":\n        return bcs.option(getBcsForType(typeArgs[0]));\n      case \"vector\":\n        return bcs.vector(getBcsForType(typeArgs[0]));\n      default:\n        throw new Error(`invalid primitive type ${type}`);\n    }\n  }\n\n  function hasUndefinedOrNull(items: PureArg[]) {\n    for (const item of items) {\n      if (typeof item === \"undefined\" || item === null) {\n        return true;\n      }\n\n      if (Array.isArray(item)) {\n        return hasUndefinedOrNull(item);\n      }\n    }\n\n    return false;\n  }\n\n  function consistsOnlyOfPrimitiveValues(items: PureArg[]) {\n    for (const item of items) {\n      if (!Array.isArray(item)) {\n        if (item === null) {\n          continue;\n        }\n        switch (typeof item) {\n          case \"string\":\n          case \"number\":\n          case \"bigint\":\n          case \"boolean\":\n            continue;\n          default:\n            return false;\n        }\n      }\n\n      return consistsOnlyOfPrimitiveValues(item);\n    }\n\n    return true;\n  }\n\n  function hasPrimitiveValues(items: PureArg[]) {\n    for (const item of items) {\n      if (!Array.isArray(item)) {\n        switch (typeof item) {\n          case \"string\":\n          case \"number\":\n          case \"bigint\":\n          case \"boolean\":\n            return true;\n          default:\n            continue;\n        }\n      }\n\n      return hasPrimitiveValues(item);\n    }\n\n    return false;\n  }\n\n  // handle some cases when TransactionArgument is nested within a vector or option\n  const { typeName, typeArgs } = parseTypeName(type);\n  switch (typeName) {\n    case \"0x1::option::Option\":\n      if (arg === null) {\n        return tx.pure.option(\"bool\", null); // 'bool' is arbitrary\n      }\n      if (consistsOnlyOfPrimitiveValues([arg])) {\n        return tx.pure(getBcsForType(type).serialize(arg));\n      }\n      if (hasPrimitiveValues([arg])) {\n        throw new Error(\"mixing primitive and TransactionArgument values is not supported\");\n      }\n\n      // wrap it with some\n      return tx.moveCall({\n        target: `0x1::option::some`,\n        typeArguments: [typeArgs[0]],\n        arguments: [pure(tx, arg, typeArgs[0])],\n      });\n    case \"vector\":\n      if (!Array.isArray(arg)) {\n        throw new Error(\"expected an array for vector type\");\n      }\n      if (arg.length === 0) {\n        return tx.pure(bcs.vector(bcs.Bool).serialize([])); // bcs.Bool is arbitrary\n      }\n      if (hasUndefinedOrNull(arg)) {\n        throw new Error(\"the provided array contains undefined or null values\");\n      }\n      if (consistsOnlyOfPrimitiveValues(arg)) {\n        return tx.pure(getBcsForType(type).serialize(arg));\n      }\n      if (hasPrimitiveValues(arg)) {\n        throw new Error(\"mixing primitive and TransactionArgument values is not supported\");\n      }\n\n      return tx.makeMoveVec({\n        type: typeArgs[0],\n        elements: arg as Array<TransactionObjectArgument>,\n      });\n    default:\n      return tx.pure(getBcsForType(type).serialize(arg));\n  }\n}\n\nexport function option(tx: Transaction, type: string, arg: GenericArg | null) {\n  if (isTransactionArgument(arg)) {\n    return arg;\n  }\n\n  if (typeArgIsPure(type)) {\n    return pure(tx, arg as PureArg | TransactionArgument, `0x1::option::Option<${type}>`);\n  }\n\n  if (arg === null) {\n    return tx.moveCall({\n      target: `0x1::option::none`,\n      typeArguments: [type],\n      arguments: [],\n    });\n  }\n\n  // wrap it with some\n  const val = generic(tx, type, arg);\n  return tx.moveCall({\n    target: `0x1::option::some`,\n    typeArguments: [type],\n    arguments: [val],\n  });\n}\n\nexport function generic(tx: Transaction, type: string, arg: GenericArg) {\n  if (typeArgIsPure(type)) {\n    return pure(tx, arg as PureArg | TransactionArgument, type);\n  } else {\n    const { typeName, typeArgs } = parseTypeName(type);\n    if (typeName === \"vector\" && Array.isArray(arg)) {\n      const itemType = typeArgs[0];\n\n      return tx.makeMoveVec({\n        type: itemType,\n        elements: arg.map((item) => obj(tx, item as TransactionObjectInput)) as Array<TransactionObjectArgument>,\n      });\n    } else {\n      return obj(tx, arg as TransactionObjectInput);\n    }\n  }\n}\n\nexport function vector(tx: Transaction, itemType: string, items: Array<GenericArg> | TransactionArgument) {\n  if (typeof items === \"function\") {\n    throw new Error(\"Transaction plugins are not supported\");\n  }\n\n  if (typeArgIsPure(itemType)) {\n    return pure(tx, items as PureArg, `vector<${itemType}>`);\n  } else if (isTransactionArgument(items)) {\n    return items;\n  } else {\n    const { typeName: itemTypeName, typeArgs: itemTypeArgs } = parseTypeName(itemType);\n    if (itemTypeName === \"0x1::option::Option\") {\n      const elements = items.map((item) => option(tx, itemTypeArgs[0], item)) as Array<TransactionObjectArgument>;\n      return tx.makeMoveVec({\n        type: itemType,\n        elements,\n      });\n    }\n\n    return tx.makeMoveVec({\n      type: itemType,\n      elements: items as Array<TransactionObjectArgument>,\n    });\n  }\n}\n\nexport function typeArgIsPure(type: string): boolean {\n  const { typeName, typeArgs } = parseTypeName(type);\n  switch (typeName) {\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n    case \"address\":\n    case \"signer\":\n      return true;\n    case \"vector\":\n      return typeArgIsPure(typeArgs[0]);\n    case \"0x1::string::String\":\n    case \"0x1::ascii::String\":\n    case \"0x2::object::ID\":\n      return true;\n    case \"0x1::option::Option\":\n      return typeArgIsPure(typeArgs[0]);\n    default:\n      return false;\n  }\n}\n\nexport function compressSuiAddress(addr: string): string {\n  // remove leading zeros\n  const stripped = addr.split(\"0x\").join(\"\");\n  for (let i = 0; i < stripped.length; i++) {\n    if (stripped[i] !== \"0\") {\n      return `0x${stripped.substring(i)}`;\n    }\n  }\n  return \"0x0\";\n}\n\n// Recursively removes leading zeros from a type.\n// e.g. `0x00000002::module::Name<0x00001::a::C>` -> `0x2::module::Name<0x1::a::C>`\nexport function compressSuiType(type: string): string {\n  const { typeName, typeArgs } = parseTypeName(type);\n  switch (typeName) {\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n    case \"address\":\n    case \"signer\":\n      return typeName;\n    case \"vector\":\n      return `vector<${compressSuiType(typeArgs[0])}>`;\n    default: {\n      const tok = typeName.split(\"::\");\n      tok[0] = compressSuiAddress(tok[0]);\n      const compressedName = tok.join(\"::\");\n      if (typeArgs.length > 0) {\n        return `${compressedName}<${typeArgs.map((typeArg) => compressSuiType(typeArg)).join(\",\")}>`;\n      } else {\n        return compressedName;\n      }\n    }\n  }\n}\n\nexport function composeSuiType(typeName: string, ...typeArgs: string[]): string {\n  if (typeArgs.length > 0) {\n    return `${typeName}<${typeArgs.join(\", \")}>`;\n  } else {\n    return typeName;\n  }\n}\n"]}