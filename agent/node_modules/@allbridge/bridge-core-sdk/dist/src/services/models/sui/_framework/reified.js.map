{"version":3,"file":"reified.js","sourceRoot":"","sources":["../../../../../../src/services/models/sui/_framework/reified.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-nocheck\n\nimport { bcs, BcsType } from \"@mysten/sui/bcs\";\nimport { fromHEX, toHEX } from \"@mysten/sui/utils\";\nimport { FieldsWithTypes, compressSuiType, parseTypeName } from \"./util\";\nimport { SuiClient, SuiParsedData, SuiObjectData } from \"@mysten/sui/client\";\n\n// for backwards compatibility\nexport { vector } from \"./vector\";\n\nexport interface StructClass {\n  readonly $typeName: string;\n  readonly $fullTypeName: string;\n  readonly $typeArgs: string[];\n  readonly $isPhantom: readonly boolean[];\n  toJSONField(): Record<string, any>;\n  toJSON(): Record<string, any>;\n\n  __StructClass: true;\n}\n\nexport interface VectorClass {\n  readonly $typeName: \"vector\";\n  readonly $fullTypeName: string;\n  readonly $typeArgs: [string];\n  readonly $isPhantom: readonly [false];\n  toJSONField(): any[];\n  toJSON(): Record<string, any>;\n\n  readonly elements: any;\n\n  __VectorClass: true;\n}\n\nexport type Primitive = \"bool\" | \"u8\" | \"u16\" | \"u32\" | \"u64\" | \"u128\" | \"u256\" | \"address\";\nexport type TypeArgument = StructClass | Primitive | VectorClass;\n\nexport interface StructClassReified<T extends StructClass, Fields> {\n  typeName: T[\"$typeName\"]; // e.g., '0x2::balance::Balance', without type arguments\n  fullTypeName: ToTypeStr<T>; // e.g., '0x2::balance::Balance<0x2::sui:SUI>'\n  typeArgs: T[\"$typeArgs\"]; // e.g., ['0x2::sui:SUI']\n  isPhantom: T[\"$isPhantom\"]; // e.g., [true, false]\n  reifiedTypeArgs: Array<Reified<TypeArgument, any> | PhantomReified<PhantomTypeArgument>>;\n  bcs: BcsType<any>;\n  fromFields(fields: Record<string, any>): T;\n  fromFieldsWithTypes(item: FieldsWithTypes): T;\n  fromBcs(data: Uint8Array): T;\n  fromJSONField: (field: any) => T;\n  fromJSON: (json: Record<string, any>) => T;\n  fromSuiParsedData: (content: SuiParsedData) => T;\n  fromSuiObjectData: (data: SuiObjectData) => T;\n  fetch: (client: SuiClient, id: string) => Promise<T>;\n  new: (fields: Fields) => T;\n  kind: \"StructClassReified\";\n}\n\nexport interface VectorClassReified<T extends VectorClass, Elements> {\n  typeName: T[\"$typeName\"];\n  fullTypeName: ToTypeStr<T>;\n  typeArgs: T[\"$typeArgs\"];\n  isPhantom: readonly [false];\n  reifiedTypeArgs: Array<Reified<TypeArgument, any>>;\n  bcs: BcsType<any>;\n  fromFields(fields: any[]): T;\n  fromFieldsWithTypes(item: FieldsWithTypes): T;\n  fromBcs(data: Uint8Array): T;\n  fromJSONField: (field: any) => T;\n  fromJSON: (json: Record<string, any>) => T;\n  new: (elements: Elements) => T;\n  kind: \"VectorClassReified\";\n}\n\nexport type Reified<T extends TypeArgument, Fields> = T extends Primitive\n  ? Primitive\n  : T extends StructClass\n    ? StructClassReified<T, Fields>\n    : T extends VectorClass\n      ? VectorClassReified<T, Fields>\n      : never;\n\nexport type ToTypeArgument<\n  T extends Primitive | StructClassReified<StructClass, any> | VectorClassReified<VectorClass, any>,\n> = T extends Primitive\n  ? T\n  : T extends StructClassReified<infer U, any>\n    ? U\n    : T extends VectorClassReified<infer U, any>\n      ? U\n      : never;\n\nexport type ToPhantomTypeArgument<T extends PhantomReified<PhantomTypeArgument>> =\n  T extends PhantomReified<infer U> ? U : never;\n\nexport type PhantomTypeArgument = string;\n\nexport interface PhantomReified<P> {\n  phantomType: P;\n  kind: \"PhantomReified\";\n}\n\nexport function phantom<T extends Reified<TypeArgument, any>>(reified: T): PhantomReified<ToTypeStr<ToTypeArgument<T>>>;\nexport function phantom<P extends PhantomTypeArgument>(phantomType: P): PhantomReified<P>;\nexport function phantom(type: string | Reified<TypeArgument, any>): PhantomReified<string> {\n  if (typeof type === \"string\") {\n    return {\n      phantomType: type,\n      kind: \"PhantomReified\",\n    };\n  } else {\n    return {\n      phantomType: type.fullTypeName,\n      kind: \"PhantomReified\",\n    };\n  }\n}\n\nexport type ToTypeStr<T extends TypeArgument> = T extends Primitive\n  ? T\n  : T extends StructClass\n    ? T[\"$fullTypeName\"]\n    : T extends VectorClass\n      ? T[\"$fullTypeName\"]\n      : never;\n\nexport type PhantomToTypeStr<T extends PhantomTypeArgument> = T extends PhantomTypeArgument ? T : never;\n\nexport type ToJSON<T extends TypeArgument> = T extends \"bool\"\n  ? boolean\n  : T extends \"u8\"\n    ? number\n    : T extends \"u16\"\n      ? number\n      : T extends \"u32\"\n        ? number\n        : T extends \"u64\"\n          ? string\n          : T extends \"u128\"\n            ? string\n            : T extends \"u256\"\n              ? string\n              : T extends \"address\"\n                ? string\n                : T extends { $typeName: \"0x1::string::String\" }\n                  ? string\n                  : T extends { $typeName: \"0x1::ascii::String\" }\n                    ? string\n                    : T extends { $typeName: \"0x2::object::UID\" }\n                      ? string\n                      : T extends { $typeName: \"0x2::object::ID\" }\n                        ? string\n                        : T extends { $typeName: \"0x2::url::Url\" }\n                          ? string\n                          : T extends {\n                                $typeName: \"0x1::option::Option\";\n                                __inner: infer U extends TypeArgument;\n                              }\n                            ? ToJSON<U> | null\n                            : T extends VectorClass\n                              ? ReturnType<T[\"toJSONField\"]>\n                              : T extends StructClass\n                                ? ReturnType<T[\"toJSONField\"]>\n                                : never;\n\nexport type ToField<T extends TypeArgument> = T extends \"bool\"\n  ? boolean\n  : T extends \"u8\"\n    ? number\n    : T extends \"u16\"\n      ? number\n      : T extends \"u32\"\n        ? number\n        : T extends \"u64\"\n          ? bigint\n          : T extends \"u128\"\n            ? bigint\n            : T extends \"u256\"\n              ? bigint\n              : T extends \"address\"\n                ? string\n                : T extends { $typeName: \"0x1::string::String\" }\n                  ? string\n                  : T extends { $typeName: \"0x1::ascii::String\" }\n                    ? string\n                    : T extends { $typeName: \"0x2::object::UID\" }\n                      ? string\n                      : T extends { $typeName: \"0x2::object::ID\" }\n                        ? string\n                        : T extends { $typeName: \"0x2::url::Url\" }\n                          ? string\n                          : T extends {\n                                $typeName: \"0x1::option::Option\";\n                                __inner: infer U extends TypeArgument;\n                              }\n                            ? ToField<U> | null\n                            : T extends VectorClass\n                              ? T[\"elements\"]\n                              : T extends StructClass\n                                ? T\n                                : never;\n\nconst Address = bcs.bytes(32).transform({\n  input: (val: string) => fromHEX(val),\n  output: (val) => toHEX(val),\n});\n\nexport function toBcs<T extends Reified<TypeArgument, any>>(arg: T): BcsType<any> {\n  switch (arg) {\n    case \"bool\":\n      return bcs.bool();\n    case \"u8\":\n      return bcs.u8();\n    case \"u16\":\n      return bcs.u16();\n    case \"u32\":\n      return bcs.u32();\n    case \"u64\":\n      return bcs.u64();\n    case \"u128\":\n      return bcs.u128();\n    case \"u256\":\n      return bcs.u256();\n    case \"address\":\n      return Address;\n    default:\n      return arg.bcs;\n  }\n}\n\nexport function extractType<T extends Reified<TypeArgument, any>>(reified: T): ToTypeStr<ToTypeArgument<T>>;\nexport function extractType<T extends PhantomReified<PhantomTypeArgument>>(\n  reified: T\n): PhantomToTypeStr<ToPhantomTypeArgument<T>>;\nexport function extractType<T extends Reified<TypeArgument, any> | PhantomReified<PhantomTypeArgument>>(\n  reified: T\n): string;\nexport function extractType(reified: Reified<TypeArgument, any> | PhantomReified<string>): string {\n  switch (reified) {\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n    case \"bool\":\n    case \"address\":\n      return reified;\n  }\n  switch (reified.kind) {\n    case \"PhantomReified\":\n      return reified.phantomType;\n    case \"StructClassReified\":\n      return reified.fullTypeName;\n    case \"VectorClassReified\":\n      return reified.fullTypeName;\n  }\n\n  throw new Error(\"unreachable\");\n}\n\nexport function decodeFromFields(reified: Reified<TypeArgument, any>, field: any) {\n  switch (reified) {\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n      return field;\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return BigInt(field);\n    case \"address\":\n      return `0x${field}`;\n  }\n  if (reified.kind === \"VectorClassReified\") {\n    return reified.fromFields(field).elements;\n  }\n  switch (reified.typeName) {\n    case \"0x1::string::String\":\n    case \"0x1::ascii::String\":\n      return new TextDecoder().decode(Uint8Array.from(field.bytes)).toString();\n    case \"0x2::url::Url\":\n      return new TextDecoder().decode(Uint8Array.from(field.url.bytes)).toString();\n    case \"0x2::object::ID\":\n      return `0x${field.bytes}`;\n    case \"0x2::object::UID\":\n      return `0x${field.id.bytes}`;\n    case \"0x1::option::Option\": {\n      if (field.vec.length === 0) {\n        return null;\n      }\n      return (reified.fromFields(field) as any).vec[0];\n    }\n    default:\n      return reified.fromFields(field);\n  }\n}\n\nexport function decodeFromFieldsWithTypes(reified: Reified<TypeArgument, any>, item: any) {\n  switch (reified) {\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n      return item;\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return BigInt(item);\n    case \"address\":\n      return item;\n  }\n  if (reified.kind === \"VectorClassReified\") {\n    return reified.fromFieldsWithTypes(item).elements;\n  }\n  switch (reified.typeName) {\n    case \"0x1::string::String\":\n    case \"0x1::ascii::String\":\n    case \"0x2::url::Url\":\n    case \"0x2::object::ID\":\n      return item;\n    case \"0x2::object::UID\":\n      return item.id;\n    case \"0x2::balance::Balance\":\n      return reified.fromFields({ value: BigInt(item) });\n    case \"0x1::option::Option\": {\n      if (item === null) {\n        return null;\n      }\n      return decodeFromFieldsWithTypes((reified as any).reifiedTypeArgs[0], item);\n    }\n    default:\n      return reified.fromFieldsWithTypes(item);\n  }\n}\n\nexport function assertReifiedTypeArgsMatch(\n  fullType: string,\n  typeArgs: string[],\n  reifiedTypeArgs: Array<Reified<TypeArgument, any> | PhantomReified<string>>\n) {\n  if (reifiedTypeArgs.length !== typeArgs.length) {\n    throw new Error(\n      `provided item has mismatching number of type argments ${fullType} (expected ${reifiedTypeArgs.length}, got ${typeArgs.length}))`\n    );\n  }\n  for (let i = 0; i < typeArgs.length; i++) {\n    if (compressSuiType(typeArgs[i]) !== compressSuiType(extractType(reifiedTypeArgs[i]))) {\n      throw new Error(\n        `provided item has mismatching type argments ${fullType} (expected ${extractType(reifiedTypeArgs[i])}, got ${\n          typeArgs[i]\n        }))`\n      );\n    }\n  }\n}\n\nexport function assertFieldsWithTypesArgsMatch(\n  item: FieldsWithTypes,\n  reifiedTypeArgs: Array<Reified<TypeArgument, any> | PhantomReified<string>>\n) {\n  const { typeArgs: itemTypeArgs } = parseTypeName(item.type);\n  assertReifiedTypeArgsMatch(item.type, itemTypeArgs, reifiedTypeArgs);\n}\n\nexport function fieldToJSON<T extends TypeArgument>(type: string, field: ToField<T>): ToJSON<T> {\n  const { typeName, typeArgs } = parseTypeName(type);\n  switch (typeName) {\n    case \"bool\":\n      return field as any;\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n      return field as any;\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return field.toString() as any;\n    case \"address\":\n    case \"signer\":\n      return field as any;\n    case \"vector\":\n      return (field as any[]).map((item: any) => fieldToJSON(typeArgs[0], item)) as any;\n    // handle special types\n    case \"0x1::string::String\":\n    case \"0x1::ascii::String\":\n    case \"0x2::url::Url\":\n    case \"0x2::object::ID\":\n    case \"0x2::object::UID\":\n      return field as any;\n    case \"0x1::option::Option\": {\n      if (field === null) {\n        return null as any;\n      }\n      return fieldToJSON(typeArgs[0], field);\n    }\n    default:\n      return (field as any).toJSONField();\n  }\n}\n\nexport function decodeFromJSONField(typeArg: Reified<TypeArgument, any>, field: any) {\n  switch (typeArg) {\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n      return field;\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return BigInt(field);\n    case \"address\":\n      return field;\n  }\n  if (typeArg.kind === \"VectorClassReified\") {\n    return typeArg.fromJSONField(field).elements;\n  }\n  switch (typeArg.typeName) {\n    case \"0x1::string::String\":\n    case \"0x1::ascii::String\":\n    case \"0x2::url::Url\":\n    case \"0x2::object::ID\":\n    case \"0x2::object::UID\":\n      return field;\n    case \"0x1::option::Option\": {\n      if (field === null) {\n        return null;\n      }\n      return decodeFromJSONField(typeArg.reifiedTypeArgs[0] as any, field);\n    }\n    default:\n      return typeArg.fromJSONField(field);\n  }\n}\n"]}