import * as reified from "../../../../_framework/reified";
import { PhantomReified, PhantomToTypeStr, PhantomTypeArgument, Reified, StructClass, ToField, ToPhantomTypeArgument, ToTypeArgument, ToTypeStr, TypeArgument } from "../../../../_framework/reified";
import { FieldsWithTypes } from "../../../../_framework/util";
import { Vector } from "../../../../_framework/vector";
import { Coin } from "../../../../sui/coin/structs";
import { Option } from "../../0x1/option/structs";
import { BcsType } from "@mysten/sui/bcs";
import { SuiClient, SuiObjectData, SuiParsedData } from "@mysten/sui/client";
export declare function isDepositForBurnTicket(type: string): boolean;
export interface DepositForBurnTicketFields<T extends PhantomTypeArgument, Auth extends TypeArgument> {
    auth: ToField<Auth>;
    coins: ToField<Coin<T>>;
    destinationDomain: ToField<"u32">;
    mintRecipient: ToField<"address">;
}
export type DepositForBurnTicketReified<T extends PhantomTypeArgument, Auth extends TypeArgument> = Reified<DepositForBurnTicket<T, Auth>, DepositForBurnTicketFields<T, Auth>>;
export declare class DepositForBurnTicket<T extends PhantomTypeArgument, Auth extends TypeArgument> implements StructClass {
    __StructClass: true;
    static get $typeName(): string;
    static readonly $numTypeParams = 2;
    static readonly $isPhantom: readonly [true, false];
    readonly $typeName: string;
    readonly $fullTypeName: string;
    readonly $typeArgs: [PhantomToTypeStr<T>, ToTypeStr<Auth>];
    readonly $isPhantom: readonly [true, false];
    readonly auth: ToField<Auth>;
    readonly coins: ToField<Coin<T>>;
    readonly destinationDomain: ToField<"u32">;
    readonly mintRecipient: ToField<"address">;
    private constructor();
    static reified<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(T: T, Auth: Auth): DepositForBurnTicketReified<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>;
    static get r(): typeof DepositForBurnTicket.reified;
    static phantom<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(T: T, Auth: Auth): PhantomReified<ToTypeStr<DepositForBurnTicket<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>>>;
    static get p(): typeof DepositForBurnTicket.phantom;
    static get bcs(): <Auth extends BcsType<any>>(Auth: Auth) => BcsType<{
        auth: Auth extends BcsType<infer U, any> ? U : never;
        coins: {
            id: {
                id: {
                    bytes: string;
                };
            };
            balance: {
                value: string;
            };
        };
        destination_domain: number;
        mint_recipient: string;
    }, {
        auth: Auth extends BcsType<any, infer U_1> ? U_1 : never;
        coins: {
            id: {
                id: {
                    bytes: string;
                };
            };
            balance: {
                value: string | number | bigint;
            };
        };
        destination_domain: number;
        mint_recipient: string;
    }>;
    static fromFields<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(typeArgs: [T, Auth], fields: Record<string, any>): DepositForBurnTicket<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>;
    static fromFieldsWithTypes<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(typeArgs: [T, Auth], item: FieldsWithTypes): DepositForBurnTicket<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>;
    static fromBcs<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(typeArgs: [T, Auth], data: Uint8Array): DepositForBurnTicket<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>;
    toJSONField(): {
        auth: reified.ToJSON<Auth>;
        coins: {
            id: import("../../../../sui/object/structs").UID;
            balance: {
                value: string;
            };
        };
        destinationDomain: number;
        mintRecipient: string;
    };
    toJSON(): {
        auth: reified.ToJSON<Auth>;
        coins: {
            id: import("../../../../sui/object/structs").UID;
            balance: {
                value: string;
            };
        };
        destinationDomain: number;
        mintRecipient: string;
        $typeName: string;
        $typeArgs: [reified.PhantomToTypeStr<T>, reified.ToTypeStr<Auth>];
    };
    static fromJSONField<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(typeArgs: [T, Auth], field: any): DepositForBurnTicket<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>;
    static fromJSON<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(typeArgs: [T, Auth], json: Record<string, any>): DepositForBurnTicket<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>;
    static fromSuiParsedData<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(typeArgs: [T, Auth], content: SuiParsedData): DepositForBurnTicket<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>;
    static fromSuiObjectData<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(typeArgs: [T, Auth], data: SuiObjectData): DepositForBurnTicket<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>;
    static fetch<T extends PhantomReified<PhantomTypeArgument>, Auth extends Reified<TypeArgument, any>>(client: SuiClient, typeArgs: [T, Auth], id: string): Promise<DepositForBurnTicket<ToPhantomTypeArgument<T>, ToTypeArgument<Auth>>>;
}
export declare function isReplaceDepositForBurnTicket(type: string): boolean;
export interface ReplaceDepositForBurnTicketFields<Auth extends TypeArgument> {
    auth: ToField<Auth>;
    originalRawMessage: ToField<Vector<"u8">>;
    originalAttestation: ToField<Vector<"u8">>;
    newDestinationCaller: ToField<Option<"address">>;
    newMintRecipient: ToField<Option<"address">>;
}
export type ReplaceDepositForBurnTicketReified<Auth extends TypeArgument> = Reified<ReplaceDepositForBurnTicket<Auth>, ReplaceDepositForBurnTicketFields<Auth>>;
export declare class ReplaceDepositForBurnTicket<Auth extends TypeArgument> implements StructClass {
    __StructClass: true;
    static get $typeName(): string;
    static readonly $numTypeParams = 1;
    static readonly $isPhantom: readonly [false];
    readonly $typeName: string;
    readonly $fullTypeName: string;
    readonly $typeArgs: [ToTypeStr<Auth>];
    readonly $isPhantom: readonly [false];
    readonly auth: ToField<Auth>;
    readonly originalRawMessage: ToField<Vector<"u8">>;
    readonly originalAttestation: ToField<Vector<"u8">>;
    readonly newDestinationCaller: ToField<Option<"address">>;
    readonly newMintRecipient: ToField<Option<"address">>;
    private constructor();
    static reified<Auth extends Reified<TypeArgument, any>>(Auth: Auth): ReplaceDepositForBurnTicketReified<ToTypeArgument<Auth>>;
    static get r(): typeof ReplaceDepositForBurnTicket.reified;
    static phantom<Auth extends Reified<TypeArgument, any>>(Auth: Auth): PhantomReified<ToTypeStr<ReplaceDepositForBurnTicket<ToTypeArgument<Auth>>>>;
    static get p(): typeof ReplaceDepositForBurnTicket.phantom;
    static get bcs(): <Auth extends BcsType<any>>(Auth: Auth) => BcsType<{
        auth: Auth extends BcsType<infer U, any> ? U : never;
        original_raw_message: number[];
        original_attestation: number[];
        new_destination_caller: {
            vec: any[];
        };
        new_mint_recipient: {
            vec: any[];
        };
    }, {
        auth: Auth extends BcsType<any, infer U_1> ? U_1 : never;
        original_raw_message: Iterable<number> & {
            length: number;
        };
        original_attestation: Iterable<number> & {
            length: number;
        };
        new_destination_caller: {
            vec: Iterable<any> & {
                length: number;
            };
        };
        new_mint_recipient: {
            vec: Iterable<any> & {
                length: number;
            };
        };
    }>;
    static fromFields<Auth extends Reified<TypeArgument, any>>(typeArg: Auth, fields: Record<string, any>): ReplaceDepositForBurnTicket<ToTypeArgument<Auth>>;
    static fromFieldsWithTypes<Auth extends Reified<TypeArgument, any>>(typeArg: Auth, item: FieldsWithTypes): ReplaceDepositForBurnTicket<ToTypeArgument<Auth>>;
    static fromBcs<Auth extends Reified<TypeArgument, any>>(typeArg: Auth, data: Uint8Array): ReplaceDepositForBurnTicket<ToTypeArgument<Auth>>;
    toJSONField(): {
        auth: reified.ToJSON<Auth>;
        originalRawMessage: number[];
        originalAttestation: number[];
        newDestinationCaller: {
            vec: string[];
        };
        newMintRecipient: {
            vec: string[];
        };
    };
    toJSON(): {
        auth: reified.ToJSON<Auth>;
        originalRawMessage: number[];
        originalAttestation: number[];
        newDestinationCaller: {
            vec: string[];
        };
        newMintRecipient: {
            vec: string[];
        };
        $typeName: string;
        $typeArgs: [reified.ToTypeStr<Auth>];
    };
    static fromJSONField<Auth extends Reified<TypeArgument, any>>(typeArg: Auth, field: any): ReplaceDepositForBurnTicket<ToTypeArgument<Auth>>;
    static fromJSON<Auth extends Reified<TypeArgument, any>>(typeArg: Auth, json: Record<string, any>): ReplaceDepositForBurnTicket<ToTypeArgument<Auth>>;
    static fromSuiParsedData<Auth extends Reified<TypeArgument, any>>(typeArg: Auth, content: SuiParsedData): ReplaceDepositForBurnTicket<ToTypeArgument<Auth>>;
    static fromSuiObjectData<Auth extends Reified<TypeArgument, any>>(typeArg: Auth, data: SuiObjectData): ReplaceDepositForBurnTicket<ToTypeArgument<Auth>>;
    static fetch<Auth extends Reified<TypeArgument, any>>(client: SuiClient, typeArg: Auth, id: string): Promise<ReplaceDepositForBurnTicket<ToTypeArgument<Auth>>>;
}
