"use strict";
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LidoSDKWithdrawRequestsInfo = void 0;
const index_js_1 = require("../common/decorators/index.js");
const index_js_2 = require("../common/utils/index.js");
const bus_module_js_1 = require("./bus-module.js");
let LidoSDKWithdrawRequestsInfo = (() => {
    var _a;
    let _classSuper = bus_module_js_1.BusModule;
    let _instanceExtraInitializers = [];
    let _getWithdrawalRequestsInfo_decorators;
    let _getWithdrawalRequestsStatus_decorators;
    let _getClaimableRequestsInfo_decorators;
    let _getClaimableRequestsETHByIds_decorators;
    let _getClaimableRequestsETHByAccount_decorators;
    let _getPendingRequestsInfo_decorators;
    return _a = class LidoSDKWithdrawRequestsInfo extends _classSuper {
            async getWithdrawalRequestsInfo(props) {
                const claimableInfo = await this.getClaimableRequestsInfo(props);
                const claimableETH = await this.getClaimableRequestsETHByAccount(props);
                const pendingInfo = await this.getPendingRequestsInfo(props);
                return {
                    claimableInfo,
                    pendingInfo,
                    claimableETH,
                };
            }
            async getWithdrawalRequestsStatus(props) {
                const account = await this.bus.core.useAccount(props.account);
                const requestsIds = await this.bus.views.getWithdrawalRequestsIds({
                    account,
                });
                return this.bus.views.getWithdrawalStatus({ requestsIds });
            }
            async getClaimableRequestsInfo(props) {
                const requests = await this.getWithdrawalRequestsStatus(props);
                return requests.reduce((acc, request) => {
                    if (request.isFinalized && !request.isClaimed) {
                        acc.claimableRequests.push(request);
                        acc.claimableAmountStETH += request.amountOfStETH;
                    }
                    return acc;
                }, {
                    claimableRequests: [],
                    claimableAmountStETH: 0n,
                });
            }
            async getClaimableRequestsETHByIds(props) {
                const sortedIds = props.claimableRequestsIds
                    .sort((aReq, bReq) => {
                    if ((0, index_js_2.isBigint)(aReq) && (0, index_js_2.isBigint)(bReq)) {
                        return aReq > bReq ? 1 : -1;
                    }
                    if (!(0, index_js_2.isBigint)(aReq) && !(0, index_js_2.isBigint)(bReq)) {
                        return aReq.id > bReq.id ? 1 : -1;
                    }
                    throw this.bus.core.error({
                        code: index_js_2.ERROR_CODE.INVALID_ARGUMENT,
                        message: 'Mixing bigint types and object types',
                    });
                })
                    .map((req) => ((0, index_js_2.isBigint)(req) ? req : req.id));
                const hints = await this.bus.views.findCheckpointHints({
                    sortedIds,
                    lastIndex: await this.bus.views.getLastCheckpointIndex(),
                });
                const ethByRequests = await this.bus.views.getClaimableEther({
                    sortedIds,
                    hints,
                });
                const ethSum = ethByRequests.reduce((acc, eth) => acc + eth, BigInt(0));
                return { ethByRequests, ethSum, hints };
            }
            async getClaimableRequestsETHByAccount(props) {
                const requests = await this.getWithdrawalRequestsStatus(props);
                const claimableRequests = requests.filter((req) => req.isFinalized);
                const sortedRequests = claimableRequests.sort((aReq, bReq) => aReq.id > bReq.id ? 1 : -1);
                const sortedIds = sortedRequests.map((req) => req.id);
                const hints = await this.bus.views.findCheckpointHints({
                    sortedIds,
                    lastIndex: await this.bus.views.getLastCheckpointIndex(),
                });
                const ethByRequests = await this.bus.views.getClaimableEther({
                    sortedIds,
                    hints,
                });
                const ethSum = ethByRequests.reduce((acc, eth) => acc + eth, BigInt(0));
                return {
                    ethByRequests,
                    ethSum,
                    hints,
                    requests: sortedRequests,
                    sortedIds,
                };
            }
            async getPendingRequestsInfo(props) {
                const requests = await this.getWithdrawalRequestsStatus(props);
                return requests.reduce((acc, request) => {
                    if (!request.isFinalized && !request.isClaimed) {
                        acc.pendingRequests.push(request);
                        acc.pendingAmountStETH += request.amountOfStETH;
                    }
                    return acc;
                }, { pendingRequests: [], pendingAmountStETH: BigInt(0) });
            }
            constructor() {
                super(...arguments);
                __runInitializers(this, _instanceExtraInitializers);
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _getWithdrawalRequestsInfo_decorators = [(0, index_js_1.Logger)('Utils:'), (0, index_js_1.ErrorHandler)()];
            _getWithdrawalRequestsStatus_decorators = [(0, index_js_1.Logger)('Utils:'), (0, index_js_1.ErrorHandler)()];
            _getClaimableRequestsInfo_decorators = [(0, index_js_1.Logger)('Utils:'), (0, index_js_1.ErrorHandler)()];
            _getClaimableRequestsETHByIds_decorators = [(0, index_js_1.Logger)('Utils:'), (0, index_js_1.ErrorHandler)()];
            _getClaimableRequestsETHByAccount_decorators = [(0, index_js_1.Logger)('Utils:'), (0, index_js_1.ErrorHandler)()];
            _getPendingRequestsInfo_decorators = [(0, index_js_1.Logger)('Utils:'), (0, index_js_1.ErrorHandler)()];
            __esDecorate(_a, null, _getWithdrawalRequestsInfo_decorators, { kind: "method", name: "getWithdrawalRequestsInfo", static: false, private: false, access: { has: obj => "getWithdrawalRequestsInfo" in obj, get: obj => obj.getWithdrawalRequestsInfo }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getWithdrawalRequestsStatus_decorators, { kind: "method", name: "getWithdrawalRequestsStatus", static: false, private: false, access: { has: obj => "getWithdrawalRequestsStatus" in obj, get: obj => obj.getWithdrawalRequestsStatus }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getClaimableRequestsInfo_decorators, { kind: "method", name: "getClaimableRequestsInfo", static: false, private: false, access: { has: obj => "getClaimableRequestsInfo" in obj, get: obj => obj.getClaimableRequestsInfo }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getClaimableRequestsETHByIds_decorators, { kind: "method", name: "getClaimableRequestsETHByIds", static: false, private: false, access: { has: obj => "getClaimableRequestsETHByIds" in obj, get: obj => obj.getClaimableRequestsETHByIds }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getClaimableRequestsETHByAccount_decorators, { kind: "method", name: "getClaimableRequestsETHByAccount", static: false, private: false, access: { has: obj => "getClaimableRequestsETHByAccount" in obj, get: obj => obj.getClaimableRequestsETHByAccount }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getPendingRequestsInfo_decorators, { kind: "method", name: "getPendingRequestsInfo", static: false, private: false, access: { has: obj => "getPendingRequestsInfo" in obj, get: obj => obj.getPendingRequestsInfo }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.LidoSDKWithdrawRequestsInfo = LidoSDKWithdrawRequestsInfo;
//# sourceMappingURL=withdraw-requests-info.js.map