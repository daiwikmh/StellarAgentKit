var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { getContract, encodeFunctionData, decodeEventLog, getAbiItem, toEventHash, isAddressEqual, } from 'viem';
import { GAS_TRANSACTION_RATIO_PRECISION, LIDO_CONTRACT_NAMES, NOOP, SUBMIT_EXTRA_GAS_TRANSACTION_RATIO, } from '../common/constants.js';
import { parseValue } from '../common/utils/parse-value.js';
import { Logger, Cache, ErrorHandler } from '../common/decorators/index.js';
import { abi } from './abi/wsteth.js';
import { stethPartialAbi, PartialTransferEventAbi, } from './abi/steth-partial.js';
import { ERROR_CODE, invariant } from '../common/utils/sdk-error.js';
import { LidoSDKModule } from '../common/class-primitives/sdk-module.js';
let LidoSDKWrap = (() => {
    var _a;
    let _classSuper = LidoSDKModule;
    let _instanceExtraInitializers = [];
    let _contractAddressWstETH_decorators;
    let _getContractWstETH_decorators;
    let _getPartialContractSteth_decorators;
    let _wrapEth_decorators;
    let _wrapEthPopulateTx_decorators;
    let _wrapEthEstimateGas_decorators;
    let _wrapSteth_decorators;
    let _wrapStethEstimateGas_decorators;
    let _wrapStethPopulateTx_decorators;
    let _wrapStethSimulateTx_decorators;
    let _approveStethForWrap_decorators;
    let _getStethForWrapAllowance_decorators;
    let _approveStethForWrapPopulateTx_decorators;
    let _approveStethForWrapEstimateGas_decorators;
    let _approveStethForWrapSimulateTx_decorators;
    let _unwrap_decorators;
    let _unwrapPopulateTx_decorators;
    let _unwrapEstimateGas_decorators;
    let _unwrapSimulateTx_decorators;
    let _convertStethToWsteth_decorators;
    let _convertWstethToSteth_decorators;
    let _validateStakeLimit_decorators;
    let _parseProps_decorators;
    let _wrapParseEvents_decorators;
    let _unwrapParseEvents_decorators;
    return _a = class LidoSDKWrap extends _classSuper {
            // Contracts
            async contractAddressWstETH() {
                return await this.core.getContractAddress(LIDO_CONTRACT_NAMES.wsteth);
            }
            async getContractWstETH() {
                const address = await this.contractAddressWstETH();
                return getContract({
                    address,
                    abi: abi,
                    client: {
                        public: this.core.rpcProvider,
                        wallet: this.core.web3Provider,
                    },
                });
            }
            async getPartialContractSteth() {
                const address = await this.core.getContractAddress(LIDO_CONTRACT_NAMES.lido);
                return getContract({
                    address,
                    abi: stethPartialAbi,
                    client: {
                        public: this.core.rpcProvider,
                        wallet: this.core.web3Provider,
                    },
                });
            }
            // Calls
            async wrapEth(props) {
                const { account, callback, value, ...rest } = await this.parseProps(props);
                const web3Provider = this.core.useWeb3Provider();
                const contract = await this.getContractWstETH();
                await this.validateStakeLimit(value);
                return this.core.performTransaction({
                    ...rest,
                    account,
                    callback,
                    getGasLimit: (options) => this.core.rpcProvider.estimateGas({
                        to: contract.address,
                        value,
                        ...options,
                    }),
                    sendTransaction: (options) => web3Provider.sendTransaction({
                        value,
                        to: contract.address,
                        ...options,
                    }),
                    decodeResult: (receipt) => this.wrapParseEvents(receipt, account.address),
                });
            }
            async wrapEthPopulateTx(props) {
                const { value, account } = await this.parseProps(props);
                const address = await this.contractAddressWstETH();
                return {
                    to: address,
                    from: account.address,
                    value,
                };
            }
            async wrapEthEstimateGas(props, options) {
                const { value, account } = await this.parseProps(props);
                const address = await this.contractAddressWstETH();
                const originalGasLimit = await this.core.rpcProvider.estimateGas({
                    account,
                    to: address,
                    value,
                    ...options,
                });
                return ((originalGasLimit *
                    BigInt(GAS_TRANSACTION_RATIO_PRECISION * SUBMIT_EXTRA_GAS_TRANSACTION_RATIO)) /
                    BigInt(GAS_TRANSACTION_RATIO_PRECISION));
            }
            /// Wrap stETH
            async wrapSteth(props) {
                this.core.useWeb3Provider();
                const { account, callback, value, ...rest } = await this.parseProps(props);
                const contract = await this.getContractWstETH();
                return this.core.performTransaction({
                    ...rest,
                    account,
                    callback,
                    getGasLimit: (options) => contract.estimateGas.wrap([value], options),
                    sendTransaction: (options) => contract.write.wrap([value], options),
                    decodeResult: (receipt) => this.wrapParseEvents(receipt, account.address),
                });
            }
            async wrapStethEstimateGas(props, options) {
                const { value, account } = await this.parseProps(props);
                const contract = await this.getContractWstETH();
                return await contract.estimateGas.wrap([value], { account, ...options });
            }
            async wrapStethPopulateTx(props) {
                const { value, account } = await this.parseProps(props);
                const address = await this.contractAddressWstETH();
                return {
                    to: address,
                    from: account.address,
                    data: encodeFunctionData({
                        abi,
                        functionName: 'wrap',
                        args: [value],
                    }),
                };
            }
            async wrapStethSimulateTx(props) {
                const { value, account } = await this.parseProps(props);
                const contract = await this.getContractWstETH();
                const { request } = await contract.simulate.wrap([value], {
                    account,
                });
                return request;
            }
            /// Approve
            async approveStethForWrap(props) {
                this.core.useWeb3Provider();
                const { account, callback, value, ...rest } = await this.parseProps(props);
                const stethContract = await this.getPartialContractSteth();
                const wstethContractAddress = await this.contractAddressWstETH();
                return this.core.performTransaction({
                    ...rest,
                    account,
                    callback,
                    getGasLimit: (options) => stethContract.estimateGas.approve([wstethContractAddress, value], options),
                    sendTransaction: (options) => stethContract.write.approve([wstethContractAddress, value], options),
                });
            }
            async getStethForWrapAllowance(account) {
                const parsedAccount = await this.core.useAccount(account);
                const stethContract = await this.getPartialContractSteth();
                const wstethAddress = await this.contractAddressWstETH();
                return stethContract.read.allowance([parsedAccount.address, wstethAddress]);
            }
            async approveStethForWrapPopulateTx(props) {
                const { value, account } = await this.parseProps(props);
                const stethContract = await this.getPartialContractSteth();
                const wstethContractAddress = await this.contractAddressWstETH();
                return {
                    to: stethContract.address,
                    from: account.address,
                    data: encodeFunctionData({
                        abi: stethPartialAbi,
                        functionName: 'approve',
                        args: [wstethContractAddress, value],
                    }),
                };
            }
            async approveStethForWrapEstimateGas(props, options) {
                const { value, account } = await this.parseProps(props);
                const stethContract = await this.getPartialContractSteth();
                const wstethContractAddress = await this.contractAddressWstETH();
                return await stethContract.estimateGas.approve([wstethContractAddress, value], { account, ...options });
            }
            async approveStethForWrapSimulateTx(props) {
                const { value, account } = await this.parseProps(props);
                const stethContract = await this.getPartialContractSteth();
                const wstethContractAddress = await this.contractAddressWstETH();
                const { request } = await stethContract.simulate.approve([wstethContractAddress, value], {
                    account,
                });
                return request;
            }
            /// Unwrap
            async unwrap(props) {
                this.core.useWeb3Provider();
                const { account, callback, value, ...rest } = await this.parseProps(props);
                const contract = await this.getContractWstETH();
                return this.core.performTransaction({
                    ...rest,
                    account,
                    callback,
                    getGasLimit: (options) => contract.estimateGas.unwrap([value], options),
                    sendTransaction: (options) => contract.write.unwrap([value], options),
                    decodeResult: (receipt) => this.unwrapParseEvents(receipt, account.address),
                });
            }
            async unwrapPopulateTx(props) {
                const { value, account } = await this.parseProps(props);
                const to = await this.contractAddressWstETH();
                return {
                    to,
                    from: account.address,
                    data: encodeFunctionData({
                        abi: abi,
                        functionName: 'unwrap',
                        args: [value],
                    }),
                };
            }
            async unwrapEstimateGas(props, options) {
                const { value, account } = await this.parseProps(props);
                const contract = await this.getContractWstETH();
                return contract.estimateGas.unwrap([value], { account, ...options });
            }
            async unwrapSimulateTx(props) {
                const { value, account } = await this.parseProps(props);
                const contract = await this.getContractWstETH();
                const { request } = await contract.simulate.unwrap([value], {
                    account,
                });
                return request;
            }
            /// Views
            async convertStethToWsteth(steth_value) {
                const value = parseValue(steth_value);
                const contract = await this.getContractWstETH();
                return contract.read.getWstETHByStETH([value]);
            }
            async convertWstethToSteth(wsteth_value) {
                const value = parseValue(wsteth_value);
                const contract = await this.getContractWstETH();
                return contract.read.getStETHByWstETH([value]);
            }
            /// Utils
            async validateStakeLimit(value) {
                const stakeContract = await this.getPartialContractSteth();
                const currentStakeLimit = (await stakeContract.read.getStakeLimitFullInfo())[3];
                if (value > currentStakeLimit) {
                    throw this.core.error({
                        code: ERROR_CODE.TRANSACTION_ERROR,
                        message: `Stake value is greater than daily protocol staking limit (${currentStakeLimit})`,
                    });
                }
            }
            async parseProps(props) {
                return {
                    ...props,
                    account: await this.core.useAccount(props.account),
                    value: parseValue(props.value),
                    callback: props.callback ?? NOOP,
                };
            }
            async wrapParseEvents(receipt, address) {
                const wstethAddress = await this.contractAddressWstETH();
                let stethWrapped;
                let wstethReceived;
                for (const log of receipt.logs) {
                    // skips non-relevant events
                    if (log.topics[0] !== _a.TRANSFER_SIGNATURE)
                        continue;
                    const parsedLog = decodeEventLog({
                        // fits both wsteth and steth events
                        abi: PartialTransferEventAbi,
                        strict: true,
                        ...log,
                    });
                    if (isAddressEqual(parsedLog.args.to, address)) {
                        wstethReceived = parsedLog.args.value;
                    }
                    else if (isAddressEqual(parsedLog.args.to, wstethAddress)) {
                        stethWrapped = parsedLog.args.value;
                    }
                }
                invariant(stethWrapped, 'could not find Transfer event in wrap transaction', ERROR_CODE.TRANSACTION_ERROR);
                invariant(wstethReceived, 'could not find Transfer event in wrap transaction', ERROR_CODE.TRANSACTION_ERROR);
                return {
                    stethWrapped,
                    wstethReceived,
                };
            }
            async unwrapParseEvents(receipt, address) {
                let stethReceived;
                let wstethUnwrapped;
                for (const log of receipt.logs) {
                    // skips non-relevant events
                    if (log.topics[0] !== _a.TRANSFER_SIGNATURE)
                        continue;
                    const parsedLog = decodeEventLog({
                        abi: PartialTransferEventAbi,
                        strict: true,
                        ...log,
                    });
                    if (isAddressEqual(parsedLog.args.from, address)) {
                        wstethUnwrapped = parsedLog.args.value;
                    }
                    else if (isAddressEqual(parsedLog.args.to, address)) {
                        stethReceived = parsedLog.args.value;
                    }
                }
                invariant(stethReceived, 'could not find Transfer event in unwrap transaction', ERROR_CODE.TRANSACTION_ERROR);
                invariant(wstethUnwrapped, 'could not find Transfer event in unwrap transaction', ERROR_CODE.TRANSACTION_ERROR);
                return {
                    stethReceived,
                    wstethUnwrapped,
                };
            }
            constructor() {
                super(...arguments);
                __runInitializers(this, _instanceExtraInitializers);
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _contractAddressWstETH_decorators = [Logger('Contracts:'), Cache(30 * 60 * 1000, ['core.chain.id'])];
            _getContractWstETH_decorators = [Logger('Contracts:'), Cache(30 * 60 * 1000, ['core.chain.id', 'contractAddressWstETH'])];
            _getPartialContractSteth_decorators = [Logger('Contracts:'), Cache(30 * 60 * 1000, ['core.chain.id'])];
            _wrapEth_decorators = [Logger('Call:'), ErrorHandler()];
            _wrapEthPopulateTx_decorators = [Logger('Utils:')];
            _wrapEthEstimateGas_decorators = [Logger('Utils:'), ErrorHandler()];
            _wrapSteth_decorators = [Logger('Call:'), ErrorHandler()];
            _wrapStethEstimateGas_decorators = [Logger('Utils:')];
            _wrapStethPopulateTx_decorators = [Logger('Utils:')];
            _wrapStethSimulateTx_decorators = [Logger('Call:'), ErrorHandler()];
            _approveStethForWrap_decorators = [Logger('Call:'), ErrorHandler()];
            _getStethForWrapAllowance_decorators = [Logger('Utils:'), ErrorHandler()];
            _approveStethForWrapPopulateTx_decorators = [Logger('Utils:')];
            _approveStethForWrapEstimateGas_decorators = [Logger('Utils:')];
            _approveStethForWrapSimulateTx_decorators = [Logger('Call:'), ErrorHandler()];
            _unwrap_decorators = [Logger('Call:'), ErrorHandler()];
            _unwrapPopulateTx_decorators = [Logger('Utils:')];
            _unwrapEstimateGas_decorators = [Logger('Utils:')];
            _unwrapSimulateTx_decorators = [Logger('Call:'), ErrorHandler()];
            _convertStethToWsteth_decorators = [Logger('Views:'), ErrorHandler()];
            _convertWstethToSteth_decorators = [Logger('Views:'), ErrorHandler()];
            _validateStakeLimit_decorators = [Logger('Utils:')];
            _parseProps_decorators = [Logger('Utils:')];
            _wrapParseEvents_decorators = [Logger('Utils:')];
            _unwrapParseEvents_decorators = [Logger('Utils:')];
            __esDecorate(_a, null, _contractAddressWstETH_decorators, { kind: "method", name: "contractAddressWstETH", static: false, private: false, access: { has: obj => "contractAddressWstETH" in obj, get: obj => obj.contractAddressWstETH }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getContractWstETH_decorators, { kind: "method", name: "getContractWstETH", static: false, private: false, access: { has: obj => "getContractWstETH" in obj, get: obj => obj.getContractWstETH }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getPartialContractSteth_decorators, { kind: "method", name: "getPartialContractSteth", static: false, private: false, access: { has: obj => "getPartialContractSteth" in obj, get: obj => obj.getPartialContractSteth }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wrapEth_decorators, { kind: "method", name: "wrapEth", static: false, private: false, access: { has: obj => "wrapEth" in obj, get: obj => obj.wrapEth }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wrapEthPopulateTx_decorators, { kind: "method", name: "wrapEthPopulateTx", static: false, private: false, access: { has: obj => "wrapEthPopulateTx" in obj, get: obj => obj.wrapEthPopulateTx }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wrapEthEstimateGas_decorators, { kind: "method", name: "wrapEthEstimateGas", static: false, private: false, access: { has: obj => "wrapEthEstimateGas" in obj, get: obj => obj.wrapEthEstimateGas }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wrapSteth_decorators, { kind: "method", name: "wrapSteth", static: false, private: false, access: { has: obj => "wrapSteth" in obj, get: obj => obj.wrapSteth }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wrapStethEstimateGas_decorators, { kind: "method", name: "wrapStethEstimateGas", static: false, private: false, access: { has: obj => "wrapStethEstimateGas" in obj, get: obj => obj.wrapStethEstimateGas }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wrapStethPopulateTx_decorators, { kind: "method", name: "wrapStethPopulateTx", static: false, private: false, access: { has: obj => "wrapStethPopulateTx" in obj, get: obj => obj.wrapStethPopulateTx }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wrapStethSimulateTx_decorators, { kind: "method", name: "wrapStethSimulateTx", static: false, private: false, access: { has: obj => "wrapStethSimulateTx" in obj, get: obj => obj.wrapStethSimulateTx }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _approveStethForWrap_decorators, { kind: "method", name: "approveStethForWrap", static: false, private: false, access: { has: obj => "approveStethForWrap" in obj, get: obj => obj.approveStethForWrap }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getStethForWrapAllowance_decorators, { kind: "method", name: "getStethForWrapAllowance", static: false, private: false, access: { has: obj => "getStethForWrapAllowance" in obj, get: obj => obj.getStethForWrapAllowance }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _approveStethForWrapPopulateTx_decorators, { kind: "method", name: "approveStethForWrapPopulateTx", static: false, private: false, access: { has: obj => "approveStethForWrapPopulateTx" in obj, get: obj => obj.approveStethForWrapPopulateTx }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _approveStethForWrapEstimateGas_decorators, { kind: "method", name: "approveStethForWrapEstimateGas", static: false, private: false, access: { has: obj => "approveStethForWrapEstimateGas" in obj, get: obj => obj.approveStethForWrapEstimateGas }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _approveStethForWrapSimulateTx_decorators, { kind: "method", name: "approveStethForWrapSimulateTx", static: false, private: false, access: { has: obj => "approveStethForWrapSimulateTx" in obj, get: obj => obj.approveStethForWrapSimulateTx }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _unwrap_decorators, { kind: "method", name: "unwrap", static: false, private: false, access: { has: obj => "unwrap" in obj, get: obj => obj.unwrap }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _unwrapPopulateTx_decorators, { kind: "method", name: "unwrapPopulateTx", static: false, private: false, access: { has: obj => "unwrapPopulateTx" in obj, get: obj => obj.unwrapPopulateTx }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _unwrapEstimateGas_decorators, { kind: "method", name: "unwrapEstimateGas", static: false, private: false, access: { has: obj => "unwrapEstimateGas" in obj, get: obj => obj.unwrapEstimateGas }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _unwrapSimulateTx_decorators, { kind: "method", name: "unwrapSimulateTx", static: false, private: false, access: { has: obj => "unwrapSimulateTx" in obj, get: obj => obj.unwrapSimulateTx }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _convertStethToWsteth_decorators, { kind: "method", name: "convertStethToWsteth", static: false, private: false, access: { has: obj => "convertStethToWsteth" in obj, get: obj => obj.convertStethToWsteth }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _convertWstethToSteth_decorators, { kind: "method", name: "convertWstethToSteth", static: false, private: false, access: { has: obj => "convertWstethToSteth" in obj, get: obj => obj.convertWstethToSteth }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _validateStakeLimit_decorators, { kind: "method", name: "validateStakeLimit", static: false, private: false, access: { has: obj => "validateStakeLimit" in obj, get: obj => obj.validateStakeLimit }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _parseProps_decorators, { kind: "method", name: "parseProps", static: false, private: false, access: { has: obj => "parseProps" in obj, get: obj => obj.parseProps }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wrapParseEvents_decorators, { kind: "method", name: "wrapParseEvents", static: false, private: false, access: { has: obj => "wrapParseEvents" in obj, get: obj => obj.wrapParseEvents }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _unwrapParseEvents_decorators, { kind: "method", name: "unwrapParseEvents", static: false, private: false, access: { has: obj => "unwrapParseEvents" in obj, get: obj => obj.unwrapParseEvents }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        Object.defineProperty(_a, "TRANSFER_SIGNATURE", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toEventHash(getAbiItem({ abi: PartialTransferEventAbi, name: 'Transfer' }))
        }),
        _a;
})();
export { LidoSDKWrap };
//# sourceMappingURL=wrap.js.map