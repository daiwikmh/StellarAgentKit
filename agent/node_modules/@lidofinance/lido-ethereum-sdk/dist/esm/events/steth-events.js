var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { getContract } from 'viem';
import { Logger, Cache, ErrorHandler } from '../common/decorators/index.js';
import { LIDO_CONTRACT_NAMES } from '../common/constants.js';
import { StethEventsAbi } from './abi/stethEvents.js';
import { ERROR_CODE, invariant, invariantArgument, } from '../common/utils/sdk-error.js';
import { requestWithBlockStep } from '../rewards/utils.js';
import { LidoSDKModule } from '../common/class-primitives/sdk-module.js';
const BLOCKS_BY_DAY = 7600n;
const REBASE_EVENT_ABI_INDEX = 8;
const DAYS_LIMIT = 7;
let LidoSDKStethEvents = (() => {
    var _a;
    let _classSuper = LidoSDKModule;
    let _instanceExtraInitializers = [];
    let _contractAddressStETH_decorators;
    let _getContractStETH_decorators;
    let _getLastRebaseEvent_decorators;
    let _getFirstRebaseEvent_decorators;
    let _getLastRebaseEvents_decorators;
    let _getRebaseEvents_decorators;
    let _getLastBlock_decorators;
    return _a = class LidoSDKStethEvents extends _classSuper {
            // Contracts
            async contractAddressStETH() {
                return await this.core.getContractAddress(LIDO_CONTRACT_NAMES.lido);
            }
            async getContractStETH() {
                const address = await this.contractAddressStETH();
                return getContract({
                    address,
                    abi: StethEventsAbi,
                    client: this.core.rpcProvider,
                });
            }
            // Events
            async getLastRebaseEvent() {
                const events = await this.getLastRebaseEvents({ count: 1 });
                return events[0];
            }
            async getFirstRebaseEvent(props) {
                const { days } = props;
                const fromBlockNumber = props.fromBlockNumber ?? (await this.getLastBlock()).number;
                const contract = await this.getContractStETH();
                for (let dayOffset = 0; dayOffset < DAYS_LIMIT; dayOffset++) {
                    const from = fromBlockNumber - BigInt(days - dayOffset) * BLOCKS_BY_DAY;
                    invariantArgument(from >= 0n, 'Days range precedes first block');
                    const to = from + BLOCKS_BY_DAY;
                    const logs = await this.core.rpcProvider.getLogs({
                        address: contract.address,
                        event: StethEventsAbi[REBASE_EVENT_ABI_INDEX],
                        fromBlock: from,
                        toBlock: to,
                        strict: true,
                    });
                    if (logs.length > 0)
                        return logs[0];
                }
                return undefined;
            }
            async getLastRebaseEvents({ count, stepBlock = _a.DEFAULT_STEP_BLOCK, }) {
                invariantArgument(count, 'count must be a positive integer');
                const events = await this.getRebaseEvents({
                    maxCount: count,
                    back: { blocks: BLOCKS_BY_DAY * BigInt(count + 1) },
                    stepBlock,
                });
                // most often scenario
                if (events.length === count)
                    return events;
                const lastEvent = events.length > 0 ? events[events.length] : undefined;
                invariant(lastEvent, 'Could not find any rebase events', ERROR_CODE.READ_ERROR);
                const fromBlock = lastEvent.blockNumber - BigInt(DAYS_LIMIT) * BLOCKS_BY_DAY;
                const rest = await this.getRebaseEvents({
                    maxCount: count - events.length,
                    to: { block: lastEvent.blockNumber },
                    from: { block: fromBlock > 0n ? fromBlock : 0n },
                    stepBlock,
                });
                return events.concat(rest);
            }
            async getRebaseEvents(props) {
                const [{ fromBlock, stepBlock, toBlock, maxCount }, contract] = await Promise.all([this.parseProps(props), this.getContractStETH()]);
                const logs = await requestWithBlockStep(stepBlock, fromBlock, toBlock, (fromBlock, toBlock) => this.core.rpcProvider.getLogs({
                    address: contract.address,
                    event: StethEventsAbi[8],
                    fromBlock,
                    toBlock,
                    strict: true,
                }));
                return maxCount ? logs.slice(Math.max(logs.length - maxCount, 0)) : logs;
            }
            // Utils
            async getLastBlock() {
                const lastBlock = await this.core.rpcProvider.getBlock({
                    blockTag: 'latest',
                });
                return lastBlock;
            }
            async parseProps(props) {
                const toBlock = await this.core.toBlockNumber(props.to ?? { block: 'latest' });
                const fromBlock = props.from
                    ? await this.core.toBlockNumber(props.from)
                    : await this.core.toBackBlock(props.back, toBlock);
                invariantArgument(toBlock >= fromBlock, 'toBlock is lower than fromBlock');
                const { stepBlock = _a.DEFAULT_STEP_BLOCK, maxCount } = props;
                invariantArgument(stepBlock > 0, 'stepBlock must be a positive integer');
                if (maxCount !== undefined) {
                    invariantArgument(maxCount > 0, 'maxCount must be a positive integer');
                }
                return {
                    ...props,
                    fromBlock,
                    toBlock,
                    stepBlock,
                };
            }
            constructor() {
                super(...arguments);
                __runInitializers(this, _instanceExtraInitializers);
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _contractAddressStETH_decorators = [Logger('Contracts:'), Cache(30 * 60 * 1000, ['core.chain.id'])];
            _getContractStETH_decorators = [Logger('Contracts:'), Cache(30 * 60 * 1000, ['core.chain.id', 'contractAddressStETH'])];
            _getLastRebaseEvent_decorators = [Logger('Events:'), ErrorHandler()];
            _getFirstRebaseEvent_decorators = [Logger('Events:'), ErrorHandler()];
            _getLastRebaseEvents_decorators = [Logger('Events:'), ErrorHandler()];
            _getRebaseEvents_decorators = [Logger('Events:'), ErrorHandler()];
            _getLastBlock_decorators = [Logger('Utils:'), ErrorHandler()];
            __esDecorate(_a, null, _contractAddressStETH_decorators, { kind: "method", name: "contractAddressStETH", static: false, private: false, access: { has: obj => "contractAddressStETH" in obj, get: obj => obj.contractAddressStETH }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getContractStETH_decorators, { kind: "method", name: "getContractStETH", static: false, private: false, access: { has: obj => "getContractStETH" in obj, get: obj => obj.getContractStETH }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getLastRebaseEvent_decorators, { kind: "method", name: "getLastRebaseEvent", static: false, private: false, access: { has: obj => "getLastRebaseEvent" in obj, get: obj => obj.getLastRebaseEvent }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getFirstRebaseEvent_decorators, { kind: "method", name: "getFirstRebaseEvent", static: false, private: false, access: { has: obj => "getFirstRebaseEvent" in obj, get: obj => obj.getFirstRebaseEvent }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getLastRebaseEvents_decorators, { kind: "method", name: "getLastRebaseEvents", static: false, private: false, access: { has: obj => "getLastRebaseEvents" in obj, get: obj => obj.getLastRebaseEvents }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getRebaseEvents_decorators, { kind: "method", name: "getRebaseEvents", static: false, private: false, access: { has: obj => "getRebaseEvents" in obj, get: obj => obj.getRebaseEvents }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getLastBlock_decorators, { kind: "method", name: "getLastBlock", static: false, private: false, access: { has: obj => "getLastBlock" in obj, get: obj => obj.getLastBlock }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        Object.defineProperty(_a, "DEFAULT_STEP_BLOCK", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 50000
        }),
        _a;
})();
export { LidoSDKStethEvents };
//# sourceMappingURL=steth-events.js.map