var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
import { createPublicClient, createWalletClient, fallback, http, custom, getContract, maxUint256, } from 'viem';
import { ERROR_CODE, invariant, invariantArgument, withSDKError, } from '../common/utils/sdk-error.js';
import { splitSignature } from '@ethersproject/bytes';
import { SDKError } from '../common/utils/index.js';
import { Logger, Initialize, Cache } from '../common/decorators/index.js';
import { SUPPORTED_CHAINS, LIDO_LOCATOR_BY_CHAIN, CONTRACTS_BY_TOKENS, LIDO_TOKENS, PERMIT_MESSAGE_TYPES, VIEM_CHAINS, SUBRGRAPH_ID_BY_CHAIN, APPROX_SECONDS_PER_BLOCK, NOOP, LIDO_L2_CONTRACT_ADDRESSES, } from '../common/constants.js';
import { LidoLocatorAbi } from './abi/lidoLocator.js';
import { wqWstethAddressAbi } from './abi/wq.js';
import { TransactionCallbackStage } from './types.js';
import { permitAbi } from './abi/permit.js';
import { LidoSDKCacheable } from '../common/class-primitives/cacheable.js';
import { readContract } from 'viem/actions';
let LidoSDKCore = (() => {
    var _a, _LidoSDKCore_web3Provider;
    let _classSuper = LidoSDKCacheable;
    let _instanceExtraInitializers = [];
    let _init_decorators;
    let _useWeb3Provider_decorators;
    let _balanceETH_decorators;
    let _contractAddressLidoLocator_decorators;
    let _getContractLidoLocator_decorators;
    let _signPermit_decorators;
    let _getPermitContractData_decorators;
    let _getFeeData_decorators;
    let _getWeb3Address_decorators;
    let _useAccount_decorators;
    let _isContract_decorators;
    let _error_decorators;
    let _getContractAddress_decorators;
    let _getL2ContractAddress_decorators;
    let _getSubgraphId_decorators;
    let _getLatestBlockToTimestamp_decorators;
    let _toBlockNumber_decorators;
    let _toBackBlock_decorators;
    return _a = class LidoSDKCore extends _classSuper {
            get web3Provider() {
                return __classPrivateFieldGet(this, _LidoSDKCore_web3Provider, "f");
            }
            constructor(props, version) {
                super();
                _LidoSDKCore_web3Provider.set(this, __runInitializers(this, _instanceExtraInitializers));
                Object.defineProperty(this, "chainId", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "rpcUrls", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "chain", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "rpcProvider", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                Object.defineProperty(this, "logMode", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: void 0
                });
                this.chainId = props.chainId;
                this.rpcUrls = props.rpcUrls;
                this.logMode = props.logMode ?? 'info';
                const { chain, rpcProvider, web3Provider } = this.init(props, version);
                this.chain = chain;
                this.rpcProvider = rpcProvider;
                __classPrivateFieldSet(this, _LidoSDKCore_web3Provider, web3Provider, "f");
            }
            // Static Provider Creation
            static createRpcProvider(chainId, rpcUrls) {
                const rpcs = rpcUrls.map((url) => http(url));
                return createPublicClient({
                    batch: {
                        multicall: true,
                    },
                    chain: VIEM_CHAINS[chainId],
                    transport: fallback(rpcs),
                });
            }
            static createWeb3Provider(chainId, transport, transportConfig) {
                return createWalletClient({
                    chain: VIEM_CHAINS[chainId],
                    transport: custom(transport, transportConfig),
                });
            }
            init(props, _version) {
                const { chainId, rpcUrls, web3Provider, rpcProvider } = props;
                if (!SUPPORTED_CHAINS.includes(chainId)) {
                    throw this.error({
                        message: `Unsupported chain: ${chainId}`,
                        code: ERROR_CODE.INVALID_ARGUMENT,
                    });
                }
                if (!rpcProvider && rpcUrls.length === 0) {
                    throw this.error({
                        message: `Either rpcProvider or rpcUrls are required`,
                        code: ERROR_CODE.INVALID_ARGUMENT,
                    });
                }
                const chain = VIEM_CHAINS[chainId];
                const currentRpcProvider = rpcProvider ?? _a.createRpcProvider(chainId, rpcUrls);
                const currentWeb3Provider = web3Provider;
                return {
                    chain,
                    rpcProvider: currentRpcProvider,
                    web3Provider: currentWeb3Provider,
                };
            }
            // Web 3 provider
            useWeb3Provider() {
                invariant(__classPrivateFieldGet(this, _LidoSDKCore_web3Provider, "f"), 'Web3 Provider is not defined', ERROR_CODE.PROVIDER_ERROR);
                return __classPrivateFieldGet(this, _LidoSDKCore_web3Provider, "f");
            }
            // Balances
            async balanceETH(address) {
                const parsedAccount = await this.useAccount(address);
                return this.rpcProvider.getBalance({ address: parsedAccount.address });
            }
            // Contracts
            contractAddressLidoLocator() {
                const locator = LIDO_LOCATOR_BY_CHAIN[this.chain.id];
                invariant(locator, `Lido Ethereum Contacts are not supported on ${this.chain.name}(${this.chain.id})`, ERROR_CODE.NOT_SUPPORTED);
                return locator;
            }
            getContractLidoLocator() {
                return getContract({
                    address: this.contractAddressLidoLocator(),
                    abi: LidoLocatorAbi,
                    client: this.rpcProvider,
                });
            }
            // PERMIT
            async signPermit(props) {
                const { token, amount, account: accountProp, spender, deadline = _a.INFINITY_DEADLINE_VALUE, } = props;
                const web3Provider = this.useWeb3Provider();
                const account = await this.useAccount(accountProp);
                const { contract, domain } = await this.getPermitContractData(token);
                const nonce = await contract.read.nonces([account.address]);
                const signature = await web3Provider.signTypedData({
                    account,
                    domain,
                    types: PERMIT_MESSAGE_TYPES,
                    primaryType: 'Permit',
                    message: {
                        owner: account.address,
                        spender,
                        value: amount,
                        nonce,
                        deadline,
                    },
                });
                const { s, r, v } = splitSignature(signature);
                return {
                    v,
                    r: r,
                    s: s,
                    value: amount,
                    deadline,
                    nonce,
                    chainId: domain.chainId,
                    owner: account.address,
                    spender,
                };
            }
            // Utils
            async getPermitContractData(token) {
                const tokenAddress = await this.getContractAddress(CONTRACTS_BY_TOKENS[token]);
                const contract = getContract({
                    address: tokenAddress,
                    abi: permitAbi,
                    client: this.rpcProvider,
                });
                let domain = {
                    name: 'Wrapped liquid staked Ether 2.0',
                    version: '1',
                    chainId: BigInt(this.chain.id),
                    verifyingContract: tokenAddress,
                };
                if (token === LIDO_TOKENS.steth) {
                    const [name, version, chainId, verifyingContract] = await contract.read.eip712Domain();
                    domain = {
                        name,
                        version,
                        chainId,
                        verifyingContract,
                    };
                }
                return {
                    contract,
                    domain,
                };
            }
            async getFeeData() {
                // we look back 5 blocks at fees of botton 25% txs
                // if you want to increase maxPriorityFee output increase percentile
                const feeHistory = await this.rpcProvider.getFeeHistory({
                    blockCount: 5,
                    blockTag: 'pending',
                    rewardPercentiles: [25],
                });
                // get average priority fee
                const maxPriorityFeePerGas = feeHistory.reward && feeHistory.reward.length > 0
                    ? feeHistory.reward
                        .map((fees) => (fees[0] ? BigInt(fees[0]) : 0n))
                        .reduce((sum, fee) => sum + fee) / BigInt(feeHistory.reward.length)
                    : 0n;
                const lastBaseFeePerGas = feeHistory.baseFeePerGas[0]
                    ? BigInt(feeHistory.baseFeePerGas[0])
                    : 0n;
                // we have to multiply by 2 until we find a reliable way to predict baseFee change
                const maxFeePerGas = lastBaseFeePerGas * 2n + maxPriorityFeePerGas;
                return {
                    lastBaseFeePerGas,
                    maxPriorityFeePerGas,
                    maxFeePerGas,
                    gasPrice: maxFeePerGas, // fallback
                };
            }
            async getWeb3Address(accountValue) {
                if (typeof accountValue === 'string')
                    return accountValue;
                if (accountValue)
                    return accountValue.address;
                const web3Provider = this.useWeb3Provider();
                if (web3Provider.account)
                    return web3Provider.account.address;
                const [account] = await web3Provider.requestAddresses();
                invariant(account, 'web3provider must have at least 1 account', ERROR_CODE.PROVIDER_ERROR);
                return account;
            }
            async useAccount(accountValue) {
                if (accountValue) {
                    if (typeof accountValue === 'string')
                        return { address: accountValue, type: 'json-rpc' };
                    else
                        return accountValue;
                }
                if (this.web3Provider) {
                    if (!this.web3Provider.account) {
                        const [account] = await withSDKError(this.web3Provider.requestAddresses(), ERROR_CODE.READ_ERROR);
                        invariant(account, 'web3provider must have at least 1 account', ERROR_CODE.PROVIDER_ERROR);
                        this.web3Provider.account = { address: account, type: 'json-rpc' };
                    }
                    return this.web3Provider.account;
                }
                invariantArgument(false, 'No account or web3Provider is available');
            }
            async isContract(address) {
                // eth_getCode returns hex string of bytecode at address
                // for accounts it's "0x"
                // for contract it's potentially very long hex (can't be safely&quickly parsed)
                const result = await this.rpcProvider.getCode({ address: address });
                return result ? result !== '0x' : false;
            }
            error(props) {
                return new SDKError(props);
            }
            async getContractAddress(contract) {
                const lidoLocator = this.getContractLidoLocator();
                if (contract === 'wsteth') {
                    const withdrawalQueue = await lidoLocator.read.withdrawalQueue();
                    const wstethAddress = await readContract(this.rpcProvider, {
                        abi: wqWstethAddressAbi,
                        address: withdrawalQueue,
                        functionName: 'WSTETH',
                    });
                    return wstethAddress;
                }
                else {
                    return lidoLocator.read[contract]();
                }
            }
            getL2ContractAddress(contract) {
                const chainConfig = LIDO_L2_CONTRACT_ADDRESSES[this.chain.id];
                invariant(chainConfig, `Lido L2 contracts are not supported for ${this.chain.name}(${this.chain.id})`, ERROR_CODE.NOT_SUPPORTED);
                const address = chainConfig[contract];
                invariant(address, `Lido L2 on ${this.chain.name}(${this.chain.id}) does not have ${contract} contract`, ERROR_CODE.NOT_SUPPORTED);
                return address;
            }
            getSubgraphId() {
                const id = SUBRGRAPH_ID_BY_CHAIN[this.chainId] ?? null;
                return id;
            }
            async getLatestBlockToTimestamp(timestamp) {
                const now = BigInt(Math.floor(Date.now() / 1000));
                let latestBlock = await this.rpcProvider.getBlock({ blockTag: 'latest' });
                if (latestBlock.timestamp < timestamp) {
                    return latestBlock;
                }
                let mid = latestBlock.number - (now - timestamp) / APPROX_SECONDS_PER_BLOCK;
                invariantArgument(mid > 0n, 'No blocks at this timestamp');
                let block = await this.rpcProvider.getBlock({ blockNumber: mid });
                // feeling lucky?
                if (block.timestamp === timestamp)
                    return block;
                const isOverShoot = block.timestamp < timestamp;
                let left = isOverShoot ? block.number : 0n;
                let right = isOverShoot ? latestBlock.number : block.number;
                while (left <= right) {
                    mid = (left + right) / 2n;
                    block = await this.rpcProvider.getBlock({ blockNumber: mid });
                    if (block.timestamp === timestamp) {
                        return block;
                    }
                    else if (block.timestamp < timestamp) {
                        latestBlock = block;
                        left = mid + 1n;
                    }
                    else {
                        right = mid - 1n;
                    }
                }
                return latestBlock;
            }
            async toBlockNumber(arg) {
                if (arg.timestamp) {
                    const block = await this.getLatestBlockToTimestamp(arg.timestamp);
                    return block.number;
                }
                const { block } = arg;
                if (typeof block === 'bigint')
                    return block;
                const { number } = await this.rpcProvider.getBlock({
                    blockTag: block,
                });
                invariantArgument(number !== null, 'block must not be pending');
                return number;
            }
            async toBackBlock(arg, start) {
                if (arg.blocks) {
                    const end = start - arg.blocks;
                    invariantArgument(end >= 0n, 'Too many blocks back');
                    return end;
                }
                else {
                    const { timestamp: startTimestamp } = await this.rpcProvider.getBlock({
                        blockNumber: start,
                    });
                    const diff = arg.days
                        ? arg.days * _a.SECONDS_PER_DAY
                        : arg.seconds;
                    invariantArgument(diff, 'must have at least something in back argument');
                    const endTimestamp = startTimestamp - diff;
                    const block = await this.getLatestBlockToTimestamp(endTimestamp);
                    return block.number;
                }
            }
            async performTransaction(props) {
                // this guards against not having web3Provider
                this.useWeb3Provider();
                const { callback = NOOP, getGasLimit, sendTransaction, decodeResult, waitForTransactionReceiptParameters = {}, } = props;
                const account = await this.useAccount(props.account);
                const isContract = await this.isContract(account.address);
                let overrides = {
                    account,
                    chain: this.chain,
                    gas: undefined,
                    maxFeePerGas: undefined,
                    maxPriorityFeePerGas: undefined,
                };
                if (isContract) {
                    // passing these stub params prevent unnecessary possibly errorish RPC calls
                    overrides = {
                        ...overrides,
                        gas: 21000n,
                        maxFeePerGas: 1n,
                        maxPriorityFeePerGas: 1n,
                        nonce: 1,
                    };
                }
                else {
                    await callback({ stage: TransactionCallbackStage.GAS_LIMIT });
                    const feeData = await this.getFeeData();
                    overrides.maxFeePerGas = feeData.maxFeePerGas;
                    overrides.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    try {
                        overrides.gas = await getGasLimit({ ...overrides });
                    }
                    catch {
                        // we retry without fees to see if tx will go trough
                        await withSDKError(getGasLimit({
                            ...overrides,
                            maxFeePerGas: undefined,
                            maxPriorityFeePerGas: undefined,
                        }), ERROR_CODE.TRANSACTION_ERROR);
                        throw this.error({
                            code: ERROR_CODE.TRANSACTION_ERROR,
                            message: 'Not enough ether for gas',
                        });
                    }
                }
                const customGas = await callback({
                    stage: TransactionCallbackStage.SIGN,
                    payload: overrides.gas,
                });
                if (typeof customGas === 'bigint')
                    overrides.gas = customGas;
                const hash = await withSDKError(sendTransaction({
                    ...overrides,
                }), ERROR_CODE.TRANSACTION_ERROR);
                if (isContract) {
                    await callback({ stage: TransactionCallbackStage.MULTISIG_DONE });
                    return { hash };
                }
                await callback({
                    stage: TransactionCallbackStage.RECEIPT,
                    payload: hash,
                });
                const receipt = await withSDKError(this.rpcProvider.waitForTransactionReceipt({
                    hash,
                    timeout: 120_000,
                    ...waitForTransactionReceiptParameters,
                }), ERROR_CODE.TRANSACTION_ERROR);
                await callback({
                    stage: TransactionCallbackStage.CONFIRMATION,
                    payload: receipt,
                });
                const confirmations = await this.rpcProvider.getTransactionConfirmations({
                    hash: receipt.transactionHash,
                });
                const result = await decodeResult?.(receipt);
                await callback({
                    stage: TransactionCallbackStage.DONE,
                    payload: confirmations,
                });
                return {
                    hash,
                    receipt,
                    result,
                    confirmations,
                };
            }
        },
        _LidoSDKCore_web3Provider = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _init_decorators = [Initialize('Init:'), Logger('LOG:')];
            _useWeb3Provider_decorators = [Logger('Provider:')];
            _balanceETH_decorators = [Logger('Balances:')];
            _contractAddressLidoLocator_decorators = [Logger('Contracts:'), Cache(30 * 60 * 1000, ['chain.id'])];
            _getContractLidoLocator_decorators = [Logger('Contracts:'), Cache(30 * 60 * 1000, ['chain.id', 'contractAddressLidoLocator'])];
            _signPermit_decorators = [Logger('Permit:')];
            _getPermitContractData_decorators = [Logger('Utils:'), Cache(30 * 60 * 1000, ['chain.id'])];
            _getFeeData_decorators = [Logger('Utils:')];
            _getWeb3Address_decorators = [Logger('Deprecation:')];
            _useAccount_decorators = [Logger('Utils:')];
            _isContract_decorators = [Logger('Utils:'), Cache(60 * 60 * 1000, ['chain.id'])];
            _error_decorators = [Logger('Utils:')];
            _getContractAddress_decorators = [Logger('Utils:'), Cache(30 * 60 * 1000, ['chain.id'])];
            _getL2ContractAddress_decorators = [Logger('Utils:'), Cache(30 * 60 * 1000, ['chain.id'])];
            _getSubgraphId_decorators = [Logger('Utils:'), Cache(30 * 60 * 1000, ['chain.id'])];
            _getLatestBlockToTimestamp_decorators = [Cache(30 * 60, ['chain.id'])];
            _toBlockNumber_decorators = [Logger('Utils:')];
            _toBackBlock_decorators = [Logger('Utils:')];
            __esDecorate(_a, null, _init_decorators, { kind: "method", name: "init", static: false, private: false, access: { has: obj => "init" in obj, get: obj => obj.init }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _useWeb3Provider_decorators, { kind: "method", name: "useWeb3Provider", static: false, private: false, access: { has: obj => "useWeb3Provider" in obj, get: obj => obj.useWeb3Provider }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _balanceETH_decorators, { kind: "method", name: "balanceETH", static: false, private: false, access: { has: obj => "balanceETH" in obj, get: obj => obj.balanceETH }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _contractAddressLidoLocator_decorators, { kind: "method", name: "contractAddressLidoLocator", static: false, private: false, access: { has: obj => "contractAddressLidoLocator" in obj, get: obj => obj.contractAddressLidoLocator }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getContractLidoLocator_decorators, { kind: "method", name: "getContractLidoLocator", static: false, private: false, access: { has: obj => "getContractLidoLocator" in obj, get: obj => obj.getContractLidoLocator }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _signPermit_decorators, { kind: "method", name: "signPermit", static: false, private: false, access: { has: obj => "signPermit" in obj, get: obj => obj.signPermit }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getPermitContractData_decorators, { kind: "method", name: "getPermitContractData", static: false, private: false, access: { has: obj => "getPermitContractData" in obj, get: obj => obj.getPermitContractData }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getFeeData_decorators, { kind: "method", name: "getFeeData", static: false, private: false, access: { has: obj => "getFeeData" in obj, get: obj => obj.getFeeData }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getWeb3Address_decorators, { kind: "method", name: "getWeb3Address", static: false, private: false, access: { has: obj => "getWeb3Address" in obj, get: obj => obj.getWeb3Address }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _useAccount_decorators, { kind: "method", name: "useAccount", static: false, private: false, access: { has: obj => "useAccount" in obj, get: obj => obj.useAccount }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _isContract_decorators, { kind: "method", name: "isContract", static: false, private: false, access: { has: obj => "isContract" in obj, get: obj => obj.isContract }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _error_decorators, { kind: "method", name: "error", static: false, private: false, access: { has: obj => "error" in obj, get: obj => obj.error }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getContractAddress_decorators, { kind: "method", name: "getContractAddress", static: false, private: false, access: { has: obj => "getContractAddress" in obj, get: obj => obj.getContractAddress }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getL2ContractAddress_decorators, { kind: "method", name: "getL2ContractAddress", static: false, private: false, access: { has: obj => "getL2ContractAddress" in obj, get: obj => obj.getL2ContractAddress }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getSubgraphId_decorators, { kind: "method", name: "getSubgraphId", static: false, private: false, access: { has: obj => "getSubgraphId" in obj, get: obj => obj.getSubgraphId }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getLatestBlockToTimestamp_decorators, { kind: "method", name: "getLatestBlockToTimestamp", static: false, private: false, access: { has: obj => "getLatestBlockToTimestamp" in obj, get: obj => obj.getLatestBlockToTimestamp }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _toBlockNumber_decorators, { kind: "method", name: "toBlockNumber", static: false, private: false, access: { has: obj => "toBlockNumber" in obj, get: obj => obj.toBlockNumber }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _toBackBlock_decorators, { kind: "method", name: "toBackBlock", static: false, private: false, access: { has: obj => "toBackBlock" in obj, get: obj => obj.toBackBlock }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        Object.defineProperty(_a, "INFINITY_DEADLINE_VALUE", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: maxUint256
        }),
        Object.defineProperty(_a, "SECONDS_PER_DAY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 86400n
        }),
        _a;
})();
export default LidoSDKCore;
//# sourceMappingURL=core.js.map