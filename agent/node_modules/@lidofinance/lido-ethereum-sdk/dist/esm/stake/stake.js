var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { zeroAddress, getContract, encodeFunctionData, decodeEventLog, getAbiItem, toEventHash, isAddressEqual, } from 'viem';
import { ERROR_CODE, invariant } from '../common/utils/sdk-error.js';
import { Logger, Cache, ErrorHandler } from '../common/decorators/index.js';
import { SUBMIT_EXTRA_GAS_TRANSACTION_RATIO, LIDO_CONTRACT_NAMES, NOOP, GAS_TRANSACTION_RATIO_PRECISION, } from '../common/constants.js';
import { parseValue } from '../common/utils/parse-value.js';
import { StethAbi, StethEventsPartialAbi } from './abi/steth.js';
import { LidoSDKModule } from '../common/class-primitives/sdk-module.js';
let LidoSDKStake = (() => {
    var _a;
    let _classSuper = LidoSDKModule;
    let _instanceExtraInitializers = [];
    let _contractAddressStETH_decorators;
    let _getContractStETH_decorators;
    let _stakeEth_decorators;
    let _stakeEthSimulateTx_decorators;
    let _getStakeLimitInfo_decorators;
    let _stakeEthEstimateGas_decorators;
    let _submitParseEvents_decorators;
    let _validateStakeLimit_decorators;
    let _stakeEthEncodeData_decorators;
    let _stakeEthPopulateTx_decorators;
    return _a = class LidoSDKStake extends _classSuper {
            // Contracts
            async contractAddressStETH() {
                return await this.core.getContractAddress(LIDO_CONTRACT_NAMES.lido);
            }
            async getContractStETH() {
                const address = await this.contractAddressStETH();
                return getContract({
                    address,
                    abi: StethAbi,
                    client: {
                        public: this.core.rpcProvider,
                        wallet: this.core.web3Provider,
                    },
                });
            }
            // Calls
            async stakeEth(props) {
                this.core.useWeb3Provider();
                const { callback, account, referralAddress, value, ...rest } = await this.parseProps(props);
                await this.validateStakeLimit(value);
                const { address } = await this.core.useAccount(account);
                const contract = await this.getContractStETH();
                return this.core.performTransaction({
                    ...rest,
                    callback,
                    account,
                    getGasLimit: async (options) => this.stakeEthEstimateGas({ value, account, referralAddress }, options),
                    sendTransaction: (options) => contract.write.submit([referralAddress], { ...options, value }),
                    decodeResult: async (receipt) => this.submitParseEvents(receipt, address),
                });
            }
            async stakeEthSimulateTx(props) {
                const { referralAddress, value, account } = await this.parseProps(props);
                const contract = await this.getContractStETH();
                const { request } = await contract.simulate.submit([referralAddress], {
                    account,
                    value: value,
                });
                return request;
            }
            // Views
            async getStakeLimitInfo() {
                const contract = await this.getContractStETH();
                const [isStakingPaused, isStakingLimitSet, currentStakeLimit, maxStakeLimit, maxStakeLimitGrowthBlocks, prevStakeLimit, prevStakeBlockNumber,] = await contract.read.getStakeLimitFullInfo();
                return {
                    isStakingPaused,
                    isStakingLimitSet,
                    currentStakeLimit,
                    maxStakeLimit,
                    maxStakeLimitGrowthBlocks,
                    prevStakeLimit,
                    prevStakeBlockNumber,
                };
            }
            // Utils
            async stakeEthEstimateGas(props, options) {
                const { referralAddress, value, account } = await this.parseProps(props);
                const contract = await this.getContractStETH();
                const originalGasLimit = await contract.estimateGas.submit([referralAddress], { account, ...options, value });
                const gasLimit = (originalGasLimit *
                    BigInt(GAS_TRANSACTION_RATIO_PRECISION * SUBMIT_EXTRA_GAS_TRANSACTION_RATIO)) /
                    BigInt(GAS_TRANSACTION_RATIO_PRECISION);
                return gasLimit;
            }
            submitParseEvents(receipt, address) {
                let stethReceived;
                let sharesReceived;
                for (const log of receipt.logs) {
                    // skips non-relevant events
                    if (log.topics[0] !== _a.TRANSFER_SIGNATURE &&
                        log.topics[0] !== _a.TRANSFER_SHARES_SIGNATURE)
                        continue;
                    const parsedLog = decodeEventLog({
                        abi: StethEventsPartialAbi,
                        strict: true,
                        ...log,
                    });
                    if (parsedLog.eventName === 'Transfer' &&
                        isAddressEqual(parsedLog.args.to, address)) {
                        stethReceived = parsedLog.args.value;
                    }
                    else if (parsedLog.eventName === 'TransferShares' &&
                        isAddressEqual(parsedLog.args.to, address)) {
                        sharesReceived = parsedLog.args.sharesValue;
                    }
                }
                invariant(stethReceived, 'could not find Transfer event in stake transaction', ERROR_CODE.TRANSACTION_ERROR);
                invariant(sharesReceived, 'could not find TransferShares event in stake transaction', ERROR_CODE.TRANSACTION_ERROR);
                return { sharesReceived, stethReceived };
            }
            async validateStakeLimit(value) {
                const { currentStakeLimit } = await this.getStakeLimitInfo();
                if (value > currentStakeLimit) {
                    throw this.core.error({
                        code: ERROR_CODE.TRANSACTION_ERROR,
                        message: `Stake value is greater than daily protocol staking limit (${currentStakeLimit})`,
                    });
                }
            }
            stakeEthEncodeData(props) {
                const { referralAddress = zeroAddress } = props;
                return encodeFunctionData({
                    abi: StethAbi,
                    functionName: 'submit',
                    args: [referralAddress],
                });
            }
            async stakeEthPopulateTx(props) {
                const { referralAddress, value, account } = await this.parseProps(props);
                const data = this.stakeEthEncodeData({ referralAddress });
                const gas = await this.stakeEthEstimateGas(props, {
                    chain: this.core.chain,
                    account,
                });
                const address = await this.contractAddressStETH();
                return {
                    to: address,
                    from: account.address,
                    gas,
                    value,
                    data,
                };
            }
            async parseProps(props) {
                return {
                    ...props,
                    account: await this.core.useAccount(props.account),
                    referralAddress: props.referralAddress ?? zeroAddress,
                    value: parseValue(props.value),
                    callback: props.callback ?? NOOP,
                };
            }
            constructor() {
                super(...arguments);
                __runInitializers(this, _instanceExtraInitializers);
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _contractAddressStETH_decorators = [Logger('Contracts:'), Cache(30 * 60 * 1000, ['core.chain.id'])];
            _getContractStETH_decorators = [Logger('Contracts:'), Cache(30 * 60 * 1000, ['core.chain.id', 'contractAddressStETH'])];
            _stakeEth_decorators = [Logger('Call:'), ErrorHandler()];
            _stakeEthSimulateTx_decorators = [Logger('Call:'), ErrorHandler()];
            _getStakeLimitInfo_decorators = [Logger('Views:'), ErrorHandler()];
            _stakeEthEstimateGas_decorators = [Logger('Utils:'), Cache(30 * 1000, ['core.chain.id'])];
            _submitParseEvents_decorators = [Logger('Utils:')];
            _validateStakeLimit_decorators = [Logger('Utils:')];
            _stakeEthEncodeData_decorators = [Logger('Utils:')];
            _stakeEthPopulateTx_decorators = [Logger('Utils:')];
            __esDecorate(_a, null, _contractAddressStETH_decorators, { kind: "method", name: "contractAddressStETH", static: false, private: false, access: { has: obj => "contractAddressStETH" in obj, get: obj => obj.contractAddressStETH }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getContractStETH_decorators, { kind: "method", name: "getContractStETH", static: false, private: false, access: { has: obj => "getContractStETH" in obj, get: obj => obj.getContractStETH }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _stakeEth_decorators, { kind: "method", name: "stakeEth", static: false, private: false, access: { has: obj => "stakeEth" in obj, get: obj => obj.stakeEth }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _stakeEthSimulateTx_decorators, { kind: "method", name: "stakeEthSimulateTx", static: false, private: false, access: { has: obj => "stakeEthSimulateTx" in obj, get: obj => obj.stakeEthSimulateTx }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getStakeLimitInfo_decorators, { kind: "method", name: "getStakeLimitInfo", static: false, private: false, access: { has: obj => "getStakeLimitInfo" in obj, get: obj => obj.getStakeLimitInfo }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _stakeEthEstimateGas_decorators, { kind: "method", name: "stakeEthEstimateGas", static: false, private: false, access: { has: obj => "stakeEthEstimateGas" in obj, get: obj => obj.stakeEthEstimateGas }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _submitParseEvents_decorators, { kind: "method", name: "submitParseEvents", static: false, private: false, access: { has: obj => "submitParseEvents" in obj, get: obj => obj.submitParseEvents }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _validateStakeLimit_decorators, { kind: "method", name: "validateStakeLimit", static: false, private: false, access: { has: obj => "validateStakeLimit" in obj, get: obj => obj.validateStakeLimit }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _stakeEthEncodeData_decorators, { kind: "method", name: "stakeEthEncodeData", static: false, private: false, access: { has: obj => "stakeEthEncodeData" in obj, get: obj => obj.stakeEthEncodeData }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _stakeEthPopulateTx_decorators, { kind: "method", name: "stakeEthPopulateTx", static: false, private: false, access: { has: obj => "stakeEthPopulateTx" in obj, get: obj => obj.stakeEthPopulateTx }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        // Precomputed event signatures
        Object.defineProperty(_a, "TRANSFER_SIGNATURE", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toEventHash(getAbiItem({ abi: StethEventsPartialAbi, name: 'Transfer' }))
        }),
        Object.defineProperty(_a, "TRANSFER_SHARES_SIGNATURE", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toEventHash(getAbiItem({ abi: StethEventsPartialAbi, name: 'TransferShares' }))
        }),
        _a;
})();
export { LidoSDKStake };
//# sourceMappingURL=stake.js.map