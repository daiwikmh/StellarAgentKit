"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AgentRuntime: () => AgentRuntime,
  AmnisStakeTool: () => AmnisStakeTool,
  AmnisWithdrawStakeTool: () => AmnisWithdrawStakeTool,
  AptosAccountAddressTool: () => AptosAccountAddressTool,
  AptosBalanceTool: () => AptosBalanceTool,
  AptosBurnTokenTool: () => AptosBurnTokenTool,
  AptosCreateTokenTool: () => AptosCreateTokenTool,
  AptosGetTokenDetailTool: () => AptosGetTokenDetailTool,
  AptosGetTokenPriceTool: () => AptosGetTokenPriceTool,
  AptosMintTokenTool: () => AptosMintTokenTool,
  AptosTransactionTool: () => AptosTransactionTool,
  AptosTransferTokenTool: () => AptosTransferTokenTool,
  AriesBorrowTool: () => AriesBorrowTool,
  AriesCreateProfileTool: () => AriesCreateProfileTool,
  AriesLendTool: () => AriesLendTool,
  AriesRepayTool: () => AriesRepayTool,
  AriesWithdrawTool: () => AriesWithdrawTool,
  BaseSigner: () => BaseSigner,
  EchelonBorrowTokenTool: () => EchelonBorrowTokenTool,
  EchelonLendTokenTool: () => EchelonLendTokenTool,
  EchelonRepayTokenTool: () => EchelonRepayTokenTool,
  EchelonWithdrawTokenTool: () => EchelonWithdrawTokenTool,
  EchoStakeTokenTool: () => EchoStakeTokenTool,
  EchoUnstakeTokenTool: () => EchoUnstakeTokenTool,
  JouleBorrowTokenTool: () => JouleBorrowTokenTool,
  JouleClaimRewardTool: () => JouleClaimRewardTool,
  JouleGetPoolDetails: () => JouleGetPoolDetails,
  JouleGetUserAllPositions: () => JouleGetUserAllPositions,
  JouleGetUserPosition: () => JouleGetUserPosition,
  JouleLendTokenTool: () => JouleLendTokenTool,
  JouleRepayTokenTool: () => JouleRepayTokenTool,
  JouleWithdrawTokenTool: () => JouleWithdrawTokenTool,
  LiquidSwapAddLiquidityTool: () => LiquidSwapAddLiquidityTool,
  LiquidSwapCreatePoolTool: () => LiquidSwapCreatePoolTool,
  LiquidSwapRemoveLiquidityTool: () => LiquidSwapRemoveLiquidityTool,
  LiquidSwapSwapTool: () => LiquidSwapSwapTool,
  LocalSigner: () => LocalSigner,
  OpenAICreateImageTool: () => OpenAICreateImageTool,
  PanoraSwapTool: () => PanoraSwapTool,
  ThalaAddLiquidityTool: () => ThalaAddLiquidityTool,
  ThalaMintMODTool: () => ThalaMintMODTool,
  ThalaRedeemMODTool: () => ThalaRedeemMODTool,
  ThalaRemoveLiquidityTool: () => ThalaRemoveLiquidityTool,
  ThalaStakeTokenTool: () => ThalaStakeTokenTool,
  ThalaUnstakeTokenTool: () => ThalaUnstakeTokenTool,
  WalletSigner: () => WalletSigner,
  createAptosTools: () => createAptosTools,
  parseJson: () => parseJson
});
module.exports = __toCommonJS(index_exports);

// src/signers/base-signer.ts
var BaseSigner = class {
  constructor(account, aptos) {
    this.account = account;
    this.aptos = aptos;
  }
  getAddress() {
    return this.account.accountAddress;
  }
};

// src/signers/local-signer.ts
var import_ts_sdk = require("@aptos-labs/ts-sdk");
var LocalSigner = class extends BaseSigner {
  constructor(account, network = import_ts_sdk.Network.DEVNET) {
    const config = new import_ts_sdk.AptosConfig({ network });
    const aptos = new import_ts_sdk.Aptos(config);
    super(account, aptos);
  }
  getAddress() {
    return this.account.accountAddress;
  }
  async signTransaction(transaction) {
    const senderAuthenticator = this.aptos.transaction.sign({
      signer: this.account,
      transaction
    });
    return {
      senderAuthenticator
    };
  }
  async sendTransaction(transaction) {
    const signedTx = await this.signTransaction(transaction);
    const submittedTx = await this.aptos.transaction.submit.simple({
      transaction,
      senderAuthenticator: signedTx.senderAuthenticator
    });
    const result = await this.aptos.waitForTransaction({
      transactionHash: submittedTx.hash
    });
    return result.hash;
  }
  async signMessage(message) {
    const signedMessage = this.account.signWithAuthenticator(message);
    return signedMessage.toString();
  }
};

// src/signers/wallet-signer.ts
var import_ts_sdk2 = require("@aptos-labs/ts-sdk");
var WalletSigner = class extends BaseSigner {
  constructor(account, wallet, network = import_ts_sdk2.Network.DEVNET) {
    const config = new import_ts_sdk2.AptosConfig({ network });
    const aptos = new import_ts_sdk2.Aptos(config);
    super(account, aptos);
    this.wallet = wallet;
  }
  getAddress() {
    const walletAddress = this.wallet?.account?.address;
    return walletAddress ? import_ts_sdk2.AccountAddress.fromString(walletAddress.toString()) : this.account.accountAddress;
  }
  async signTransaction(transaction) {
    const senderAuthenticator = await this.wallet.signTransaction({
      transactionOrPayload: transaction
    });
    return {
      senderAuthenticator: senderAuthenticator.authenticator
    };
  }
  async sendTransaction(transaction) {
    const txHash = await this.wallet.signAndSubmitTransaction(transaction);
    return txHash.hash;
  }
  async signMessage(message) {
    return this.wallet.signMessage(message);
  }
};

// src/agent.ts
var import_pyth_aptos_js = require("@pythnetwork/pyth-aptos-js");

// src/constants/price-feed.ts
var priceFeed = [
  "0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
  "0x2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b",
  "0x2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b",
  "0x03ae4db29ed4ae33d323568895aa00337e658e348b37509f5372ae51f0af00d5",
  "0x9d4294bbcd1174d6f2003ec365831e64cc31d9f6f15a2b85399db8d5000960f6",
  "0x03ae4db29ed4ae33d323568895aa00337e658e348b37509f5372ae51f0af00d5",
  "0xc9d8b075a5c69303365ae23633d4e085199bf5c520a3b90fed1322a0342ffc33",
  "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43"
];

// src/tools/amnis/stake-token.ts
async function stakeTokens(agent, to, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::router::deposit_and_stake_entry",
        functionArguments: [amount, to.toString()]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token staking failed");
      throw new Error("Token staking failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Token staking failed: ${error.message}`);
  }
}

// src/tools/amnis/withdraw-stake.ts
async function unstakeTokens(agent, to, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::router::unstake_entry",
        functionArguments: [amount, to.toString()]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token unstaking failed");
      throw new Error("Token unstaking failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Token unstaking failed: ${error.message}`);
  }
}

// src/tools/aptos/balance.ts
var import_ts_sdk3 = require("@aptos-labs/ts-sdk");
async function getBalance(agent, mint) {
  try {
    if (mint) {
      let balance2;
      if (mint.split("::").length !== 3) {
        const balances = await agent.aptos.getCurrentFungibleAssetBalances({
          options: {
            where: {
              owner_address: {
                _eq: agent.account.getAddress().toStringLong()
              },
              asset_type: { _eq: mint }
            }
          }
        });
        balance2 = balances[0].amount ?? 0;
      } else {
        balance2 = await agent.aptos.getAccountCoinAmount({
          accountAddress: agent.account.getAddress(),
          coinType: mint
        });
      }
      return balance2;
    }
    const balance = await agent.aptos.getAccountAPTAmount({
      accountAddress: agent.account.getAddress()
    });
    const convertedBalance = (0, import_ts_sdk3.convertAmountFromOnChainToHumanReadable)(balance, 8);
    return convertedBalance;
  } catch (error) {
    throw new Error(`Token transfer failed: ${error.message}`);
  }
}

// src/tools/aptos/burn-nft.ts
async function burnNFT(agent, mint) {
  return "";
}

// src/tools/aptos/burn-token.ts
async function burnToken(agent, amount, mint) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x67c8564aee3799e9ac669553fdef3a3828d4626f24786b6a5642152fa09469dd::launchpad::burn_fa",
        functionArguments: [mint, amount]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token burn failed");
      throw new Error("Token burn failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Token burn failed: ${error.message}`);
  }
}

// src/tools/aptos/transfer-nft.ts
async function transferNFT(agent, to, mint) {
  return "";
}

// src/tools/aptos/transfer-token.ts
async function transferTokens(agent, to, amount, mint) {
  const COIN_STANDARD_DATA = {
    function: "0x1::coin::transfer",
    typeArguments: [mint],
    functionArguments: [to.toString(), amount]
  };
  const FUNGIBLE_ASSET_DATA = {
    function: "0x1::primary_fungible_store::transfer",
    typeArguments: ["0x1::fungible_asset::Metadata"],
    functionArguments: [mint, to.toString(), amount]
  };
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: mint.split("::").length === 3 ? COIN_STANDARD_DATA : FUNGIBLE_ASSET_DATA
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token transfer failed");
      throw new Error("Token transfer failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Token transfer failed: ${error.message}`);
  }
}

// src/tools/aptos/mint-token.ts
async function mintToken(agent, to, mint, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x67c8564aee3799e9ac669553fdef3a3828d4626f24786b6a5642152fa09469dd::launchpad::mint_to_address",
        functionArguments: [to.toString(), mint, amount]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token mint failed");
      throw new Error("Token mint failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Token mint failed: ${error.message}`);
  }
}

// src/tools/aptos/create-token.ts
async function createToken(agent, name, symbol, iconURI, projectURI) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x67c8564aee3799e9ac669553fdef3a3828d4626f24786b6a5642152fa09469dd::launchpad::create_fa_simple",
        functionArguments: [name, symbol, iconURI, projectURI]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token creation failed");
      throw new Error("Token creation failed");
    }
    return {
      hash: signedTransaction.hash,
      // @ts-ignore
      token: signedTransaction.events[0].data.fa_obj.inner
    };
  } catch (error) {
    throw new Error(`Token creation failed: ${error.message}`);
  }
}

// src/tools/aptos/get-transaction.ts
async function getTransaction(agent, hash) {
  try {
    const transaction = await agent.aptos.getTransactionByHash({
      transactionHash: hash
    });
    return transaction;
  } catch (error) {
    throw new Error(`Token transfer failed: ${error.message}`);
  }
}

// src/tools/aptos/get-token-details.ts
var import_axios = __toESM(require("axios"));
async function getTokenDetails(tokenAddress) {
  try {
    const res = await import_axios.default.get(
      "https://raw.githubusercontent.com/PanoraExchange/Aptos-Tokens/refs/heads/main/token-list.json"
    );
    const tokenData = await res.data;
    if (!tokenAddress || tokenAddress === "") return tokenData[0];
    const token = tokenData.find(
      (tokenAddr) => (tokenAddr.tokenAddress || tokenAddr.faAddress).toLowerCase() === tokenAddress.toLowerCase()
    );
    if (!token && tokenAddress.includes("fa_to_coin_wrapper::WrappedUSDT")) {
      return tokenData.find(
        (e) => e.faAddress === "0x357b0b74bc833e95a115ad22604854d6b0fca151cecd94111770e5d6ffc9dc2b"
      );
    }
    if (!token) throw new Error("Cannot find token");
    return token;
  } catch (error) {
    throw new Error(`Token transfer failed: ${error.message}`);
  }
}

// src/tools/aptos/get-token-price.ts
async function getTokenPrice(query) {
  try {
    const assetDataResponse = await fetch(`https://hermes.pyth.network/v2/price_feeds?query=${query}&asset_type=crypto`);
    const assetData = await assetDataResponse.json();
    const formattedData = assetData.map((data) => {
      return {
        id: data.id,
        displayName: data.attributes.display_symbol,
        symbol: data.attributes.symbol
      };
    });
    const assetIdArray = formattedData.map((data) => data.id);
    if (assetIdArray.length === 0) {
      throw new Error("No assets found for the given query");
    }
    const assetPriceDataResponse = await fetch(
      `https://hermes.pyth.network/v2/updates/price/latest?ids[]=${assetIdArray.join("&ids[]=")}`
    );
    const assetPriceData = await assetPriceDataResponse.json();
    const priceFeed2 = formattedData.map((data) => {
      const priceData = assetPriceData.parsed.find((price) => price.id === data.id);
      return {
        ...data,
        price: (Number(priceData.price.price) / 10 ** Math.abs(priceData.price.expo)).toLocaleString() || Number(priceData.price.price).toLocaleString()
      };
    });
    return priceFeed2;
  } catch (error) {
    throw new Error(`Token transfer failed: ${error.message}`);
  }
}

// src/tools/joule/lend.ts
async function lendToken(agent, amount, mint, positionId, newPosition, fungibleAsset) {
  const DEFAULT_FUNCTIONAL_ARGS = [positionId, amount, newPosition];
  const COIN_STANDARD_DATA = {
    function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::lend",
    typeArguments: [mint.toString()],
    functionArguments: DEFAULT_FUNCTIONAL_ARGS
  };
  const FUNGIBLE_ASSET_DATA = {
    function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::lend_fa",
    functionArguments: [positionId, mint.toString(), newPosition, amount]
  };
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: fungibleAsset ? FUNGIBLE_ASSET_DATA : COIN_STANDARD_DATA
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token mint failed");
      throw new Error("Token mint failed");
    }
    return {
      hash: signedTransaction.hash,
      // @ts-ignore
      positionId: signedTransaction.events[0].data.position_id
    };
  } catch (error) {
    throw new Error(`Token mint failed: ${error.message}`);
  }
}

// src/tools/joule/borrow.ts
async function borrowToken(agent, amount, mint, positionId, fungibleAsset) {
  const pyth_update_data = await agent.getPythData();
  const DEFAULT_FUNCTIONAL_ARGS = [positionId, amount, pyth_update_data];
  const COIN_STANDARD_DATA = {
    function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::borrow",
    typeArguments: [mint.toString()],
    functionArguments: DEFAULT_FUNCTIONAL_ARGS
  };
  const FUNGIBLE_ASSET_DATA = {
    function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::borrow_fa",
    functionArguments: [positionId, mint.toString(), amount, pyth_update_data]
  };
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: fungibleAsset ? FUNGIBLE_ASSET_DATA : COIN_STANDARD_DATA
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token borrow failed");
      throw new Error("Token borrow failed");
    }
    return {
      hash: signedTransaction.hash,
      positionId
    };
  } catch (error) {
    throw new Error(`Token borrow failed: ${error.message}`);
  }
}

// src/tools/joule/repay.ts
async function repayToken(agent, amount, mint, positionId, fungibleAsset) {
  const DEFAULT_FUNCTIONAL_ARGS = [positionId, amount];
  const COIN_STANDARD_DATA = {
    function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::repay",
    typeArguments: [mint.toString()],
    functionArguments: DEFAULT_FUNCTIONAL_ARGS
  };
  const FUNGIBLE_ASSET_DATA = {
    function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::repay_fa",
    functionArguments: [positionId, mint.toString(), amount]
  };
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: fungibleAsset ? FUNGIBLE_ASSET_DATA : COIN_STANDARD_DATA
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token repay failed");
      throw new Error("Token repay failed");
    }
    return {
      hash: signedTransaction.hash,
      positionId
    };
  } catch (error) {
    throw new Error(`Token repay failed: ${error.message}`);
  }
}

// src/tools/joule/withdraw.ts
async function withdrawToken(agent, amount, mint, positionId, fungibleAsset) {
  const pyth_update_data = await agent.getPythData();
  const DEFAULT_FUNCTIONAL_ARGS = [positionId, amount, pyth_update_data];
  const COIN_STANDARD_DATA = {
    function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::withdraw",
    typeArguments: [mint.toString()],
    functionArguments: DEFAULT_FUNCTIONAL_ARGS
  };
  const FUNGIBLE_ASSET_DATA = {
    function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::withdraw_fa",
    functionArguments: [positionId, mint.toString(), amount, pyth_update_data]
  };
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: fungibleAsset ? FUNGIBLE_ASSET_DATA : COIN_STANDARD_DATA
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Token withdraw failed");
      throw new Error("Token withdraw failed");
    }
    return {
      hash: signedTransaction.hash,
      positionId
    };
  } catch (error) {
    throw new Error(`Token withdraw failed: ${error.message}`);
  }
}

// src/tools/joule/pool-detail.ts
async function getPoolDetails(agent, mint) {
  try {
    const allPoolDetailsResponse = await fetch("https://price-api.joule.finance/api/market");
    const allPoolDetails = await allPoolDetailsResponse.json();
    const poolDetail = allPoolDetails.data.find((pool) => pool.asset.type.includes(mint));
    if (!poolDetail) {
      throw new Error("Pool not found");
    }
    return {
      assetName: poolDetail.asset.assetName,
      tokenAddress: mint,
      ltv: poolDetail.ltv,
      decimals: poolDetail.asset.decimals,
      marketSize: Number(poolDetail.marketSize) / poolDetail.asset.decimals,
      totalBorrowed: Number(poolDetail.totalBorrowed) / poolDetail.asset.decimals,
      depositApy: poolDetail.depositApy,
      extraDepositApy: poolDetail.extraAPY.depositAPY,
      borrowApy: poolDetail.borrowApy,
      price: poolDetail.priceInfo.price
    };
  } catch (error) {
    throw new Error(`Failed to get pool details: ${error.message}`);
  }
}

// src/tools/joule/user-position.ts
async function getUserPosition(agent, userAddress, positionId) {
  try {
    const transaction = await agent.aptos.view({
      payload: {
        function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::user_position_details",
        functionArguments: [userAddress.toString(), positionId]
      }
    });
    if (!transaction) {
      throw new Error("Failed to fetch user position");
    }
    return transaction;
  } catch (error) {
    throw new Error(`Failed to get user position: ${error.message}`);
  }
}

// src/utils/clean-joule-all-positions-list.ts
var removeLastInterestRateIndex = (obj) => {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => removeLastInterestRateIndex(item));
  }
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (key === "last_interest_rate_index") {
      return acc;
    }
    acc[key] = removeLastInterestRateIndex(value);
    return acc;
  }, {});
};

// src/tools/joule/user-all-positions.ts
async function getUserAllPositions(agent, userAddress) {
  try {
    const transaction = await agent.aptos.view({
      payload: {
        function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::user_positions_map",
        functionArguments: [userAddress.toString()]
      }
    });
    if (!transaction) {
      throw new Error("Failed to fetch user all positions");
    }
    const cleanedTransaction = removeLastInterestRateIndex(transaction);
    return cleanedTransaction;
  } catch (error) {
    throw new Error(`Failed to get user all positions: ${error.message}`);
  }
}

// src/tools/joule/claim-reward.ts
async function claimReward(agent, rewardCoinType) {
  try {
    const coinReward = `${rewardCoinType}1111`.replace("0x", "@");
    const isCoinTypeSTApt = rewardCoinType === "0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::stapt_token::StakedApt";
    console.log({
      sender: agent.account.getAddress(),
      data: {
        function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::claim_rewards",
        typeArguments: [
          isCoinTypeSTApt ? "0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::amapt_token::AmnisApt" : "0x1::aptos_coin::AptosCoin"
        ],
        functionArguments: [coinReward, isCoinTypeSTApt ? "amAPTIncentives" : "APTIncentives"]
      }
    });
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x2fe576faa841347a9b1b32c869685deb75a15e3f62dfe37cbd6d52cc403a16f6::pool::claim_rewards",
        typeArguments: [
          isCoinTypeSTApt ? "0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::amapt_token::AmnisApt" : "0x1::aptos_coin::AptosCoin"
        ],
        functionArguments: [coinReward, isCoinTypeSTApt ? "amAPTIncentives" : "APTIncentives"]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Claim rewards failed");
      throw new Error("Claim rewards failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Claim rewards failed: ${error.message}`);
  }
}

// src/tools/aries/create-profile.ts
async function createAriesProfile(agent) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3::controller::register_user",
        functionArguments: ["Main account"]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Create profile failed");
      throw new Error("Create profile failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Create profile failed: ${error.message}`);
  }
}

// src/tools/aries/lend.ts
async function lendAriesToken(agent, mintType, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3::controller::deposit",
        typeArguments: [mintType],
        functionArguments: ["Main account", amount, false]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Lend failed");
      throw new Error("Lend failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Lend failed: ${error.message}`);
  }
}

// src/tools/aries/borrow.ts
async function borrowAriesToken(agent, mintType, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3::controller::withdraw",
        typeArguments: [mintType],
        functionArguments: ["Main account", amount, true]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Borrow failed");
      throw new Error("Borrow failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Borrow failed: ${error.message}`);
  }
}

// src/tools/aries/withdraw.ts
async function withdrawAriesToken(agent, mintType, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3::controller::withdraw",
        typeArguments: [mintType],
        functionArguments: ["Main account", amount, false]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Withdraw failed");
      throw new Error("Withdraw failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Withdraw failed: ${error.message}`);
  }
}

// src/tools/aries/repay.ts
async function repayAriesToken(agent, mintType, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3::controller::deposit",
        typeArguments: [mintType],
        functionArguments: ["Main account", amount, true]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Repay failed");
      throw new Error("Repay failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Repay failed: ${error.message}`);
  }
}

// src/tools/echelon/lend.ts
async function lendTokenWithEchelon(agent, mintType, amount, poolAddress, fungibleAsset) {
  try {
    const FUNCTIONAL_ARGS_DATA = [poolAddress, amount];
    const COIN_STANDARD_DATA = {
      function: "0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba::scripts::supply",
      typeArguments: [mintType.toString()],
      functionArguments: FUNCTIONAL_ARGS_DATA
    };
    const FUNGIBLE_ASSET_DATA = {
      function: "0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba::scripts::supply_fa",
      functionArguments: FUNCTIONAL_ARGS_DATA
    };
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: fungibleAsset ? FUNGIBLE_ASSET_DATA : COIN_STANDARD_DATA
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Lend failed");
      throw new Error("Lend failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Lend failed: ${error.message}`);
  }
}

// src/tools/echelon/withdraw.ts
async function withdrawTokenWithEchelon(agent, mintType, amount, poolAddress, fungibleAsset) {
  try {
    const FUNCTIONAL_ARGS_DATA = [poolAddress, amount];
    const COIN_STANDARD_DATA = {
      function: "0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba::scripts::withdraw",
      typeArguments: [mintType.toString()],
      functionArguments: FUNCTIONAL_ARGS_DATA
    };
    const FUNGIBLE_ASSET_DATA = {
      function: "0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba::scripts::withdraw_fa",
      functionArguments: FUNCTIONAL_ARGS_DATA
    };
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: fungibleAsset ? FUNGIBLE_ASSET_DATA : COIN_STANDARD_DATA
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Withdraw failed");
      throw new Error("Withdraw failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Withdraw failed: ${error.message}`);
  }
}

// src/tools/echelon/repay.ts
async function repayTokenWithEchelon(agent, mintType, amount, poolAddress, fungibleAsset) {
  try {
    const FUNCTIONAL_ARGS_DATA = [poolAddress, amount];
    const COIN_STANDARD_DATA = {
      function: "0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba::scripts::repay",
      typeArguments: [mintType.toString()],
      functionArguments: FUNCTIONAL_ARGS_DATA
    };
    const FUNGIBLE_ASSET_DATA = {
      function: "0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba::scripts::repay_fa",
      functionArguments: FUNCTIONAL_ARGS_DATA
    };
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: fungibleAsset ? FUNGIBLE_ASSET_DATA : COIN_STANDARD_DATA
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Repay failed");
      throw new Error("Repay failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Repay failed: ${error.message}`);
  }
}

// src/tools/echelon/borrow.ts
async function borrowTokenWithEchelon(agent, mintType, amount, poolAddress, fungibleAsset) {
  const FUNCTIONAL_ARGS_DATA = [poolAddress, amount];
  const COIN_STANDARD_DATA = {
    function: "0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba::scripts::borrow",
    typeArguments: [mintType.toString()],
    functionArguments: FUNCTIONAL_ARGS_DATA
  };
  const FUNGIBLE_ASSET_DATA = {
    function: "0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba::scripts::borrow_fa",
    functionArguments: FUNCTIONAL_ARGS_DATA
  };
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: fungibleAsset ? FUNGIBLE_ASSET_DATA : COIN_STANDARD_DATA
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Borrow failed");
      throw new Error("Borrow failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Borrow failed: ${error.message}`);
  }
}

// src/tools/echo/stake.ts
async function stakeTokenWithEcho(agent, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0xa0281660ff6ca6c1b68b55fcb9b213c2276f90ad007ad27fd003cf2f3478e96e::lsdmanage::stake",
        functionArguments: [amount]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Stake token in Echo failed");
      throw new Error("Stake token in Echo failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Stake token in Echo failed: ${error.message}`);
  }
}

// src/tools/echo/unstake.ts
async function unstakeTokenWithEcho(agent, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0xa0281660ff6ca6c1b68b55fcb9b213c2276f90ad007ad27fd003cf2f3478e96e::lsdmanage::unstake",
        functionArguments: [amount]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Unstake token in Echo failed");
      throw new Error("Unstake token in Echo failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Unstake token in Echo failed: ${error.message}`);
  }
}

// src/tools/liquidswap/swap.ts
async function swap(agent, mintX, mintY, swapAmount, minCoinOut = 0) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12::scripts_v2::swap",
        typeArguments: [
          mintX,
          mintY,
          "0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12::curves::Uncorrelated"
        ],
        functionArguments: [swapAmount, minCoinOut]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Swap failed");
      throw new Error("Swap failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Swap failed: ${error.message}`);
  }
}

// src/tools/liquidswap/create-pool.ts
async function createPool(agent, mintX, mintY) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12::scripts_v2::register_pool",
        typeArguments: [
          mintX,
          mintY,
          "0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12::curves::Uncorrelated"
        ],
        functionArguments: []
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Create pool failed");
      throw new Error("Create pool failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Create pool failed: ${error.message}`);
  }
}

// src/tools/liquidswap/add-liquidity.ts
async function addLiquidity(agent, mintX, mintY, mintXAmount, mintYAmount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b::router::add_liquidity_v05",
        typeArguments: [
          mintX,
          mintY,
          "0x163df34fccbf003ce219d3f1d9e70d140b60622cb9dd47599c25fb2f797ba6e::curves::Uncorrelated"
        ],
        functionArguments: [
          mintXAmount,
          0,
          //coin_x_min,
          mintYAmount,
          0
          // coin_y_min
        ]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Add liquidity failed");
      throw new Error("Add liquidity failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    console.error(error, "Add liquidity failed");
    throw new Error(`Add liquidity failed: ${error.message}`);
  }
}

// src/tools/liquidswap/remove-liquidity.ts
async function removeLiquidity(agent, mintX, mintY, lpAmount, minMintX = 0, minMintY = 0) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x9dd974aea0f927ead664b9e1c295e4215bd441a9fb4e53e5ea0bf22f356c8a2b::router::remove_liquidity_v05",
        typeArguments: [
          mintX,
          mintY,
          "0x163df34fccbf003ce219d3f1d9e70d140b60622cb9dd47599c25fb2f797ba6e::curves::Uncorrelated"
        ],
        functionArguments: [lpAmount, minMintX, minMintY]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Remove liquidity failed");
      throw new Error("Remove liquidity failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Remove liquidity failed: ${error.message}`);
  }
}

// src/tools/panora/swap.ts
var import_axios2 = __toESM(require("axios"));
async function swapWithPanora(agent, fromToken, toToken, swapAmount, toWalletAddress) {
  try {
    const panoraParameters = {
      fromTokenAddress: fromToken,
      toTokenAddress: toToken,
      fromTokenAmount: swapAmount.toString(),
      toWalletAddress: toWalletAddress ? toWalletAddress : agent.account.getAddress().toString()
    };
    const url = `https://api.panora.exchange/swap?${new URLSearchParams(panoraParameters).toString()}`;
    const panoraApiKey = agent.config.PANORA_API_KEY;
    if (!panoraApiKey) {
      throw new Error("No PANORA_API_KEY in config");
    }
    const res = await import_axios2.default.post(
      url,
      {},
      {
        headers: {
          "x-api-key": panoraApiKey
        }
      }
    );
    const response = await res.data;
    if (response.quotes.length <= 0) {
      throw new Error("no quotes available from panora");
    }
    const transactionData = response.quotes[0].txData;
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: transactionData.function,
        typeArguments: transactionData.type_arguments,
        functionArguments: transactionData.arguments
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Swap failed");
      throw new Error("Swap tx failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Swap failed: ${error.message}`);
  }
}

// src/tools/openai/create-image.ts
var import_openai = __toESM(require("openai"));
async function createImage(agent, prompt, size = "1024x1024", n = 1) {
  try {
    const apiKey = agent.config.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error("No OPENAI_API_KEY in config");
    }
    const openai = new import_openai.default({ apiKey });
    const response = await openai.images.generate({
      prompt,
      n,
      size
    });
    return {
      images: response.data.map((img) => img.url)
    };
  } catch (error) {
    throw new Error(`Image generation failed: ${error.message}`);
  }
}

// src/tools/thala/stake.ts
async function stakeTokenWithThala(agent, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0xfaf4e633ae9eb31366c9ca24214231760926576c7b625313b3688b5e900731f6::scripts::stake_APT_and_thAPT",
        functionArguments: [amount]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Stake APT failed");
      throw new Error("Stake APT failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Stake APT failed: ${error.message}`);
  }
}

// src/tools/thala/unstake.ts
async function unstakeAPTWithThala(agent, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0xfaf4e633ae9eb31366c9ca24214231760926576c7b625313b3688b5e900731f6::scripts::unstake_thAPT",
        functionArguments: [amount]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Unstake token failed");
      throw new Error("Unstake token failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Unstake token failed: ${error.message}`);
  }
}

// src/tools/thala/mint-mod.ts
async function mintMODWithThala(agent, mintType, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x6f986d146e4a90b828d8c12c14b6f4e003fdff11a8eecceceb63744363eaac01::psm_scripts::mint",
        typeArguments: [mintType],
        functionArguments: [amount]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Mint MOD failed");
      throw new Error("Mint MOD failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Mint MOD failed: ${error.message}`);
  }
}

// src/tools/thala/redeem-mod.ts
async function redeemMODWithThala(agent, mintType, amount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x6f986d146e4a90b828d8c12c14b6f4e003fdff11a8eecceceb63744363eaac01::psm_scripts::redeem",
        typeArguments: [mintType],
        functionArguments: [amount]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Redeem MOD failed");
      throw new Error("Redeem MOD failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Redeem MOD failed: ${error.message}`);
  }
}

// src/tools/thala/add-liquidity.ts
async function addLiquidityWithThala(agent, mintTypeX, mintTypeY, mintXAmount, mintYAmount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::weighted_pool_scripts::add_liquidity",
        typeArguments: [
          mintTypeX,
          mintTypeY,
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::weighted_pool::Weight_50",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::weighted_pool::Weight_50",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null"
        ],
        functionArguments: [mintXAmount, mintYAmount, 0, 0, 0, 0, 0, 0]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Add liquidity failed");
      throw new Error("Add liquidity failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Add liquidity failed: ${error.message}`);
  }
}

// src/tools/thala/remove-liquidity.ts
async function removeLiquidityWithThala(agent, mintTypeX, mintTypeY, lpAmount) {
  try {
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::weighted_pool_scripts::remove_liquidity",
        typeArguments: [
          mintTypeX,
          mintTypeY,
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::weighted_pool::Weight_50",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::weighted_pool::Weight_50",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null",
          "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null"
        ],
        functionArguments: [lpAmount, 0, 0, 0, 0]
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Remove liquidity failed");
      throw new Error("Remove liquidity failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Remove liquidity failed: ${error.message}`);
  }
}

// src/tools/thala/create-pool.ts
var NOTACOIN = "0x007730cd28ee1cdc9e999336cbc430f99e7c44397c0aa77516f6f23a78559bb5::coin_wrapper::Notacoin";
async function createPoolWithThala(agent, mintX, mintY, amountX, amountY, feeTier, amplificationFactor) {
  try {
    const isCoinX = mintX === "0x1::aptos_coin::AptosCoin" || mintX.includes("::");
    const isCoinY = mintY === "0x1::aptos_coin::AptosCoin" || mintY.includes("::");
    const functionArgs = [
      [isCoinX ? "0xa" : mintX, isCoinY ? "0xa" : mintY],
      [amountX, amountY],
      feeTier,
      amplificationFactor
    ];
    const typeArgs = [isCoinX ? mintX : NOTACOIN, isCoinY ? mintY : NOTACOIN, NOTACOIN, NOTACOIN, NOTACOIN, NOTACOIN];
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: {
        function: "0x007730cd28ee1cdc9e999336cbc430f99e7c44397c0aa77516f6f23a78559bb5::coin_wrapper::create_pool_stable",
        typeArguments: typeArgs,
        functionArguments: functionArgs
      }
    });
    const committedTransactionHash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: committedTransactionHash
    });
    if (!signedTransaction.success) {
      console.error(signedTransaction, "Create pool failed");
      throw new Error("Create pool failed");
    }
    return signedTransaction.hash;
  } catch (error) {
    throw new Error(`Create pool failed: ${error.message}`);
  }
}

// src/tools/merkletrade/place-limit-order.ts
var import_ts_sdk4 = require("@merkletrade/ts-sdk");

// src/tools/merkletrade/error.ts
var MerkleBaseError = class _MerkleBaseError extends Error {
  code;
  status;
  constructor(status, code, message) {
    super(message);
    this.code = code;
    this.status = status;
    Object.setPrototypeOf(this, _MerkleBaseError.prototype);
  }
};
var PositionNotFoundError = class extends MerkleBaseError {
  pair;
  isLong;
  constructor(pair, isLong, message) {
    super("error", "POSITION_NOT_FOUND", message);
    this.pair = pair;
    this.isLong = isLong;
  }
};
var FailedSendTransactionError = class extends MerkleBaseError {
  tx;
  constructor(message, tx) {
    super("error", "FAILED_SEND_TRANSACTION", message);
    this.tx = tx;
  }
};

// src/tools/merkletrade/place-limit-order.ts
async function placeLimitOrderWithMerkleTrade(agent, pair, isLong, sizeDelta, collateralDelta, price) {
  try {
    const merkle = new import_ts_sdk4.MerkleClient(await import_ts_sdk4.MerkleClientConfig.mainnet());
    const payload = merkle.payloads.placeLimitOrder({
      pair,
      userAddress: agent.account.getAddress(),
      sizeDelta: (0, import_ts_sdk4.fromNumber)(sizeDelta, 6),
      collateralDelta: (0, import_ts_sdk4.fromNumber)(collateralDelta, 6),
      price: (0, import_ts_sdk4.fromNumber)(price, 10),
      isLong,
      isIncrease: true
    });
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: payload
    });
    const txhash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: txhash
    });
    if (!signedTransaction.success) {
      throw new FailedSendTransactionError("Place limit order failed", signedTransaction);
    }
    return signedTransaction.hash;
  } catch (error) {
    if (error instanceof MerkleBaseError) {
      throw error;
    }
    throw new Error(`Place market order failed: ${error.message}`);
  }
}

// src/tools/merkletrade/place-market-order.ts
var import_ts_sdk5 = require("@merkletrade/ts-sdk");
async function placeMarketOrderWithMerkleTrade(agent, pair, isLong, sizeDelta, collateralDelta) {
  try {
    const merkle = new import_ts_sdk5.MerkleClient(await import_ts_sdk5.MerkleClientConfig.mainnet());
    const payload = merkle.payloads.placeMarketOrder({
      pair,
      userAddress: agent.account.getAddress(),
      sizeDelta: (0, import_ts_sdk5.fromNumber)(sizeDelta, 6),
      collateralDelta: (0, import_ts_sdk5.fromNumber)(collateralDelta, 6),
      isLong,
      isIncrease: true
    });
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: payload
    });
    const txhash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: txhash
    });
    if (!signedTransaction.success) {
      throw new FailedSendTransactionError("Place market order failed", signedTransaction);
    }
    return signedTransaction.hash;
  } catch (error) {
    if (error instanceof MerkleBaseError) {
      throw error;
    }
    throw new Error(`Place market order failed: ${error.message}`);
  }
}

// src/tools/merkletrade/close-position.ts
var import_ts_sdk6 = require("@merkletrade/ts-sdk");
async function closePositionWithMerkleTrade(agent, pair, isLong) {
  try {
    const merkle = new import_ts_sdk6.MerkleClient(await import_ts_sdk6.MerkleClientConfig.mainnet());
    const positions = await merkle.getPositions({
      address: agent.account.getAddress().toString()
    });
    const position = positions.find((position2) => position2.pairType === pair && position2.isLong === isLong);
    if (!position) {
      throw new PositionNotFoundError(pair, isLong, "Position not found");
    }
    const payload = merkle.payloads.placeMarketOrder({
      pair,
      userAddress: agent.account.getAddress(),
      sizeDelta: position.size,
      collateralDelta: position.collateral,
      isLong: position.isLong,
      isIncrease: false
    });
    const transaction = await agent.aptos.transaction.build.simple({
      sender: agent.account.getAddress(),
      data: payload
    });
    const txhash = await agent.account.sendTransaction(transaction);
    const signedTransaction = await agent.aptos.waitForTransaction({
      transactionHash: txhash
    });
    if (!signedTransaction.success) {
      throw new FailedSendTransactionError("Close position failed", signedTransaction);
    }
    return signedTransaction.hash;
  } catch (error) {
    if (error instanceof MerkleBaseError) {
      throw error;
    }
    throw new Error(`Close position failed: ${error.message}`);
  }
}

// src/tools/merkletrade/get-positions.ts
var import_ts_sdk7 = require("@merkletrade/ts-sdk");
async function getPositionsWithMerkleTrade(agent) {
  try {
    const merkle = new import_ts_sdk7.MerkleClient(await import_ts_sdk7.MerkleClientConfig.mainnet());
    const positions = await merkle.getPositions({
      address: agent.account.getAddress().toString()
    });
    const humanReadablePositions = positions.map((position) => ({
      ...position,
      size: (0, import_ts_sdk7.toNumber)(position.size, 6),
      collateral: (0, import_ts_sdk7.toNumber)(position.collateral, 6),
      avgPrice: (0, import_ts_sdk7.toNumber)(position.avgPrice, 10),
      stopLossTriggerPrice: (0, import_ts_sdk7.toNumber)(position.stopLossTriggerPrice, 10),
      takeProfitTriggerPrice: (0, import_ts_sdk7.toNumber)(position.takeProfitTriggerPrice, 10)
    }));
    return humanReadablePositions;
  } catch (error) {
    throw new Error(`Get positions failed: ${error.message}`);
  }
}

// src/utils/get-pool-address-by-token-name.ts
var tokensList = [
  {
    name: "USDt",
    poolAddress: "0xac00e90cdadec06d81e0d5ce7a3e93d63d563e982dea0ca15bad2b067f42d2be",
    decimals: 6,
    tokenAddress: "0x357b0b74bc833e95a115ad22604854d6b0fca151cecd94111770e5d6ffc9dc2b"
  },
  {
    name: "zUSDT",
    poolAddress: "0x447b3b516546f28e8c4f6825a6287b09161659e7c500c599c29c28a8492844b8",
    decimals: 6,
    tokenAddress: "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT"
  },
  {
    name: "zUSDC",
    poolAddress: "0xa9c51ca3bcd93978d0c4aada7c4cf47c0791caced3cdc4e15f2c8e0797d1f93c",
    decimals: 6,
    tokenAddress: "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDC"
  },
  {
    name: "APT",
    poolAddress: "0x761a97787fa8b3ae0cef91ebc2d96e56cc539df5bc88dadabee98ae00363a831",
    decimals: 8,
    tokenAddress: "0x1::aptos_coin::AptosCoin"
  },
  {
    name: "sthAPT",
    poolAddress: "0xed6bf9fe7e3f42c6831ffac91824a545c4b8bfcb40a59b3f4ccfe203cafb7f42",
    decimals: 8,
    tokenAddress: "0xfaf4e633ae9eb31366c9ca24214231760926576c7b625313b3688b5e900731f6::staking::StakedThalaAPT"
  },
  {
    name: "MOD",
    poolAddress: "0xef2ae89796725d0eb363326ecb7df159feb949f6d1f400f76deeeebccbac00f1",
    decimals: 8,
    tokenAddress: "0x6f986d146e4a90b828d8c12c14b6f4e003fdff11a8eecceceb63744363eaac01::mod_coin::MOD"
  },
  {
    name: "THL",
    poolAddress: "0x127ea5b4c450be695e488da1c3bc013e2e93d8cf00270ef90385189844bc9755",
    decimals: 8,
    tokenAddress: "0x7fd500c11216f0fe3095d0c4b8aa4d64a4e2e04f83758462f2b127255643615::thl_coin::THL"
  },
  {
    name: "wUSDC",
    poolAddress: "0xa76ebfb432982c864783fdb33cdf5a9edb18ac1b950deb8037f5cf8c984da3d2",
    decimals: 6,
    tokenAddress: "0x5e156f1207d0ebfa19a9eeff00d62a282278fb8719f4fab3a586a0a2c0fffbea::coin::T"
  },
  {
    name: "zWETH",
    poolAddress: "0x548cf587bd918a0005b3372a1d23e64b18ace3c61962f087a21eac52cf228504",
    decimals: 6,
    tokenAddress: "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::WETH"
  },
  {
    name: "wWETH",
    poolAddress: "0x114ee519ffa1e8697784bd1a350822cb37601a1476289051b8295165597a4538",
    decimals: 6,
    tokenAddress: "0xcc8a89c8dce9693d354449f1f73e60e14e347417854f029db5bc8e7454008abb::coin::T"
  },
  {
    name: "CAKE",
    poolAddress: "0x41b039e5518b1a3786ee798d895e0ddf3141fbbc20009284323fa51ea279c819",
    decimals: 8,
    tokenAddress: "0x159df6b7689437016108a019fd5bef736bac692b6d4a1f10c941f6fbb9a74ca6::oft::CakeOFT"
  },
  {
    name: "stAPT",
    poolAddress: "0xc3c9cc885a52004e0490f6a8291b3bc5854f0e42d931fb124736bd189c9f0f45",
    decimals: 8,
    tokenAddress: "0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::stapt_token::StakedApt"
  },
  {
    name: "aBTC",
    poolAddress: "0xacb7262b33a147b47b950a3a26d7699e1a58bcaa475ef636cb0fea53fa0eb872",
    decimals: 10,
    tokenAddress: "0x4e1854f6d332c9525e258fb6e66f84b6af8aba687bbcb832a24768c4e175feec::abtc::ABTC"
  },
  {
    name: "STONE",
    poolAddress: "0x075c39f18c7bc00ac0f81a0f9ab7e319e23790d7d8c3df968d84a23699584bd9",
    decimals: 8,
    tokenAddress: "0x543c5660aa4d496687e2068c11765f04607c4f4b639a83233a9333604fb8ce59::stakestone_ether::StakeStoneEther"
  },
  {
    name: "truAPT",
    poolAddress: "0x7bd5be03df0fb3841fed337b8e7a353818b917cce6db28b807b691002a122d73",
    decimals: 8,
    tokenAddress: "0xaef6a8c3182e076db72d64324617114cacf9a52f28325edc10b483f7f05da0e7"
  },
  {
    name: "sBTC",
    poolAddress: "0x754114c656e26498a8c0b20fa24af663fed5e4b24acb471c103daea0f7006b40",
    decimals: 8,
    tokenAddress: "0x5dee1d4b13fae338a1e1780f9ad2709a010e824388efd169171a26e3ea9029bb::stakestone_bitcoin::StakeStoneBitcoin"
  }
];
var getTokenByTokenName = (name) => {
  const token = tokensList.find(
    (token2) => token2.name.toLowerCase() === name.toLowerCase() || token2.name.toLowerCase().includes(name.toLowerCase())
  );
  return token;
};
var getTokenByTokenAddress = (address) => {
  const token = tokensList.find((token2) => token2.tokenAddress.toLowerCase() === address.toLowerCase());
  return token;
};

// src/agent.ts
var AgentRuntime = class {
  account;
  aptos;
  config;
  constructor(account, aptos, config) {
    this.account = account;
    this.aptos = aptos;
    this.config = config ? config : {};
  }
  async getPythData() {
    const connection = new import_pyth_aptos_js.AptosPriceServiceConnection("https://hermes.pyth.network");
    return await connection.getPriceFeedsUpdateData(priceFeed);
  }
  getBalance(mint) {
    return getBalance(this, mint);
  }
  getTokenDetails(token) {
    return getTokenDetails(token);
  }
  getTokenByTokenName(name) {
    return getTokenByTokenName(name);
  }
  getTokenPrice(query) {
    return getTokenPrice(query);
  }
  transferTokens(to, amount, mint) {
    return transferTokens(this, to, amount, mint);
  }
  getTransaction(hash) {
    return getTransaction(this, hash);
  }
  burnToken(amount, mint) {
    return burnToken(this, amount, mint);
  }
  createToken(name, symbol, iconURI, projectURI) {
    return createToken(this, name, symbol, iconURI, projectURI);
  }
  mintToken(to, mint, amount) {
    return mintToken(this, to, mint, amount);
  }
  stakeTokensWithAmnis(to, amount) {
    return stakeTokens(this, to, amount);
  }
  withdrawStakeFromAmnis(to, amount) {
    return unstakeTokens(this, to, amount);
  }
  transferNFT(to, mint) {
    return transferNFT(this, to, mint);
  }
  burnNFT(mint) {
    return burnNFT(this, mint);
  }
  lendToken(amount, mint, positionId, newPosition, fungibleAsset) {
    return lendToken(this, amount, mint, positionId, newPosition, fungibleAsset);
  }
  borrowToken(amount, mint, positionId, fungibleAsset) {
    return borrowToken(this, amount, mint, positionId, fungibleAsset);
  }
  withdrawToken(amount, mint, positionId, fungibleAsset) {
    return withdrawToken(this, amount, mint, positionId, fungibleAsset);
  }
  repayToken(amount, mint, positionId, fungibleAsset) {
    return repayToken(this, amount, mint, positionId, fungibleAsset);
  }
  getUserPosition(userAddress, positionId) {
    return getUserPosition(this, userAddress, positionId);
  }
  getUserAllPositions(userAddress) {
    return getUserAllPositions(this, userAddress);
  }
  getPoolDetails(mint) {
    return getPoolDetails(this, mint);
  }
  addLiquidity(mintX, mintY, mintXAmount, mintYAmount) {
    return addLiquidity(this, mintX, mintY, mintXAmount, mintYAmount);
  }
  removeLiquidity(mintX, mintY, lpAmount, minMintX = 0, minMintY = 0) {
    return removeLiquidity(this, mintX, mintY, lpAmount, minMintX, minMintY);
  }
  swap(mintX, mintY, swapAmount, minCoinOut) {
    return swap(this, mintX, mintY, swapAmount, minCoinOut);
  }
  createPool(mintX, mintY) {
    return createPool(this, mintX, mintY);
  }
  claimReward(rewardCoinType) {
    return claimReward(this, rewardCoinType);
  }
  // Aries
  createAriesProfile() {
    return createAriesProfile(this);
  }
  lendAriesToken(mintType, amount) {
    return lendAriesToken(this, mintType, amount);
  }
  borrowAriesToken(mintType, amount) {
    return borrowAriesToken(this, mintType, amount);
  }
  withdrawAriesToken(mintType, amount) {
    return withdrawAriesToken(this, mintType, amount);
  }
  repayAriesToken(mintType, amount) {
    return repayAriesToken(this, mintType, amount);
  }
  // Thala
  stakeTokensWithThala(amount) {
    return stakeTokenWithThala(this, amount);
  }
  unstakeTokensWithThala(amount) {
    return unstakeAPTWithThala(this, amount);
  }
  mintMODWithThala(mintType, amount) {
    return mintMODWithThala(this, mintType, amount);
  }
  redeemMODWithThala(mintType, amount) {
    return redeemMODWithThala(this, mintType, amount);
  }
  addLiquidityWithThala(mintX, mintY, mintXAmount, mintYAmount) {
    return addLiquidityWithThala(this, mintX, mintY, mintXAmount, mintYAmount);
  }
  removeLiquidityWithThala(mintX, mintY, lpAmount) {
    return removeLiquidityWithThala(this, mintX, mintY, lpAmount);
  }
  createPoolWithThala(mintX, mintY, amountX, amountY, feeTier, amplificationFactor) {
    return createPoolWithThala(this, mintX, mintY, amountX, amountY, feeTier, amplificationFactor);
  }
  // panora
  swapWithPanora(fromToken, toToken, swapAmount, toWalletAddress) {
    return swapWithPanora(this, fromToken, toToken, swapAmount, toWalletAddress);
  }
  // openai
  createImageWithOpenAI(prompt, size, n) {
    return createImage(this, prompt, size, n);
  }
  // Echo
  stakeTokenWithEcho(amount) {
    return stakeTokenWithEcho(this, amount);
  }
  unstakeTokenWithEcho(amount) {
    return unstakeTokenWithEcho(this, amount);
  }
  // Echelon
  lendTokenWithEchelon(mintType, amount, poolAddress, fungibleAsset) {
    return lendTokenWithEchelon(this, mintType, amount, poolAddress, fungibleAsset);
  }
  withdrawTokenWithEchelon(mintType, amount, poolAddress, fungibleAsset) {
    return withdrawTokenWithEchelon(this, mintType, amount, poolAddress, fungibleAsset);
  }
  repayTokenWithEchelon(mintType, amount, poolAddress, fungibleAsset) {
    return repayTokenWithEchelon(this, mintType, amount, poolAddress, fungibleAsset);
  }
  borrowTokenWithEchelon(mintType, amount, poolAddress, fungibleAsset) {
    return borrowTokenWithEchelon(this, mintType, amount, poolAddress, fungibleAsset);
  }
  // MerkleTrade
  placeMarketOrderWithMerkleTrade(pair, isLong, sizeDelta, collateralDelta) {
    return placeMarketOrderWithMerkleTrade(this, pair, isLong, sizeDelta, collateralDelta);
  }
  placeLimitOrderWithMerkleTrade(pair, isLong, sizeDelta, collateralDelta, price) {
    return placeLimitOrderWithMerkleTrade(this, pair, isLong, sizeDelta, collateralDelta, price);
  }
  closePositionWithMerkleTrade(pair, isLong) {
    return closePositionWithMerkleTrade(this, pair, isLong);
  }
  getPositionsWithMerkleTrade() {
    return getPositionsWithMerkleTrade(this);
  }
};

// src/langchain/account/address.ts
var import_tools2 = require("langchain/tools");
var AptosAccountAddressTool = class extends import_tools2.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aptos_get_wallet_address";
  description = "Get the wallet address of the agent";
  async _call(_input) {
    return this.agent.account.getAddress().toString();
  }
};

// src/langchain/amnis/stake.ts
var import_ts_sdk8 = require("@aptos-labs/ts-sdk");
var import_tools3 = require("langchain/tools");
var AmnisStakeTool = class extends import_tools3.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "amnis_stake";
  description = `this tool can be used to stake APT (Aptos) to amnis validator and receive its liquid staking token stAPT (staked APT)

	keep recipient blank if user themselves wants to receive stAPT and not send to anybody else

  Inputs ( input is a JSON string ) (required):
  amount: number, eg 1 or 0.01 (required)
  recipient: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (optional)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const recipient = import_ts_sdk8.AccountAddress.from(parsedInput.recipient) || this.agent.account.getAddress();
      const stakeTransactionHash = await this.agent.stakeTokensWithAmnis(
        recipient,
        (0, import_ts_sdk8.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, 8)
      );
      return JSON.stringify({
        status: "success",
        stakeTransactionHash,
        token: {
          name: "stAPT",
          decimals: 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/amnis/withdraw-stake.ts
var import_ts_sdk9 = require("@aptos-labs/ts-sdk");
var import_tools4 = require("langchain/tools");
var AmnisWithdrawStakeTool = class extends import_tools4.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "amnis_withdraw_stake";
  description = `this tool can be used to withdraw staked APT (Aptos) from amnis validator and receive back APT

	keep recipient blank if user themselves wants to receive APT and not send to anybody else

  Inputs ( input is a JSON string ):
  amount: number, eg 1 or 0.01 (required)
  recipient: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (optional)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const recipient = import_ts_sdk9.AccountAddress.from(parsedInput.recipient) || this.agent.account.getAddress();
      const withdrawStakeTransactionHash = await this.agent.withdrawStakeFromAmnis(
        recipient,
        (0, import_ts_sdk9.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, 8)
      );
      return JSON.stringify({
        status: "success",
        withdrawStakeTransactionHash,
        token: {
          name: "APT",
          decimals: 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aptos/balance.ts
var import_tools5 = require("langchain/tools");
var AptosBalanceTool = class extends import_tools5.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aptos_balance";
  description = `Get the balance of a Aptos account.

  If you want to get the balance of your wallet, you don't need to provide the mint.
  If no mint is provided, the balance will be in APT.
  if you want to get balance of a fungible asset, you need to provide the asset address as mint

  Inputs ( input is a JSON string ):
  mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "
  0x357b0b74bc833e95a115ad22604854d6b0fca151cecd94111770e5d6ffc9dc2b" (optional)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mint = parsedInput.mint || void 0;
      const mintDetails = this.agent.getTokenDetails(mint);
      const balance = await this.agent.getBalance(mint);
      return JSON.stringify({
        status: "success",
        balance,
        token: {
          name: mintDetails.name || "APT",
          decimals: mintDetails.decimals || 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aptos/get-token-details.ts
var import_tools6 = require("langchain/tools");
var AptosGetTokenDetailTool = class extends import_tools6.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aptos_token_details";
  description = `Get the detail of any aptos tokens

  details also include decimals which you can use to make onchain values readable to a human user

  Inputs ( input is a JSON string ):
  token: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (optional)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mint = parsedInput.token || "";
      const tokenData = await this.agent.getTokenDetails(mint);
      return JSON.stringify({
        status: "success",
        tokenData
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aptos/transfer-token.ts
var import_ts_sdk10 = require("@aptos-labs/ts-sdk");
var import_tools7 = require("langchain/tools");
var AptosTransferTokenTool = class extends import_tools7.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aptos_transfer_token";
  description = `this tool can be used to transfer APT, any token or fungible asset to a recipient

  if you want to transfer APT, mint will be "0x1::aptos_coin::AptosCoin"
  if you want to transfer token other than APT, you need to provide the mint of that specific token
  if you want to transfer fungible asset, add fungible asset address as mint

  keep to blank if user themselves wants to receive the token and not send to anybody else

  Inputs ( input is a JSON string ):
  to: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (optional)
  amount: number, eg 1 or 0.01 (required)
  mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" 
  or "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const recipient = import_ts_sdk10.AccountAddress.from(parsedInput.to) || this.agent.account.getAddress();
      const transferTokenTransactionHash = await this.agent.transferTokens(
        recipient,
        (0, import_ts_sdk10.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 6),
        parsedInput.mint
      );
      return JSON.stringify({
        status: "success",
        transferTokenTransactionHash,
        token: {
          name: mintDetail.name,
          decimals: mintDetail.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aptos/burn-token.ts
var import_ts_sdk11 = require("@aptos-labs/ts-sdk");
var import_tools8 = require("langchain/tools");
var AptosBurnTokenTool = class extends import_tools8.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aptos_burn_token";
  description = `this tool can be used to burn a fungible asset

  Inputs ( input is a JSON string ):
  amount: number, eg 1 or 0.01 (required) 
  mint: string, "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const burnTransactionHash = await this.agent.burnToken(
        (0, import_ts_sdk11.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8),
        parsedInput.mint
      );
      return JSON.stringify({
        status: "success",
        burnTransactionHash,
        token: {
          name: mintDetail.name,
          decimals: mintDetail.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aptos/mint-token.ts
var import_ts_sdk12 = require("@aptos-labs/ts-sdk");
var import_tools9 = require("langchain/tools");
var AptosMintTokenTool = class extends import_tools9.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aptos_mint_token";
  description = `this tool can be used to create fungible asset to a recipient

if the recipient wants to receive the token and not send to anybody else, keep to blank

  Inputs ( input is a JSON string ):
  to: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)
  amount: number, eg 1 or 0.01 (required)
  mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const recipient = import_ts_sdk12.AccountAddress.from(parsedInput.to) || this.agent.account.getAddress();
      const mintTokenTransactionHash = await this.agent.mintToken(recipient, parsedInput.mint, parsedInput.amount);
      return JSON.stringify({
        status: "success",
        mintTokenTransactionHash,
        token: {
          name: mintDetail.name || "APT",
          decimals: 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aptos/create-token.ts
var import_tools10 = require("langchain/tools");
var AptosCreateTokenTool = class extends import_tools10.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aptos_create_token";
  description = `this tool can be used to create fungible asset to a recipient

  Inputs ( input is a JSON string ):
  name: string, eg "USDT" (required)
  symbol: string, eg "USDT" (required)
  iconURI: string, eg "https://example.com/icon.png" (required)
  projectURI: string, eg "https://example.com/project" (required)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const createTokenTransactionHash = await this.agent.createToken(
        parsedInput.name,
        parsedInput.symbol,
        parsedInput.iconURI,
        parsedInput.projectURI
      );
      return JSON.stringify({
        status: "success",
        createTokenTransactionHash,
        token: {
          name: parsedInput.name,
          decimals: 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aptos/get-transaction.ts
var import_tools11 = require("langchain/tools");
var AptosTransactionTool = class extends import_tools11.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aptos_get_transaction";
  description = `Fetches a transaction from aptos blockchain

  Inputs ( input is a JSON string ):
  transactionHash: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const aptosTransaction = await this.agent.getTransaction(parsedInput.transactionHash);
      return JSON.stringify({
        status: "success",
        aptosTransaction
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aptos/get-token-price.ts
var import_tools12 = require("langchain/tools");
var AptosGetTokenPriceTool = class extends import_tools12.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aptos_token_price";
  description = `Get the live price of any aptos tokens in USD.
	do not do any decimals conversion here, the price is already in USD

  details also include decimals which you can use to make onchain values readable to a human user

  Inputs ( input is a JSON string - this is IMPORTANT):
  token: string, eg usdt, btc etc.`;
  async _call(input) {
    console.log("input", input);
    try {
      const parsedInput = parseJson(input);
      const token = parsedInput.token || input || "usdt";
      const tokenData = await this.agent.getTokenPrice(token);
      return JSON.stringify({
        status: "success",
        tokenData
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aries/create-profile.ts
var import_tools13 = require("langchain/tools");
var AriesCreateProfileTool = class extends import_tools13.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aries_create_profile";
  description = `this tool can be used to create a profile in Aries
    `;
  async _call() {
    try {
      const createProfileTransactionHash = await this.agent.createAriesProfile();
      return JSON.stringify({
        status: "success",
        createProfileTransactionHash
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aries/lend-token.ts
var import_ts_sdk13 = require("@aptos-labs/ts-sdk");
var import_tools14 = require("langchain/tools");

// src/utils/parse-json.ts
var parseJson = (input) => {
  try {
    const forbiddenWords = ["null", "undefined", "{}"];
    if (input in forbiddenWords) throw new Error();
    const parsedInput = JSON.parse(input);
    return parsedInput;
  } catch (e) {
    return {};
  }
};

// src/langchain/aries/lend-token.ts
var AriesLendTool = class extends import_tools14.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aries_lend";
  description = `this tool can be used to lend tokens in Aries

    if you want to lend APT, mintType will be "0x1::aptos_coin::AptosCoin"

    Inputs ( input is a JSON string ):
    mintType: string, eg "0x1::aptos_coin::AptosCoin" (required)
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const lendTokenTransactionHash = await this.agent.lendAriesToken(
        parsedInput.mintType,
        (0, import_ts_sdk13.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8)
      );
      return JSON.stringify({
        status: "success",
        lendTokenTransactionHash,
        token: {
          name: mintDetail.name,
          decimals: mintDetail.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aries/withdraw-token.ts
var import_ts_sdk14 = require("@aptos-labs/ts-sdk");
var import_tools15 = require("langchain/tools");
var AriesWithdrawTool = class extends import_tools15.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aries_withdraw";
  description = `this tool can be used to withdraw tokens from Aries

    if you want to withdraw APT, mintType will be "0x1::aptos_coin::AptosCoin"

    Inputs ( input is a JSON string ):
    mintType: string, eg "0x1::aptos_coin::AptosCoin" (required)
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const withdrawTokenTransactionHash = await this.agent.withdrawAriesToken(
        parsedInput.mintType,
        (0, import_ts_sdk14.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8)
      );
      return JSON.stringify({
        status: "success",
        withdrawTokenTransactionHash,
        token: {
          name: mintDetail.name,
          decimals: mintDetail.decimals || 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aries/borrow-token.ts
var import_ts_sdk15 = require("@aptos-labs/ts-sdk");
var import_tools16 = require("langchain/tools");
var AriesBorrowTool = class extends import_tools16.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aries_borrow";
  description = `this tool can be used to borrow tokens from Aries

    if you want to borrow APT, mintType will be "0x1::aptos_coin::AptosCoin"

    Inputs ( input is a JSON string ):
    mintType: string, eg "0x1::aptos_coin::AptosCoin" (required)
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const borrowTokenTransactionHash = await this.agent.borrowAriesToken(
        parsedInput.mintType,
        (0, import_ts_sdk15.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8)
      );
      return JSON.stringify({
        status: "success",
        borrowTokenTransactionHash,
        token: {
          name: mintDetail.name,
          decimals: mintDetail.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/aries/repay-token.ts
var import_ts_sdk16 = require("@aptos-labs/ts-sdk");
var import_tools17 = require("langchain/tools");
var AriesRepayTool = class extends import_tools17.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "aries_repay";
  description = `this tool can be used to repay tokens in Aries

    if you want to repay APT, mintType will be "0x1::aptos_coin::AptosCoin"

    Inputs ( input is a JSON string ):
    mintType: string, eg "0x1::aptos_coin::AptosCoin" (required)
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const repayTokenTransactionHash = await this.agent.repayAriesToken(
        parsedInput.mintType,
        (0, import_ts_sdk16.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8)
      );
      return JSON.stringify({
        status: "success",
        repayTokenTransactionHash,
        token: {
          name: mintDetail.name,
          decimals: mintDetail.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/joule/lend-token.ts
var import_ts_sdk17 = require("@aptos-labs/ts-sdk");
var import_tools18 = require("langchain/tools");
var JouleLendTokenTool = class extends import_tools18.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "joule_lend_token";
  description = `this tool can be used to lend APT, tokens or fungible asset to a position

  if you want to lend APT, mint will be "0x1::aptos_coin::AptosCoin"
  if you want to lend token other than APT, you need to provide the mint of that specific token
  if you want to lend fungible asset, add "0x1::aptos_coin::AptosCoin" as mint and provide fungible asset address

  if positionId is not provided, the positionId will be 1234 and newPosition should be true
  
  Inputs ( input is a JSON string ):
  amount: number, eg 1 or 0.01 (required)
  mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
  positionId: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)
  newPosition: boolean, (required)  
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const fungibleAsset = mintDetail.faAddress.toLowerCase() === parsedInput.mint.toLowerCase();
      const lendTokenTransactionHash = await this.agent.lendToken(
        (0, import_ts_sdk17.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8),
        parsedInput.mint,
        parsedInput.positionId,
        parsedInput.newPosition,
        fungibleAsset
      );
      return JSON.stringify({
        status: "success",
        lendTokenTransactionHash,
        token: {
          name: mintDetail.name,
          decimals: mintDetail.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/joule/borrow-token.ts
var import_ts_sdk18 = require("@aptos-labs/ts-sdk");
var import_tools19 = require("langchain/tools");
var JouleBorrowTokenTool = class extends import_tools19.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "joule_borrow_token";
  description = `this tool can be used to borrow APT, tokens or fungible asset from a position

  if you want to borrow APT, mint will be "0x1::aptos_coin::AptosCoin"
  if you want to borrow token other than APT, you need to provide the mint of that specific token
  if you want to borrow fungible asset, add "0x1::aptos_coin::AptosCoin" as mint and provide fungible asset address
  
  Inputs ( input is a JSON string ):
  amount: number, eg 1 or 0.01 (required)
  mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
  positionId: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const fungibleAsset = mintDetail.faAddress.toLowerCase() === parsedInput.mint.toLowerCase();
      const borrowTokenTransactionHash = await this.agent.borrowToken(
        (0, import_ts_sdk18.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8),
        parsedInput.mint,
        parsedInput.positionId,
        fungibleAsset
      );
      return JSON.stringify({
        status: "success",
        borrowTokenTransactionHash,
        token: {
          name: mintDetail.name || "APT",
          decimals: mintDetail.decimals || 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/joule/withdraw-token.ts
var import_ts_sdk19 = require("@aptos-labs/ts-sdk");
var import_tools20 = require("langchain/tools");
var JouleWithdrawTokenTool = class extends import_tools20.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "joule_withdraw_token";
  description = `this tool can be used to withdraw APT, tokens or fungible asset from a position

  if you want to withdraw APT, add "0x1::aptos_coin::AptosCoin" as mint
  if you want to withdraw token other than APT, you need to provide the mint of that specific token
  if you want to withdraw fungible asset, add "0x1::aptos_coin::AptosCoin" as mint and provide fungible asset address
  
  Inputs ( input is a JSON string ):

  amount: number, eg 1 or 0.01 (required)
  mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
  positionId: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const fungibleAsset = mintDetail.faAddress.toLowerCase() === parsedInput.mint.toLowerCase();
      const withdrawTokenTransactionHash = await this.agent.withdrawToken(
        (0, import_ts_sdk19.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8),
        parsedInput.mint,
        parsedInput.positionId,
        fungibleAsset
      );
      return JSON.stringify({
        status: "success",
        withdrawTokenTransactionHash,
        token: {
          name: mintDetail.name,
          decimals: mintDetail.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/joule/repay-token.ts
var import_ts_sdk20 = require("@aptos-labs/ts-sdk");
var import_tools21 = require("langchain/tools");
var JouleRepayTokenTool = class extends import_tools21.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "joule_repay_token";
  description = `this tool can be used to repay APT, tokens or fungible asset from a position

  if you want to repay APT, mint will be "0x1::aptos_coin::AptosCoin"
  if you want to repay token other than APT, you need to provide the mint of that specific token
  if you want to repay fungible asset, add "0x1::aptos_coin::AptosCoin" as mint and provide fungible asset address
  
  Inputs ( input is a JSON string ):
  amount: number, eg 1 or 0.01 (required)
  mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
  positionId: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)
  fungibleAssetAddress: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (optional)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintDetail = await this.agent.getTokenDetails(parsedInput.mint);
      const repayTokenTransactionHash = await this.agent.repayToken(
        (0, import_ts_sdk20.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8),
        parsedInput.mint,
        parsedInput.positionId,
        parsedInput.fungibleAssetAddress
      );
      return JSON.stringify({
        status: "success",
        repayTokenTransactionHash,
        token: {
          name: mintDetail.name,
          decimals: mintDetail.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/joule/get-pool-details.ts
var import_tools22 = require("langchain/tools");
var JouleGetPoolDetails = class extends import_tools22.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "joule_get_pool_details";
  description = `the tool can be used to get a token / fungible asset pool details

  Inputs ( input is a JSON string ):
     mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)

  Example: '{"mint": "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT"}'
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const pool = await this.agent.getPoolDetails(parsedInput.mint);
      return JSON.stringify({
        status: "success",
        pool
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/joule/get-user-position.ts
var import_ts_sdk21 = require("@aptos-labs/ts-sdk");
var import_tools23 = require("langchain/tools");
var JouleGetUserPosition = class extends import_tools23.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "joule_get_user_position";
  description = `the tool can be used to get details about a user's position

	keep userAddress blank if user wants to get their own position or didn't provide any other user's address

	ask user to provide positionId from the list of positions they have if they want to get details about a specific position.
	do not fill random positionId if the user didn't provide any positionId

  Inputs ( input is a JSON string ):
     userAddress: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (optional)
     positionId: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (required)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const userAddress = import_ts_sdk21.AccountAddress.from(parsedInput.userAddress) || this.agent.account.getAddress();
      const jouleUserPosition = await this.agent.getUserPosition(userAddress, parsedInput.positionId);
      return JSON.stringify({
        status: "success",
        jouleUserPosition
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/joule/get-user-all-positions.ts
var import_ts_sdk22 = require("@aptos-labs/ts-sdk");
var import_tools24 = require("langchain/tools");
var JouleGetUserAllPositions = class extends import_tools24.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "joule_get_user_all_positions";
  description = `the tool can be used to get details about a user's all positions

	keep userAddress blank if user wants to get their own position or didn't provide any other user's address

  Inputs ( input is a JSON string ):
     userAddress: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (optional)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const userAddress = import_ts_sdk22.AccountAddress.from(parsedInput.userAddress) || this.agent.account.getAddress();
      const jouleUserAllPositions = await this.agent.getUserAllPositions(userAddress);
      return JSON.stringify({
        status: "success",
        jouleUserAllPositions,
        tokens: tokensList.map((token) => {
          return {
            name: token.name,
            decimals: token.decimals,
            tokenAddress: token.tokenAddress
          };
        })
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/joule/claim-reward.ts
var import_tools25 = require("langchain/tools");
var JouleClaimRewardTool = class extends import_tools25.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "joule_claim_rewards";
  description = `this tool can be used to claim rewards from Joule pools

    Supports claiming both APT incentives and amAPT incentives.

    User can only claim rewards for coin - 
    usdt - 0x357b0b74bc833e95a115ad22604854d6b0fca151cecd94111770e5d6ffc9dc2b
    usdc - 0xbae207659db88bea0cbead6da0ed00aac12edcdda169e591cd41c94180b46f3b
    weth - 0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa
    stapt - 0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::stapt_token::StakedApt

    Inputs (input is a JSON string):
    rewardCoinType: string, eg "0x1::aptos_coin::AptosCoin" (required)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const claimRewardsTransactionHash = await this.agent.claimReward(parsedInput.rewardCoinType);
      const tokenDetails = await this.agent.getTokenDetails(parsedInput.rewardCoinType);
      return JSON.stringify({
        status: "success",
        claimRewardsTransactionHash,
        reward: {
          coinType: parsedInput.rewardCoinType,
          name: tokenDetails.name,
          type: parsedInput.rewardName,
          decimals: tokenDetails.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/liquidswap/swap.ts
var import_ts_sdk23 = require("@aptos-labs/ts-sdk");
var import_tools26 = require("langchain/tools");
var LiquidSwapSwapTool = class extends import_tools26.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "liquidswap_swap";
  description = `this tool can be used to swap tokens in liquidswap

want to swap APT and one of the token, mint is 0x1::aptos_coin::AptosCoin
one of the token is USDT, use 0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT

if user added mintX or mintY as asset name, and you don't have the address of the asset, use these token names:
usdt,zusdt,zusdc,apt,sthapt,mod,thl,wusdc,zweth,wweth,cake,stapt,abtc,stone,truapt,sbtc
or whatever name the user has provided, you can use the token name to get the address of the token 

cant swap any fungible tokens. only coin standard swap allowed. if user trying to swap fungible token, ask it to swap via panora.

coin standard format : string::string::string

Inputs (input is a JSON string):
mintX: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
mintY: string, eg (same as mintX) (required)
swapAmount: number, eg 1 or 0.01 (required)
minCoinOut: number, eg 1 or 0.01 (optional)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      let mintX = parsedInput.mintX;
      const tokenX = getTokenByTokenName(mintX);
      if (tokenX) {
        mintX = tokenX.tokenAddress;
      }
      let mintY = parsedInput.mintY;
      const tokenY = getTokenByTokenName(mintY);
      if (tokenY) {
        mintY = tokenY.tokenAddress;
      }
      const mintXDetail = await this.agent.getTokenDetails(mintX);
      const mintYDetail = await this.agent.getTokenDetails(mintY);
      const swapTransactionHash = await this.agent.swap(
        mintX,
        mintY,
        (0, import_ts_sdk23.convertAmountFromHumanReadableToOnChain)(parsedInput.swapAmount, mintXDetail.decimals),
        (0, import_ts_sdk23.convertAmountFromHumanReadableToOnChain)(parsedInput.minCoinOut, mintXDetail.decimals) || 0
      );
      return JSON.stringify({
        status: "success",
        swapTransactionHash,
        token: [
          {
            mintX: mintXDetail.name,
            decimals: mintXDetail.decimals
          },
          {
            mintY: mintYDetail.name,
            decimals: mintYDetail.decimals
          }
        ]
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/liquidswap/create-pool.ts
var import_tools27 = require("langchain/tools");

// src/utils/parse-fungible-asset-to-wrapped-asset.ts
var parseFungibleAssetAddressToWrappedAssetAddress = (assetAddress) => {
  if (assetAddress === "0x357b0b74bc833e95a115ad22604854d6b0fca151cecd94111770e5d6ffc9dc2b") {
    return "0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3::fa_to_coin_wrapper::WrappedUSDT";
  }
  return assetAddress;
};

// src/langchain/liquidswap/create-pool.ts
var LiquidSwapCreatePoolTool = class extends import_tools27.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "liquidswap_create_pool";
  description = `this tool can be used to create a new pool in liquidswap

    if you want to create a pool with APT and one of the token, mint will be "0x1::aptos_coin::AptosCoin"

	if user added mintX or mintY as asset name, and you don't have the address of the asset, you can use the following token names:
	['usdt', 'zusdt', 'zusdc', 'apt', 'sthapt', 'mod', 'thl', 'wusdc' , 'zweth', 'wweth', 'cake', 'stapt', 'abtc', 'stone' , 'truapt', 'sbtc']
	or whatever name the user has provided, you can use the token name to get the address of the token 

    Inputs ( input is a JSON string ):
    mintX: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
    mintY: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      let mintX = parsedInput.mintX;
      const tokenX = getTokenByTokenName(mintX);
      if (tokenX) {
        mintX = tokenX.tokenAddress;
      }
      let mintY = parsedInput.mintY;
      const tokenY = getTokenByTokenName(mintY);
      if (tokenY) {
        mintY = tokenY.tokenAddress;
      }
      const mintXDetail = await this.agent.getTokenDetails(mintX);
      const mintYDetail = await this.agent.getTokenDetails(mintY);
      const createPoolTransactionHash = await this.agent.createPool(
        parseFungibleAssetAddressToWrappedAssetAddress(mintX),
        parseFungibleAssetAddressToWrappedAssetAddress(mintY)
      );
      return JSON.stringify({
        status: "success",
        createPoolTransactionHash,
        token: [
          {
            mintX: mintXDetail.name,
            decimals: mintXDetail.decimals
          },
          {
            mintY: mintYDetail.name,
            decimals: mintYDetail.decimals
          }
        ]
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/liquidswap/add-liquidity.ts
var import_ts_sdk24 = require("@aptos-labs/ts-sdk");
var import_tools28 = require("langchain/tools");
var LiquidSwapAddLiquidityTool = class extends import_tools28.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "liquidswap_add_liquidity";
  description = `this tool can be used to add liquidity in liquidswap

    if you want to add APT and one of the token, mint will be "0x1::aptos_coin::AptosCoin"

	if user added mintX or mintY as asset name, and you don't have the address of the asset, you can use the following token names:
	['usdt', 'zusdt', 'zusdc', 'apt', 'sthapt', 'mod', 'thl', 'wusdc' , 'zweth', 'wweth', 'cake', 'stapt', 'abtc', 'stone' , 'truapt', 'sbtc']
	or whatever name the user has provided, you can use the token name to get the address of the token 


    Inputs ( input is a JSON string ):
    mintX: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
    mintY: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
    mintXAmount: number, eg 1 or 0.01 (required)
    mintYAmount: number, eg 1 or 0.01 (required)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      let mintX = parsedInput.mintX;
      const tokenX = getTokenByTokenName(mintX);
      if (tokenX) {
        mintX = tokenX.tokenAddress;
      }
      let mintY = parsedInput.mintY;
      const tokenY = getTokenByTokenName(mintY);
      if (tokenY) {
        mintY = tokenY.tokenAddress;
      }
      const wrappedMintX = parseFungibleAssetAddressToWrappedAssetAddress(mintX);
      const wrappedMintY = parseFungibleAssetAddressToWrappedAssetAddress(mintY);
      const mintXDetail = await this.agent.getTokenDetails(wrappedMintX);
      const mintYDetail = await this.agent.getTokenDetails(wrappedMintY);
      const swapTransactionHash = await this.agent.addLiquidity(
        wrappedMintX,
        wrappedMintY,
        (0, import_ts_sdk24.convertAmountFromHumanReadableToOnChain)(parsedInput.mintXAmount, mintXDetail.decimals),
        (0, import_ts_sdk24.convertAmountFromHumanReadableToOnChain)(parsedInput.mintYAmount, mintYDetail.decimals)
      );
      return JSON.stringify({
        status: "success",
        swapTransactionHash,
        token: [
          {
            mintX: mintXDetail.name,
            decimals: mintXDetail.decimals
          },
          {
            mintY: mintYDetail.name,
            decimals: mintYDetail.decimals
          }
        ]
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/liquidswap/remove-liquidity.ts
var import_ts_sdk25 = require("@aptos-labs/ts-sdk");
var import_tools29 = require("langchain/tools");
var LiquidSwapRemoveLiquidityTool = class extends import_tools29.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "liquidswap_remove_liquidity";
  description = `this tool can be used to remove liquidity from liquidswap

if you want to remove APT and one of the token, mint will be "0x1::aptos_coin::AptosCoin"

if user added mintX or mintY as asset name, and you don't have the address of the asset, use these token names:
usdt,zusdt,zusdc,apt,sthapt,mod,thl,wusdc,zweth,wweth,cake,stapt,abtc,stone,truapt,sbtc
or whatever name the user has provided, you can use the token name to get the address of the token 

minMintX and minMintY are minimum amount of tokens to receive, default is 0

deposit liquidity in one of the pools to get LP tokens if you don't have LP tokens

Inputs (input is a JSON string):
mintX: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
mintY: string, eg same as mintX (required)
lpAmount: number, eg 1 or 0.01 (required)
minMintX: number, eg 1 or 0.01 (optional)
minMintY: number, eg 1 or 0.01 (optional)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      let mintX = parsedInput.mintX;
      const tokenX = getTokenByTokenName(mintX);
      if (tokenX) {
        mintX = tokenX.tokenAddress;
      }
      let mintY = parsedInput.mintY;
      const tokenY = getTokenByTokenName(mintY);
      if (tokenY) {
        mintY = tokenY.tokenAddress;
      }
      const mintXDetail = await this.agent.getTokenDetails(mintX);
      const mintYDetail = await this.agent.getTokenDetails(mintY);
      const removeLiquidityTransactionHash = await this.agent.removeLiquidity(
        parseFungibleAssetAddressToWrappedAssetAddress(mintX),
        parseFungibleAssetAddressToWrappedAssetAddress(mintY),
        (0, import_ts_sdk25.convertAmountFromHumanReadableToOnChain)(parsedInput.lpAmount, 6),
        (0, import_ts_sdk25.convertAmountFromHumanReadableToOnChain)(parsedInput.minMintX || 0, mintXDetail.decimals),
        (0, import_ts_sdk25.convertAmountFromHumanReadableToOnChain)(parsedInput.minMintY || 0, mintYDetail.decimals)
      );
      return JSON.stringify({
        status: "success",
        removeLiquidityTransactionHash,
        token: [
          {
            mintX: mintXDetail.name,
            decimals: mintXDetail.decimals
          },
          {
            mintY: mintYDetail.name,
            decimals: mintYDetail.decimals
          }
        ]
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/echelon/lend-token.ts
var import_ts_sdk26 = require("@aptos-labs/ts-sdk");
var import_tools30 = require("langchain/tools");
var EchelonLendTokenTool = class extends import_tools30.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "echelon_lend_token";
  description = `this tool can be used to lend APT, tokens or fungible asset to a position

    if you want to lend APT, mint will be "0x1::aptos_coin::AptosCoin"
    if user added mint as asset name, and you don't have the address of the asset, you can use the following token names:
    ['usdt', 'zusdt', 'zusdc', 'apt', 'sthapt', 'mod', 'thl', 'wusdc' , 'zweth', 'wweth', 'cake', 'stapt', 'abtc', 'stone' , 'truapt', 'sbtc']
    or whatever name the user has provided, you can use the token name to get the address of the token

    Inputs ( input is a JSON string ) (IMPORTANT):
    amount: number, eg 1 or 0.01 (required)
    mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const token = getTokenByTokenName(parsedInput.mint) || getTokenByTokenAddress(parsedInput.mint);
      if (!token) throw new Error("Token not found");
      const mintDetail = await this.agent.getTokenDetails(token.tokenAddress);
      console.log("mintDetail", mintDetail);
      const lendTokenTransactionHash = await this.agent.lendTokenWithEchelon(
        token.tokenAddress,
        (0, import_ts_sdk26.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8),
        token.poolAddress,
        token.tokenAddress.split("::").length !== 3
      );
      return JSON.stringify({
        status: "success",
        lendTokenTransactionHash,
        token: {
          name: mintDetail.name || "APT",
          decimals: mintDetail.decimals || 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/echelon/withdraw-token.ts
var import_ts_sdk27 = require("@aptos-labs/ts-sdk");
var import_tools31 = require("langchain/tools");
var EchelonWithdrawTokenTool = class extends import_tools31.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "echelon_withdraw_token";
  description = `this tool can be used to withdraw APT, tokens or fungible asset from a position

    if you want to withdraw APT, mint will be "0x1::aptos_coin::AptosCoin"
    if user added mint as asset name, and you don't have the address of the asset, you can use the following token names:
    ['usdt', 'zusdt', 'zusdc', 'apt', 'sthapt', 'mod', 'thl', 'wusdc' , 'zweth', 'wweth', 'cake', 'stapt', 'abtc', 'stone' , 'truapt', 'sbtc']
    or whatever name the user has provided, you can use the token name to get the address of the token

    Inputs ( input is a JSON string ) (IMPORTANT):
    amount: number, eg 1 or 0.01 (required)
    mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const token = getTokenByTokenName(parsedInput.mint) || getTokenByTokenAddress(parsedInput.mint);
      if (!token) throw new Error("Token not found");
      const mintDetail = await this.agent.getTokenDetails(token.tokenAddress);
      console.log("mintDetail", mintDetail);
      const withdrawTokenTransactionHash = await this.agent.withdrawTokenWithEchelon(
        token.tokenAddress,
        (0, import_ts_sdk27.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8),
        token.poolAddress,
        token.tokenAddress.split("::").length !== 3
      );
      return JSON.stringify({
        status: "success",
        withdrawTokenTransactionHash,
        token: {
          name: mintDetail.name || "APT",
          decimals: mintDetail.decimals || 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/echelon/repay-token.ts
var import_ts_sdk28 = require("@aptos-labs/ts-sdk");
var import_tools32 = require("langchain/tools");
var EchelonRepayTokenTool = class extends import_tools32.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "echelon_repay_token";
  description = `this tool can be used to repay APT, tokens or fungible asset from a position

    if you want to repay APT, mint will be "0x1::aptos_coin::AptosCoin"
    if user added mint as asset name, and you don't have the address of the asset, you can use the following token names:
    ['usdt', 'zusdt', 'zusdc', 'apt', 'sthapt', 'mod', 'thl', 'wusdc' , 'zweth', 'wweth', 'cake', 'stapt', 'abtc', 'stone' , 'truapt', 'sbtc']
    or whatever name the user has provided, you can use the token name to get the address of the token

    Inputs ( input is a JSON string ) (IMPORTANT):
    amount: number, eg 1 or 0.01 (required)
    mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const token = getTokenByTokenName(parsedInput.mint) || getTokenByTokenAddress(parsedInput.mint);
      if (!token) throw new Error("Token not found");
      const mintDetail = await this.agent.getTokenDetails(token.tokenAddress);
      const repayTokenTransactionHash = await this.agent.repayTokenWithEchelon(
        token.tokenAddress,
        (0, import_ts_sdk28.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8),
        token.poolAddress,
        token.tokenAddress.split("::").length !== 3
      );
      return JSON.stringify({
        status: "success",
        repayTokenTransactionHash,
        token: {
          name: mintDetail.name || "APT",
          decimals: mintDetail.decimals || 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/echelon/borrow-token.ts
var import_ts_sdk29 = require("@aptos-labs/ts-sdk");
var import_tools33 = require("langchain/tools");
var EchelonBorrowTokenTool = class extends import_tools33.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "echelon_borrow_token";
  description = `this tool can be used to borrow APT, tokens or fungible asset from a position

  if you want to borrow APT, mint will be "0x1::aptos_coin::AptosCoin"

  if user added mint as asset name, and you don't have the address of the asset, you can use the following token names:
  ['usdt', 'zusdt', 'zusdc', 'apt', 'sthapt', 'mod', 'thl', 'wusdc' , 'zweth', 'wweth', 'cake', 'stapt', 'abtc', 'stone' , 'truapt', 'sbtc']
  or whatever name the user has provided, you can use the token name to get the address of the token 


  Inputs ( input is a JSON string ) (IMPORTANT):
  amount: number, eg 1 or 0.01 (required)
  mint: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" or "usdt (name of the token)" (required)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const token = getTokenByTokenName(parsedInput.mint) || getTokenByTokenAddress(parsedInput.mint);
      if (!token) throw new Error("Token not found");
      const mintDetail = await this.agent.getTokenDetails(token.tokenAddress);
      const borrowTokenTransactionHash = await this.agent.borrowTokenWithEchelon(
        token.tokenAddress,
        (0, import_ts_sdk29.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, mintDetail.decimals || 8),
        token.poolAddress,
        token.tokenAddress.split("::").length !== 3
      );
      return JSON.stringify({
        status: "success",
        borrowTokenTransactionHash,
        token: {
          name: mintDetail.name || "APT",
          decimals: mintDetail.decimals || 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/echo/stake.ts
var import_ts_sdk30 = require("@aptos-labs/ts-sdk");
var import_tools34 = require("langchain/tools");
var EchoStakeTokenTool = class extends import_tools34.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "echo_stake_token";
  description = `this tool can be used to stake token in Echo

    Inputs ( input is a JSON string ):
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const stakeTransactionHash = await this.agent.stakeTokenWithEcho(
        (0, import_ts_sdk30.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, 8)
      );
      return JSON.stringify({
        status: "success",
        stakeTransactionHash,
        token: {
          name: "eAPT",
          decimals: 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/echo/unstake.ts
var import_ts_sdk31 = require("@aptos-labs/ts-sdk");
var import_tools35 = require("langchain/tools");
var EchoUnstakeTokenTool = class extends import_tools35.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "echo_unstake_token";
  description = `this tool can be used to unstake token in Echo

    Inputs ( input is a JSON string ):
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const unstakeTransactionHash = await this.agent.unstakeTokenWithEcho(
        (0, import_ts_sdk31.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, 8)
      );
      return JSON.stringify({
        status: "success",
        unstakeTransactionHash,
        token: {
          name: "APT",
          decimals: 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/merkletrade/get-position.ts
var import_tools36 = require("langchain/tools");
var MerkleTradeGetPositionTool = class extends import_tools36.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "merkle_trade_get_position";
  description = `this tool can be used to get position on MerkleTrade
    No inputs required, this tool will return the current position of the agent
  `;
  async _call() {
    try {
      const position = await this.agent.getPositionsWithMerkleTrade();
      return JSON.stringify({
        status: "success",
        position
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/merkletrade/place-limit-order.ts
var import_tools37 = require("langchain/tools");
var MerkleTradePlaceLimitOrderTool = class extends import_tools37.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "merkle_trade_place_limit_order";
  description = `this tool can be used to place limit order on MerkleTrade

  if you want to place a limit order to buy BTC at 100000, pair will be "BTC_USD" and isLong will be true, price will be 100000
  
	Inputs ( input is a JSON string ):
	pair: string, eg "BTC_USD" (required)
	isLong: boolean, eg true (required)
	sizeDelta: number, eg 10 (required)
	collateralDelta: number, eg 10 (required)
	price: number, eg 10000 (required)
	`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const txhash = await this.agent.placeLimitOrderWithMerkleTrade(
        parsedInput.pair,
        parsedInput.isLong,
        parsedInput.sizeDelta,
        parsedInput.collateralDelta,
        parsedInput.price
      );
      return JSON.stringify({
        status: "success",
        limitOrderTransactionHash: txhash,
        position: {
          pair: parsedInput.pair,
          isLong: parsedInput.isLong,
          sizeDelta: parsedInput.sizeDelta,
          collateralDelta: parsedInput.collateralDelta,
          price: parsedInput.price
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/merkletrade/place-market-order.ts
var import_tools38 = require("langchain/tools");
var MerkleTradePlaceMarketOrderTool = class extends import_tools38.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "merkle_trade_place_market_order";
  description = `this tool can be used to place market order on MerkleTrade

  if you want to place a market order to buy BTC, pair will be "BTC_USD" and isLong will be true, 
  if you want to place a market order to sell BTC, pair will be "BTC_USD" and isLong will be false
  if you want to place a market order to size 100, collateral 10, sizeDelta will be 100, collateralDelta will be 10

	Inputs ( input is a JSON string ):
	pair: string, eg "BTC_USD" (required)
	isLong: boolean, eg true (required)
	sizeDelta: number, eg 10 (required)
	collateralDelta: number, eg 10 (required)
	`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const txhash = await this.agent.placeMarketOrderWithMerkleTrade(
        parsedInput.pair,
        parsedInput.isLong,
        parsedInput.sizeDelta,
        parsedInput.collateralDelta
      );
      return JSON.stringify({
        status: "success",
        marketOrderTransactionHash: txhash,
        position: {
          pair: parsedInput.pair,
          isLong: parsedInput.isLong,
          sizeDelta: parsedInput.sizeDelta,
          collateralDelta: parsedInput.collateralDelta
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/merkletrade/close-position.ts
var import_tools39 = require("langchain/tools");
var MerkleTradeClosePositionTool = class extends import_tools39.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "merkle_trade_close_position";
  description = `this tool can be used to close position on MerkleTrade

  if you want to close a position, pair will be "BTC_USD" and isLong will be true
  
	Inputs ( input is a JSON string ):
	pair: string, eg "BTC_USD" (required)
	isLong: boolean, eg true (required)
	`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const txhash = await this.agent.closePositionWithMerkleTrade(parsedInput.pair, parsedInput.isLong);
      return JSON.stringify({
        status: "success",
        closePositionTransactionHash: txhash,
        position: {
          pair: parsedInput.pair,
          isLong: parsedInput.isLong,
          sizeDelta: parsedInput.sizeDelta,
          collateralDelta: parsedInput.collateralDelta,
          price: parsedInput.price
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/openai/create-image.ts
var import_tools40 = require("langchain/tools");
var OpenAICreateImageTool = class extends import_tools40.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "openai_create_image";
  description = `
    Generate an image using OpenAI's DALL-E

    Inputs ( input is a JSON string ):
    prompt: string, Text description of the image to generate (required)
    size: string, Image size ('256x256', '512x512', or '1024x1024') (default: '1024x1024')
    n: number, Number of images to generate (default: 1)`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const response = await this.agent.createImageWithOpenAI(parsedInput.prompt, parsedInput.size, parsedInput.n);
      return JSON.stringify({
        status: "success",
        response
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/panora/swap.ts
var import_tools41 = require("langchain/tools");
var PanoraSwapTool = class extends import_tools41.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "panora_aggregator_swap";
  description = `this tool can be used to swap tokens in panora - liquidity aggregator on aptos

	if you want to swap APT and one of the token, fromToken will be "0x1::aptos_coin::AptosCoin"

	Inputs ( input is a JSON string ):
	fromToken: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
	toToken: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
	swapAmount: number, eg 1 or 0.01 (required)
	toWalletAddress: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa" (optional)
	`;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintXDetail = await this.agent.getTokenDetails(parsedInput.fromToken);
      const mintYDetail = await this.agent.getTokenDetails(parsedInput.toToken);
      const swapTransactionHash = await this.agent.swapWithPanora(
        parsedInput.fromToken,
        parsedInput.toToken,
        parsedInput.swapAmount,
        parsedInput.toWalletAddress
      );
      return JSON.stringify({
        status: "success",
        swapTransactionHash,
        token: [
          {
            mintX: mintXDetail.name,
            decimals: mintXDetail.decimals
          },
          {
            mintY: mintYDetail.name,
            decimals: mintYDetail.decimals
          }
        ]
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/thala/stake.ts
var import_ts_sdk32 = require("@aptos-labs/ts-sdk");
var import_tools42 = require("langchain/tools");
var ThalaStakeTokenTool = class extends import_tools42.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "thala_stake_token";
  description = `this tool can be used to stake thAPT in Thala

    Inputs ( input is a JSON string ):
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const stakeTransactionHash = await this.agent.stakeTokensWithThala(
        (0, import_ts_sdk32.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, 8)
      );
      return JSON.stringify({
        status: "success",
        stakeTransactionHash,
        token: {
          name: "thAPT",
          decimals: 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/thala/unstake.ts
var import_ts_sdk33 = require("@aptos-labs/ts-sdk");
var import_tools43 = require("langchain/tools");
var ThalaUnstakeTokenTool = class extends import_tools43.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "thala_unstake_token";
  description = `this tool can be used to unstake thAPT in Thala

    Inputs ( input is a JSON string ):
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const unstakeTransactionHash = await this.agent.unstakeTokensWithThala(
        (0, import_ts_sdk33.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, 8)
      );
      return JSON.stringify({
        status: "success",
        unstakeTransactionHash,
        token: {
          name: "APT",
          decimals: 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/thala/mint-mod.ts
var import_ts_sdk34 = require("@aptos-labs/ts-sdk");
var import_tools44 = require("langchain/tools");
var ThalaMintMODTool = class extends import_tools44.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "thala_mint_mod";
  description = `this tool can be used to mint move dollar (MOD) in Thala

    Only supported coin types: lzUSDC, whUSDC, or USDt

	if the user coin is not in the list , default to lzUSDC

	mintType for lzUSDC - 0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDC
	mintType for wUSDC - 0x5e156f1207d0ebfa19a9eeff00d62a282278fb8719f4fab3a586a0a2c0fffbea::coin::T
	mintType for USDt - 0x357b0b74bc833e95a115ad22604854d6b0fca151cecd94111770e5d6ffc9dc2b

    Inputs ( input is a JSON string ):
    mintType: eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintMODTransactionHash = await this.agent.mintMODWithThala(
        parsedInput.mintType,
        (0, import_ts_sdk34.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, 6)
      );
      return JSON.stringify({
        status: "success",
        mintMODTransactionHash,
        token: {
          name: "MOD",
          decimals: 8
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/thala/redeem-mod.ts
var import_ts_sdk35 = require("@aptos-labs/ts-sdk");
var import_tools45 = require("langchain/tools");
var ThalaRedeemMODTool = class extends import_tools45.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "thala_redeem_mod";
  description = `this tool can be used to redeem move dollar (MOD) in Thala

  Only supported coin types: lzUSDC, whUSDC, or USDt

	if the user coin is not in the list , default to lzUSDC

	mintType for lzUSDC - 0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDC
	mintType for wUSDC - 0x5e156f1207d0ebfa19a9eeff00d62a282278fb8719f4fab3a586a0a2c0fffbea::coin::T
	mintType for USDt - 0x357b0b74bc833e95a115ad22604854d6b0fca151cecd94111770e5d6ffc9dc2b


    Inputs ( input is a JSON string ):
    mintType: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
    amount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const tokenDetails = await this.agent.getTokenDetails(parsedInput.mintType);
      const redeemMODTransactionHash = await this.agent.redeemMODWithThala(
        parsedInput.mintType,
        (0, import_ts_sdk35.convertAmountFromHumanReadableToOnChain)(parsedInput.amount, 6)
      );
      return JSON.stringify({
        status: "success",
        redeemMODTransactionHash,
        token: {
          name: tokenDetails.name,
          decimals: tokenDetails.decimals
        }
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/thala/add-liquidity.ts
var import_ts_sdk36 = require("@aptos-labs/ts-sdk");
var import_tools46 = require("langchain/tools");
var ThalaAddLiquidityTool = class extends import_tools46.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "thala_add_liquidity";
  description = `this tool can be used to add liquidity to a Thala pool

    If you want to add APT, use "0x1::aptos_coin::AptosCoin" as the coin type

    Inputs ( input is a JSON string ) (IMPORTANT):
    mintX: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
    mintY: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
    mintXAmount: number, eg 1 or 0.01 (required)
    mintYAmount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintXDetail = await this.agent.getTokenDetails(parsedInput.mintX);
      const mintYDetail = await this.agent.getTokenDetails(parsedInput.mintY);
      const addLiquidityTransactionHash = await this.agent.addLiquidityWithThala(
        parsedInput.mintX,
        parsedInput.mintY,
        (0, import_ts_sdk36.convertAmountFromHumanReadableToOnChain)(parsedInput.mintXAmount, mintXDetail.decimals),
        (0, import_ts_sdk36.convertAmountFromHumanReadableToOnChain)(parsedInput.mintYAmount, mintYDetail.decimals)
      );
      return JSON.stringify({
        status: "success",
        addLiquidityTransactionHash,
        tokens: [
          {
            mintX: mintXDetail.name,
            decimals: mintXDetail.decimals
          },
          {
            mintY: mintYDetail.name,
            decimals: mintYDetail.decimals
          }
        ]
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/thala/remove-liquidity.ts
var import_ts_sdk37 = require("@aptos-labs/ts-sdk");
var import_tools47 = require("langchain/tools");
var ThalaRemoveLiquidityTool = class extends import_tools47.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "thala_remove_liquidity";
  description = `this tool can be used to remove liquidity from a Thala pool

    If one of your coins is APT, use "0x1::aptos_coin::AptosCoin" as the coin type

    Inputs ( input is a JSON string ):
    mintX: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
    mintY: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
    lpAmount: number, eg 1 or 0.01 (required)
    `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintXDetail = await this.agent.getTokenDetails(parsedInput.mintX);
      const mintYDetail = await this.agent.getTokenDetails(parsedInput.mintY);
      const removeLiquidityTransactionHash = await this.agent.removeLiquidityWithThala(
        parsedInput.mintX,
        parsedInput.mintY,
        (0, import_ts_sdk37.convertAmountFromHumanReadableToOnChain)(parsedInput.lpAmount, 6)
      );
      return JSON.stringify({
        status: "success",
        removeLiquidityTransactionHash,
        tokens: [
          {
            mintX: mintXDetail.name,
            decimals: 6
          },
          {
            mintY: mintYDetail.name,
            decimals: 6
          }
        ]
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/thala/create-pool.ts
var import_ts_sdk38 = require("@aptos-labs/ts-sdk");
var import_tools48 = require("langchain/tools");
var ThalaCreatePoolTool = class extends import_tools48.Tool {
  constructor(agent) {
    super();
    this.agent = agent;
  }
  name = "thala_create_pool";
  description = `this tool can be used to create a new pool in Thala

    If you want to create a pool with APT, use "0x1::aptos_coin::AptosCoin" as the coin type
    For other coins use their respective addresses

    Fee tiers:
    - 1 for 0.01%
    - 5 for 0.05%
    - 30 for 0.3%
    - 100 for 1%

    Amplification factors: 10, 100, or 1000

    If the user did not provide any input for fee tiers or amplification, do not fill any fee tiers or amplification. 
    Ask the user to provide fee tiers and amplification.

    Inputs (input is a JSON string):
    mintX: string, eg "0x1::aptos_coin::AptosCoin" (required)
    mintY: string, eg "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT" (required)
    amountX: number, eg 1 or 0.01 (required)
    amountY: number, eg 1 or 0.01 (required)
    feeTier: number, eg 1, 5, 30, or 100 (required)
    amplificationFactor: number, eg 10, 100, or 1000 (required)
  `;
  async _call(input) {
    try {
      const parsedInput = parseJson(input);
      const mintXDetail = await this.agent.getTokenDetails(parsedInput.mintX);
      const mintYDetail = await this.agent.getTokenDetails(parsedInput.mintY);
      const createPoolTransactionHash = await this.agent.createPoolWithThala(
        parsedInput.mintX,
        parsedInput.mintY,
        (0, import_ts_sdk38.convertAmountFromHumanReadableToOnChain)(parsedInput.amountX, mintXDetail.decimals),
        (0, import_ts_sdk38.convertAmountFromHumanReadableToOnChain)(parsedInput.amountY, mintYDetail.decimals),
        parsedInput.feeTier,
        parsedInput.amplificationFactor
      );
      return JSON.stringify({
        status: "success",
        createPoolTransactionHash,
        tokens: [
          {
            mintX: mintXDetail.name,
            decimals: mintXDetail.decimals
          },
          {
            mintY: mintYDetail.name,
            decimals: mintYDetail.decimals
          }
        ]
      });
    } catch (error) {
      return JSON.stringify({
        status: "error",
        message: error.message,
        code: error.code || "UNKNOWN_ERROR"
      });
    }
  }
};

// src/langchain/index.ts
var createAptosTools = (agent, config = {}) => {
  const tools = [
    // Aptos tools
    new AptosBalanceTool(agent),
    new AptosAccountAddressTool(agent),
    new AptosTransferTokenTool(agent),
    // new AptosBurnNFTTool(agent),
    new AptosBurnTokenTool(agent),
    // new AptosTransferNFTTool(agent),
    new AptosTransactionTool(agent),
    new AptosGetTokenDetailTool(agent),
    new AptosMintTokenTool(agent),
    new AptosCreateTokenTool(agent),
    new AptosGetTokenPriceTool(agent),
    // Amnis tools
    new AmnisStakeTool(agent),
    new AmnisWithdrawStakeTool(agent),
    // Joule tools
    new JouleLendTokenTool(agent),
    new JouleWithdrawTokenTool(agent),
    new JouleBorrowTokenTool(agent),
    new JouleRepayTokenTool(agent),
    new JouleGetPoolDetails(agent),
    new JouleGetUserPosition(agent),
    new JouleGetUserAllPositions(agent),
    new JouleClaimRewardTool(agent),
    // LiquidSwap tools
    new LiquidSwapCreatePoolTool(agent),
    new LiquidSwapAddLiquidityTool(agent),
    new LiquidSwapRemoveLiquidityTool(agent),
    new LiquidSwapSwapTool(agent),
    // Aries tools
    new AriesCreateProfileTool(agent),
    new AriesWithdrawTool(agent),
    new AriesBorrowTool(agent),
    new AriesLendTool(agent),
    new AriesRepayTool(agent),
    // Thala tools
    new ThalaAddLiquidityTool(agent),
    new ThalaRemoveLiquidityTool(agent),
    new ThalaMintMODTool(agent),
    new ThalaRedeemMODTool(agent),
    new ThalaUnstakeTokenTool(agent),
    new ThalaStakeTokenTool(agent),
    new ThalaCreatePoolTool(agent),
    // Panora tools
    new PanoraSwapTool(agent),
    // OpenAI tools
    new OpenAICreateImageTool(agent),
    // Echo tools
    new EchoStakeTokenTool(agent),
    new EchoUnstakeTokenTool(agent),
    // Echelon tools
    new EchelonLendTokenTool(agent),
    new EchelonWithdrawTokenTool(agent),
    new EchelonRepayTokenTool(agent),
    new EchelonBorrowTokenTool(agent),
    // Merkletrade Tools
    new MerkleTradeClosePositionTool(agent),
    new MerkleTradeGetPositionTool(agent),
    new MerkleTradePlaceLimitOrderTool(agent),
    new MerkleTradePlaceMarketOrderTool(agent)
  ];
  return config.filter ? tools.filter((tool) => config?.filter?.includes(tool.name)) : tools;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AgentRuntime,
  AmnisStakeTool,
  AmnisWithdrawStakeTool,
  AptosAccountAddressTool,
  AptosBalanceTool,
  AptosBurnTokenTool,
  AptosCreateTokenTool,
  AptosGetTokenDetailTool,
  AptosGetTokenPriceTool,
  AptosMintTokenTool,
  AptosTransactionTool,
  AptosTransferTokenTool,
  AriesBorrowTool,
  AriesCreateProfileTool,
  AriesLendTool,
  AriesRepayTool,
  AriesWithdrawTool,
  BaseSigner,
  EchelonBorrowTokenTool,
  EchelonLendTokenTool,
  EchelonRepayTokenTool,
  EchelonWithdrawTokenTool,
  EchoStakeTokenTool,
  EchoUnstakeTokenTool,
  JouleBorrowTokenTool,
  JouleClaimRewardTool,
  JouleGetPoolDetails,
  JouleGetUserAllPositions,
  JouleGetUserPosition,
  JouleLendTokenTool,
  JouleRepayTokenTool,
  JouleWithdrawTokenTool,
  LiquidSwapAddLiquidityTool,
  LiquidSwapCreatePoolTool,
  LiquidSwapRemoveLiquidityTool,
  LiquidSwapSwapTool,
  LocalSigner,
  OpenAICreateImageTool,
  PanoraSwapTool,
  ThalaAddLiquidityTool,
  ThalaMintMODTool,
  ThalaRedeemMODTool,
  ThalaRemoveLiquidityTool,
  ThalaStakeTokenTool,
  ThalaUnstakeTokenTool,
  WalletSigner,
  createAptosTools,
  parseJson
});
//# sourceMappingURL=index.js.map