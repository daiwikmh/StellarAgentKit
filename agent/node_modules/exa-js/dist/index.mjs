// src/index.ts
import fetch, { Headers } from "cross-fetch";
var fetchImpl = typeof global !== "undefined" && global.fetch ? global.fetch : fetch;
var HeadersImpl = typeof global !== "undefined" && global.Headers ? global.Headers : Headers;
var Exa = class {
  /**
   * Helper method to separate out the contents-specific options from the rest.
   */
  extractContentsOptions(options) {
    const {
      text,
      highlights,
      summary,
      subpages,
      subpageTarget,
      extras,
      livecrawl,
      livecrawlTimeout,
      ...rest
    } = options;
    const contentsOptions = {};
    if (text === void 0 && summary === void 0 && highlights === void 0 && extras === void 0) {
      contentsOptions.text = true;
    }
    if (text !== void 0)
      contentsOptions.text = text;
    if (summary !== void 0)
      contentsOptions.summary = summary;
    if (highlights !== void 0)
      contentsOptions.highlights = highlights;
    if (subpages !== void 0)
      contentsOptions.subpages = subpages;
    if (subpageTarget !== void 0)
      contentsOptions.subpageTarget = subpageTarget;
    if (extras !== void 0)
      contentsOptions.extras = extras;
    if (livecrawl !== void 0)
      contentsOptions.livecrawl = livecrawl;
    if (livecrawlTimeout !== void 0)
      contentsOptions.livecrawlTimeout = livecrawlTimeout;
    return {
      contentsOptions,
      restOptions: rest
    };
  }
  /**
   * Constructs the Exa API client.
   * @param {string} apiKey - The API key for authentication.
   * @param {string} [baseURL] - The base URL of the Exa API.
   */
  constructor(apiKey, baseURL = "https://api.exa.ai") {
    this.baseURL = baseURL;
    if (!apiKey) {
      apiKey = process.env.EXASEARCH_API_KEY;
      if (!apiKey) {
        throw new Error(
          "API key must be provided as an argument or as an environment variable (EXASEARCH_API_KEY)"
        );
      }
    }
    this.headers = new HeadersImpl({
      "x-api-key": apiKey,
      "Content-Type": "application/json",
      "User-Agent": "exa-node 1.4.0"
    });
  }
  /**
   * Makes a request to the Exa API.
   * @param {string} endpoint - The API endpoint to call.
   * @param {string} method - The HTTP method to use.
   * @param {any} [body] - The request body for POST requests.
   * @returns {Promise<any>} The response from the API.
   */
  async request(endpoint, method, body) {
    const response = await fetchImpl(this.baseURL + endpoint, {
      method,
      headers: this.headers,
      body: body ? JSON.stringify(body) : void 0
    });
    if (!response.ok) {
      const message = (await response.json()).error;
      throw new Error(
        `Request failed with status ${response.status}. ${message}`
      );
    }
    return await response.json();
  }
  /**
   * Performs a search with an Exa prompt-engineered query.
   * 
   * @param {string} query - The query string.
   * @param {RegularSearchOptions} [options] - Additional search options
   * @returns {Promise<SearchResponse<{}>>} A list of relevant search results.
   */
  async search(query, options) {
    return await this.request("/search", "POST", { query, ...options });
  }
  /**
   * Performs a search with an Exa prompt-engineered query and returns the contents of the documents.
   * 
   * @param {string} query - The query string.
   * @param {RegularSearchOptions & T} [options] - Additional search + contents options
   * @returns {Promise<SearchResponse<T>>} A list of relevant search results with requested contents.
   */
  async searchAndContents(query, options) {
    const { contentsOptions, restOptions } = options === void 0 ? { contentsOptions: { text: true }, restOptions: {} } : this.extractContentsOptions(options);
    return await this.request("/search", "POST", {
      query,
      contents: contentsOptions,
      ...restOptions
    });
  }
  /**
   * Finds similar links to the provided URL.
   * @param {string} url - The URL for which to find similar links.
   * @param {FindSimilarOptions} [options] - Additional options for finding similar links.
   * @returns {Promise<SearchResponse<{}>>} A list of similar search results.
   */
  async findSimilar(url, options) {
    return await this.request("/findSimilar", "POST", { url, ...options });
  }
  /**
   * Finds similar links to the provided URL and returns the contents of the documents.
   * @param {string} url - The URL for which to find similar links.
   * @param {FindSimilarOptions & T} [options] - Additional options for finding similar links + contents.
   * @returns {Promise<SearchResponse<T>>} A list of similar search results, including requested contents.
   */
  async findSimilarAndContents(url, options) {
    const { contentsOptions, restOptions } = options === void 0 ? { contentsOptions: { text: true }, restOptions: {} } : this.extractContentsOptions(options);
    return await this.request("/findSimilar", "POST", {
      url,
      contents: contentsOptions,
      ...restOptions
    });
  }
  /**
   * Retrieves contents of documents based on URLs.
   * @param {string | string[] | SearchResult[]} urls - A URL or array of URLs, or an array of SearchResult objects.
   * @param {ContentsOptions} [options] - Additional options for retrieving document contents.
   * @returns {Promise<SearchResponse<T>>} A list of document contents for the requested URLs.
   */
  async getContents(urls, options) {
    if (!urls || Array.isArray(urls) && urls.length === 0) {
      throw new Error("Must provide at least one URL");
    }
    let requestUrls;
    if (typeof urls === "string") {
      requestUrls = [urls];
    } else if (typeof urls[0] === "string") {
      requestUrls = urls;
    } else {
      requestUrls = urls.map((result) => result.url);
    }
    const payload = {
      urls: requestUrls,
      ...options
    };
    return await this.request("/contents", "POST", payload);
  }
  /**
   * Generate an answer to a query.
   * @param {string} query - The question or query to answer.
   * @param {AnswerOptions} [options] - Additional options for answer generation.
   * @returns {Promise<AnswerResponse>} The generated answer and source references.
   * 
   * Note: For streaming responses, use the `streamAnswer` method:
   * ```ts
   * for await (const chunk of exa.streamAnswer(query)) {
   *   // Handle chunks
   * }
   * ```
   */
  async answer(query, options) {
    if (options?.stream) {
      throw new Error(
        "For streaming responses, please use streamAnswer() instead:\n\nfor await (const chunk of exa.streamAnswer(query)) {\n  // Handle chunks\n}"
      );
    }
    const requestBody = {
      query,
      stream: false,
      text: options?.text ?? false,
      model: options?.model ?? "exa"
    };
    return await this.request("/answer", "POST", requestBody);
  }
  /**
   * Stream an answer as an async generator
   *
   * Each iteration yields a chunk with partial text (`content`) or new citations.
   * Use this if you'd like to read the answer incrementally, e.g. in a chat UI.
   *
   * Example usage:
   * ```ts
   * for await (const chunk of exa.streamAnswer("What is quantum computing?", { text: false })) {
   *   if (chunk.content) process.stdout.write(chunk.content);
   *   if (chunk.citations) {
   *     console.log("\nCitations: ", chunk.citations);
   *   }
   * }
   * ```
   */
  async *streamAnswer(query, options) {
    const body = {
      query,
      text: options?.text ?? false,
      stream: true,
      model: options?.model ?? "exa"
    };
    const response = await fetchImpl(this.baseURL + "/answer", {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(body)
    });
    if (!response.ok) {
      const message = await response.text();
      throw new Error(
        `Request failed with status ${response.status}. ${message}`
      );
    }
    const reader = response.body?.getReader();
    if (!reader) {
      throw new Error("No response body available for streaming.");
    }
    const decoder = new TextDecoder();
    let buffer = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (!line.startsWith("data: "))
            continue;
          const jsonStr = line.replace(/^data:\s*/, "").trim();
          if (!jsonStr || jsonStr === "[DONE]") {
            continue;
          }
          let chunkData;
          try {
            chunkData = JSON.parse(jsonStr);
          } catch (err) {
            continue;
          }
          const chunk = this.processChunk(chunkData);
          if (chunk.content || chunk.citations) {
            yield chunk;
          }
        }
      }
      if (buffer.startsWith("data: ")) {
        const leftover = buffer.replace(/^data:\s*/, "").trim();
        if (leftover && leftover !== "[DONE]") {
          try {
            const chunkData = JSON.parse(leftover);
            const chunk = this.processChunk(chunkData);
            if (chunk.content || chunk.citations) {
              yield chunk;
            }
          } catch (e) {
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }
  processChunk(chunkData) {
    let content;
    let citations;
    if (chunkData.choices && chunkData.choices[0] && chunkData.choices[0].delta) {
      content = chunkData.choices[0].delta.content;
    }
    if (chunkData.citations && chunkData.citations !== "null") {
      citations = chunkData.citations.map((c) => ({
        id: c.id,
        url: c.url,
        title: c.title,
        publishedDate: c.publishedDate,
        author: c.author,
        text: c.text
      }));
    }
    return { content, citations };
  }
};
var src_default = Exa;
export {
  src_default as default
};
//# sourceMappingURL=index.mjs.map