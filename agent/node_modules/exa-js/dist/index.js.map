{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import fetch, { Headers } from \"cross-fetch\";\n\n// Use native fetch in Node.js environments\nconst fetchImpl = typeof global !== \"undefined\" && global.fetch ? global.fetch : fetch;\nconst HeadersImpl = typeof global !== \"undefined\" && global.Headers ? global.Headers : Headers;\n\nconst isBeta = false;\n\n/**\n * Search options for performing a search query.\n * @typedef {Object} SearchOptions\n * @property {number} [numResults] - Number of search results to return. Default 10. Max 10 for basic plans.\n * @property {string[]} [includeDomains] - List of domains to include in the search.\n * @property {string[]} [excludeDomains] - List of domains to exclude in the search.\n * @property {string} [startCrawlDate] - Start date for results based on crawl date.\n * @property {string} [endCrawlDate] - End date for results based on crawl date.\n * @property {string} [startPublishedDate] - Start date for results based on published date.\n * @property {string} [endPublishedDate] - End date for results based on published date.\n * @property {string} [category] - A data category to focus on, with higher comprehensivity and data cleanliness. Currently, the only category is company.\n * @property {string[]} [includeText] - List of strings that must be present in webpage text of results. Currently only supports 1 string of up to 5 words.\n * @property {string[]} [excludeText] - List of strings that must not be present in webpage text of results. Currently only supports 1 string of up to 5 words.\n * @property {string[]} [flags] - Experimental flags\n */\nexport type BaseSearchOptions = {\n  numResults?: number;\n  includeDomains?: string[];\n  excludeDomains?: string[];\n  startCrawlDate?: string;\n  endCrawlDate?: string;\n  startPublishedDate?: string;\n  endPublishedDate?: string;\n  category?:\n    | \"company\"\n    | \"research paper\"\n    | \"news\"\n    | \"pdf\"\n    | \"github\"\n    | \"tweet\"\n    | \"personal site\"\n    | \"linkedin profile\"\n    | \"financial report\";\n  includeText?: string[];\n  excludeText?: string[];\n  flags?: string[];\n};\n\n/**\n * Search options for performing a search query.\n * @typedef {Object} RegularSearchOptions\n */\nexport type RegularSearchOptions = BaseSearchOptions & {\n  /**\n   * If true, the search results are moderated for safety.\n   */\n  moderation?: boolean;\n\n  useAutoprompt?: boolean;\n  type?: \"keyword\" | \"neural\" | \"auto\";\n};\n\n/**\n * Options for finding similar links.\n * @typedef {Object} FindSimilarOptions\n * @property {boolean} [excludeSourceDomain] - If true, excludes links from the base domain of the input.\n */\nexport type FindSimilarOptions = BaseSearchOptions & {\n  excludeSourceDomain?: boolean;\n};\n\nexport type ExtrasOptions = { links?: number; imageLinks?: number };\n\n/**\n * Search options for performing a search query.\n * @typedef {Object} ContentsOptions\n * @property {TextContentsOptions | boolean} [text] - Options for retrieving text contents.\n * @property {HighlightsContentsOptions | boolean} [highlights] - Options for retrieving highlights.\n * @property {SummaryContentsOptions | boolean} [summary] - Options for retrieving summary.\n * @property {LivecrawlOptions} [livecrawl] - Options for livecrawling contents. Default is \"never\" for neural/auto search, \"fallback\" for keyword search.\n * @property {number} [livecrawlTimeout] - The timeout for livecrawling. Max and default is 10000ms.\n * @property {boolean} [filterEmptyResults] - If true, filters out results with no contents. Default is true.\n * @property {number} [subpages] - The number of subpages to return for each result, where each subpage is derived from an internal link for the result.\n * @property {string | string[]} [subpageTarget] - Text used to match/rank subpages in the returned subpage list. You could use \"about\" to get *about* page for websites. Note that this is a fuzzy matcher.\n * @property {ExtrasOptions} [extras] - Miscelleneous data derived from results\n */\nexport type ContentsOptions = {\n  text?: TextContentsOptions | true;\n  highlights?: HighlightsContentsOptions | true;\n  summary?: SummaryContentsOptions | true;\n  livecrawl?: LivecrawlOptions;\n  livecrawlTimeout?: number;\n  filterEmptyResults?: boolean;\n  subpages?: number;\n  subpageTarget?: string | string[];\n  extras?: ExtrasOptions;\n} & (typeof isBeta extends true ? {} : {});\n\n/**\n * Options for livecrawling contents\n * @typedef {string} LivecrawlOptions\n */\nexport type LivecrawlOptions = \"never\" | \"fallback\" | \"always\" | \"auto\";\n\n/**\n * Options for retrieving text from page.\n * @typedef {Object} TextContentsOptions\n * @property {number} [maxCharacters] - The maximum number of characters to return.\n * @property {boolean} [includeHtmlTags] - If true, includes HTML tags in the returned text. Default: false\n */\nexport type TextContentsOptions = {\n  maxCharacters?: number;\n  includeHtmlTags?: boolean;\n};\n\n/**\n * Options for retrieving highlights from page.\n * @typedef {Object} HighlightsContentsOptions\n * @property {string} [query] - The query string to use for highlights search.\n * @property {number} [numSentences] - The number of sentences to return for each highlight.\n * @property {number} [highlightsPerUrl] - The number of highlights to return for each URL.\n */\nexport type HighlightsContentsOptions = {\n  query?: string;\n  numSentences?: number;\n  highlightsPerUrl?: number;\n};\n\n/**\n * Represents a JSON Schema definition used for structured summary output.\n * To learn more visit https://json-schema.org/overview/what-is-jsonschema.\n */\nexport type JSONSchema = {\n  $schema?: string;\n  title?: string;\n  description?: string;\n  type:\n    | \"object\"\n    | \"array\"\n    | \"string\"\n    | \"number\"\n    | \"boolean\"\n    | \"null\"\n    | \"integer\";\n  properties?: Record<string, JSONSchema>;\n  items?: JSONSchema | JSONSchema[];\n  required?: string[];\n  enum?: any[];\n  additionalProperties?: boolean | JSONSchema;\n  definitions?: Record<string, JSONSchema>;\n  patternProperties?: Record<string, JSONSchema>;\n  allOf?: JSONSchema[];\n  anyOf?: JSONSchema[];\n  oneOf?: JSONSchema[];\n  not?: JSONSchema;\n};\n\n/**\n * Options for retrieving summary from page.\n * @typedef {Object} SummaryContentsOptions\n * @property {string} [query] - The query string to use for summary generation.\n * @property {JSONSchema} [schema] - JSON schema for structured output from summary.\n */\nexport type SummaryContentsOptions = {\n  query?: string;\n  schema?: JSONSchema;\n};\n\n/**\n * @typedef {Object} TextResponse\n * @property {string} text - Text from page\n */\nexport type TextResponse = { text: string };\n\n/**\n * @typedef {Object} HighlightsResponse\n * @property {string[]} highlights - The highlights as an array of strings.\n * @property {number[]} highlightScores - The corresponding scores as an array of floats, 0 to 1\n */\nexport type HighlightsResponse = {\n  highlights: string[];\n  highlightScores: number[];\n};\n\n/**\n * @typedef {Object} SummaryResponse\n * @property {string} summary - The generated summary of the page content.\n */\nexport type SummaryResponse = { summary: string };\n\n/**\n * @typedef {Object} ExtrasResponse\n * @property {string[]} links - The links on the page of a result\n * @property {string[]} imageLinks - The image links on the page of a result\n */\nexport type ExtrasResponse = { extras: { links?: string[]; imageLinks?: string[] } };\n\n/**\n * @typedef {Object} SubpagesResponse\n * @property {ContentsResultComponent<T extends ContentsOptions>} subpages - The subpages for a result\n */\nexport type SubpagesResponse<T extends ContentsOptions> = {\n  subpages: ContentsResultComponent<T>[];\n};\n\nexport type Default<T extends {}, U> = [keyof T] extends [never] ? U : T;\n\n/**\n * @typedef {Object} ContentsResultComponent\n * Depending on 'ContentsOptions', this yields a combination of 'TextResponse', 'HighlightsResponse', 'SummaryResponse', or an empty object.\n *\n * @template T - A type extending from 'ContentsOptions'.\n */\nexport type ContentsResultComponent<T extends ContentsOptions> = Default<\n  (T[\"text\"] extends object | true ? TextResponse : {}) &\n    (T[\"highlights\"] extends object | true ? HighlightsResponse : {}) &\n    (T[\"summary\"] extends object | true ? SummaryResponse : {}) &\n    (T[\"subpages\"] extends number ? SubpagesResponse<T> : {}) &\n    (T[\"extras\"] extends object ? ExtrasResponse : {}),\n  TextResponse\n  >;\n\n  /**\n   * Represents the cost breakdown related to contents retrieval. Fields are optional because\n   * only non-zero costs are included.\n   * @typedef {Object} CostDollarsContents\n   * @property {number} [text] - The cost in dollars for retrieving text.\n   * @property {number} [highlights] - The cost in dollars for retrieving highlights.\n   * @property {number} [summary] - The cost in dollars for retrieving summary.\n   */\nexport type CostDollarsContents = {\n  text?: number;\n  highlights?: number;\n  summary?: number;\n};\n\n/**\n * Represents the cost breakdown related to search. Fields are optional because\n * only non-zero costs are included.\n * @typedef {Object} CostDollarsSeearch\n * @property {number} [neural] - The cost in dollars for neural search.\n * @property {number} [keyword] - The cost in dollars for keyword search.\n */\nexport type CostDollarsSeearch = {\n  neural?: number;\n  keyword?: number;\n};\n\n/**\n * Represents the total cost breakdown. Only non-zero costs are included.\n * @typedef {Object} CostDollars\n * @property {number} total - The total cost in dollars.\n * @property {CostDollarsSeearch} [search] - The cost breakdown for search.\n * @property {CostDollarsContents} [contents] - The cost breakdown for contents.\n */\nexport type CostDollars = {\n  total: number;\n  search?: CostDollarsSeearch;\n  contents?: CostDollarsContents;\n};\n\n/**\n * Represents a search result object.\n * @typedef {Object} SearchResult\n * @property {string} title - The title of the search result.\n * @property {string} url - The URL of the search result.\n * @property {string} [publishedDate] - The estimated creation date of the content.\n * @property {string} [author] - The author of the content, if available.\n * @property {number} [score] - Similarity score between the query/url and the result.\n * @property {string} id - The temporary ID for the document.\n * @property {string} [image] - A representative image for the content, if any.\n * @property {string} [favicon] - A favicon for the site, if any.\n */\nexport type SearchResult<T extends ContentsOptions> = {\n  title: string | null;\n  url: string;\n  publishedDate?: string;\n  author?: string;\n  score?: number;\n  id: string;\n  image?: string;\n  favicon?: string;\n} & ContentsResultComponent<T>;\n\n/**\n * Represents a search response object.\n * @typedef {Object} SearchResponse\n * @property {Result[]} results - The list of search results.\n * @property {string} [autopromptString] - The autoprompt string, if applicable.\n * @property {string} [autoDate] - The autoprompt date, if applicable.\n * @property {string} requestId - The request ID for the search.\n * @property {CostDollars} [costDollars] - The cost breakdown for this request.\n */\nexport type SearchResponse<T extends ContentsOptions> = {\n  results: SearchResult<T>[];\n  autopromptString?: string;\n  autoDate?: string;\n  requestId: string;\n  costDollars?: CostDollars;\n};\n\n/**\n * Options for the answer endpoint\n * @typedef {Object} AnswerOptions\n * @property {boolean} [stream] - Whether to stream the response. Default false.\n * @property {boolean} [text] - Whether to include text in the source results. Default false.\n * @property {\"exa\" | \"exa-pro\"} [model] - The model to use for generating the answer. Default \"exa\".\n */\nexport type AnswerOptions = {\n  stream?: boolean;\n  text?: boolean;\n  model?: \"exa\" | \"exa-pro\";\n};\n\n/**\n * Represents an answer response object from the /answer endpoint.\n * @typedef {Object} AnswerResponse\n * @property {string} answer - The generated answer text.\n * @property {SearchResult<{}>[]} citations - The sources used to generate the answer.\n * @property {string} [requestId] - Optional request ID for the answer.\n */\nexport type AnswerResponse = {\n  answer: string;\n  citations: SearchResult<{}>[];\n  requestId?: string;\n};\n\nexport type AnswerStreamChunk = {\n  /**\n   * The partial text content of the answer (if present in this chunk).\n   */\n  content?: string;\n  /**\n   * Citations associated with the current chunk of text (if present).\n   */\n  citations?: Array<{\n    id: string;\n    url: string;\n    title?: string;\n    publishedDate?: string;\n    author?: string;\n    text?: string;\n  }>;\n};\n\n/**\n * Represents a streaming answer response chunk from the /answer endpoint.\n * @typedef {Object} AnswerStreamResponse\n * @property {string} [answer] - A chunk of the generated answer text.\n * @property {SearchResult<{}>[]]} [citations] - The sources used to generate the answer.\n */\nexport type AnswerStreamResponse = {\n  answer?: string;\n  citations?: SearchResult<{}>[];\n};\n\n/**\n * The Exa class encapsulates the API's endpoints.\n */\nclass Exa {\n  private baseURL: string;\n  private headers: Headers;\n\n  /**\n   * Helper method to separate out the contents-specific options from the rest.\n   */\n  private extractContentsOptions<T extends ContentsOptions>(options: T): {\n    contentsOptions: ContentsOptions;\n    restOptions: Omit<T, keyof ContentsOptions>;\n  } {\n    const {\n      text,\n      highlights,\n      summary,\n      subpages,\n      subpageTarget,\n      extras,\n      livecrawl,\n      livecrawlTimeout,\n      ...rest\n    } = options;\n\n    const contentsOptions: ContentsOptions = {};\n\n    // Default: if none of text, summary, or highlights is provided, we retrieve text\n    if (\n      text === undefined &&\n      summary === undefined &&\n      highlights === undefined &&\n      extras === undefined\n    ) {\n      contentsOptions.text = true;\n    }\n\n    if (text !== undefined) contentsOptions.text = text;\n    if (summary !== undefined) contentsOptions.summary = summary;\n    if (highlights !== undefined) contentsOptions.highlights = highlights;\n    if (subpages !== undefined) contentsOptions.subpages = subpages;\n    if (subpageTarget !== undefined) contentsOptions.subpageTarget = subpageTarget;\n    if (extras !== undefined) contentsOptions.extras = extras;\n    if (livecrawl !== undefined) contentsOptions.livecrawl = livecrawl;\n    if (livecrawlTimeout !== undefined) contentsOptions.livecrawlTimeout = livecrawlTimeout;\n\n    return {\n      contentsOptions,\n      restOptions: rest as Omit<T, keyof ContentsOptions>,\n    };\n  }\n\n  /**\n   * Constructs the Exa API client.\n   * @param {string} apiKey - The API key for authentication.\n   * @param {string} [baseURL] - The base URL of the Exa API.\n   */\n  constructor(apiKey?: string, baseURL: string = \"https://api.exa.ai\") {\n    this.baseURL = baseURL;\n    if (!apiKey) {\n      apiKey = process.env.EXASEARCH_API_KEY;\n      if (!apiKey) {\n        throw new Error(\n          \"API key must be provided as an argument or as an environment variable (EXASEARCH_API_KEY)\",\n        );\n      }\n    }\n    this.headers = new HeadersImpl({\n      \"x-api-key\": apiKey,\n      \"Content-Type\": \"application/json\",\n      \"User-Agent\": \"exa-node 1.4.0\",\n    });\n  }\n\n  /**\n   * Makes a request to the Exa API.\n   * @param {string} endpoint - The API endpoint to call.\n   * @param {string} method - The HTTP method to use.\n   * @param {any} [body] - The request body for POST requests.\n   * @returns {Promise<any>} The response from the API.\n   */\n  private async request(\n    endpoint: string,\n    method: string,\n    body?: any,\n  ): Promise<any> {\n    const response = await fetchImpl(this.baseURL + endpoint, {\n      method,\n      headers: this.headers,\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    if (!response.ok) {\n      const message = (await response.json()).error;\n      throw new Error(\n        `Request failed with status ${response.status}. ${message}`,\n      );\n    }\n\n    return await response.json();\n  }\n\n  /**\n   * Performs a search with an Exa prompt-engineered query.\n   * \n   * @param {string} query - The query string.\n   * @param {RegularSearchOptions} [options] - Additional search options\n   * @returns {Promise<SearchResponse<{}>>} A list of relevant search results.\n   */\n  async search(\n    query: string,\n    options?: RegularSearchOptions,\n  ): Promise<SearchResponse<{}>> {\n    return await this.request(\"/search\", \"POST\", { query, ...options });\n  }\n\n  /**\n   * Performs a search with an Exa prompt-engineered query and returns the contents of the documents.\n   * \n   * @param {string} query - The query string.\n   * @param {RegularSearchOptions & T} [options] - Additional search + contents options\n   * @returns {Promise<SearchResponse<T>>} A list of relevant search results with requested contents.\n   */\n  async searchAndContents<T extends ContentsOptions>(\n    query: string,\n    options?: RegularSearchOptions & T,\n  ): Promise<SearchResponse<T>> {\n    const { contentsOptions, restOptions } =\n      options === undefined\n        ? { contentsOptions: { text: true }, restOptions: {} }\n        : this.extractContentsOptions(options);\n\n    return await this.request(\"/search\", \"POST\", {\n      query,\n      contents: contentsOptions,\n      ...restOptions,\n    });\n  }\n\n  /**\n   * Finds similar links to the provided URL.\n   * @param {string} url - The URL for which to find similar links.\n   * @param {FindSimilarOptions} [options] - Additional options for finding similar links.\n   * @returns {Promise<SearchResponse<{}>>} A list of similar search results.\n   */\n  async findSimilar(\n    url: string,\n    options?: FindSimilarOptions,\n  ): Promise<SearchResponse<{}>> {\n    return await this.request(\"/findSimilar\", \"POST\", { url, ...options });\n  }\n\n  /**\n   * Finds similar links to the provided URL and returns the contents of the documents.\n   * @param {string} url - The URL for which to find similar links.\n   * @param {FindSimilarOptions & T} [options] - Additional options for finding similar links + contents.\n   * @returns {Promise<SearchResponse<T>>} A list of similar search results, including requested contents.\n   */\n  async findSimilarAndContents<T extends ContentsOptions>(\n    url: string,\n    options?: FindSimilarOptions & T,\n  ): Promise<SearchResponse<T>> {\n    const { contentsOptions, restOptions } =\n      options === undefined\n        ? { contentsOptions: { text: true }, restOptions: {} }\n        : this.extractContentsOptions(options);\n\n    return await this.request(\"/findSimilar\", \"POST\", {\n      url,\n      contents: contentsOptions,\n      ...restOptions,\n    });\n  }\n\n  /**\n   * Retrieves contents of documents based on URLs.\n   * @param {string | string[] | SearchResult[]} urls - A URL or array of URLs, or an array of SearchResult objects.\n   * @param {ContentsOptions} [options] - Additional options for retrieving document contents.\n   * @returns {Promise<SearchResponse<T>>} A list of document contents for the requested URLs.\n   */\n  async getContents<T extends ContentsOptions>(\n    urls: string | string[] | SearchResult<T>[],\n    options?: T,\n  ): Promise<SearchResponse<T>> {\n    if (!urls || (Array.isArray(urls) && urls.length === 0)) {\n      throw new Error(\"Must provide at least one URL\");\n    }\n\n    let requestUrls: string[];\n\n    if (typeof urls === \"string\") {\n      requestUrls = [urls];\n    } else if (typeof urls[0] === \"string\") {\n      requestUrls = urls as string[];\n    } else {\n      requestUrls = (urls as SearchResult<T>[]).map((result) => result.url);\n    }\n\n    const payload = {\n      urls: requestUrls,\n      ...options,\n    };\n\n    return await this.request(\"/contents\", \"POST\", payload);\n  }\n\n  /**\n   * Generate an answer to a query.\n   * @param {string} query - The question or query to answer.\n   * @param {AnswerOptions} [options] - Additional options for answer generation.\n   * @returns {Promise<AnswerResponse>} The generated answer and source references.\n   * \n   * Note: For streaming responses, use the `streamAnswer` method:\n   * ```ts\n   * for await (const chunk of exa.streamAnswer(query)) {\n   *   // Handle chunks\n   * }\n   * ```\n   */\n  async answer(\n    query: string,\n    options?: AnswerOptions,\n  ): Promise<AnswerResponse> {\n    if (options?.stream) {\n      throw new Error(\n        \"For streaming responses, please use streamAnswer() instead:\\n\\n\" +\n        \"for await (const chunk of exa.streamAnswer(query)) {\\n\" +\n        \"  // Handle chunks\\n\" +\n        \"}\"\n      );\n    }\n\n    // For non-streaming requests, make a regular API call\n    const requestBody = {\n      query,\n      stream: false,\n      text: options?.text ?? false,\n      model: options?.model ?? \"exa\"\n    };\n\n    return await this.request(\"/answer\", \"POST\", requestBody);\n  }\n\n  /**\n   * Stream an answer as an async generator\n   *\n   * Each iteration yields a chunk with partial text (`content`) or new citations.\n   * Use this if you'd like to read the answer incrementally, e.g. in a chat UI.\n   *\n   * Example usage:\n   * ```ts\n   * for await (const chunk of exa.streamAnswer(\"What is quantum computing?\", { text: false })) {\n   *   if (chunk.content) process.stdout.write(chunk.content);\n   *   if (chunk.citations) {\n   *     console.log(\"\\nCitations: \", chunk.citations);\n   *   }\n   * }\n   * ```\n   */\n  async *streamAnswer(\n    query: string,\n    options?: { text?: boolean; model?: \"exa\" | \"exa-pro\" }\n  ): AsyncGenerator<AnswerStreamChunk> {\n    // Build the POST body and fetch the streaming response.\n    const body = {\n      query,\n      text: options?.text ?? false,\n      stream: true,\n      model: options?.model ?? \"exa\"\n    };\n\n    const response = await fetchImpl(this.baseURL + \"/answer\", {\n      method: \"POST\",\n      headers: this.headers,\n      body: JSON.stringify(body),\n    });\n\n    if (!response.ok) {\n      const message = await response.text();\n      throw new Error(\n        `Request failed with status ${response.status}. ${message}`,\n      );\n    }\n\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error(\"No response body available for streaming.\");\n    }\n\n    const decoder = new TextDecoder();\n    let buffer = \"\";\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split(\"\\n\");\n        buffer = lines.pop() || \"\";\n\n        for (const line of lines) {\n          if (!line.startsWith(\"data: \")) continue;\n\n          const jsonStr = line.replace(/^data:\\s*/, \"\").trim();\n          if (!jsonStr || jsonStr === \"[DONE]\") {\n            continue;\n          }\n\n          let chunkData: any;\n          try {\n            chunkData = JSON.parse(jsonStr);\n          } catch (err) {\n            continue;\n          }\n\n          const chunk = this.processChunk(chunkData);\n          if (chunk.content || chunk.citations) {\n            yield chunk;\n          }\n        }\n      }\n\n      if (buffer.startsWith(\"data: \")) {\n        const leftover = buffer.replace(/^data:\\s*/, \"\").trim();\n        if (leftover && leftover !== \"[DONE]\") {\n          try {\n            const chunkData = JSON.parse(leftover);\n            const chunk = this.processChunk(chunkData);\n            if (chunk.content || chunk.citations) {\n              yield chunk;\n            }\n          } catch (e) {\n          }\n        }\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n\n  private processChunk(chunkData: any): AnswerStreamChunk {\n    let content: string | undefined;\n    let citations:\n      | Array<{\n          id: string;\n          url: string;\n          title?: string;\n          publishedDate?: string;\n          author?: string;\n          text?: string;\n        }>\n      | undefined;\n\n    if (chunkData.choices && chunkData.choices[0] && chunkData.choices[0].delta) {\n      content = chunkData.choices[0].delta.content;\n    }\n\n    if (chunkData.citations && chunkData.citations !== \"null\") {\n      citations = chunkData.citations.map((c: any) => ({\n        id: c.id,\n        url: c.url,\n        title: c.title,\n        publishedDate: c.publishedDate,\n        author: c.author,\n        text: c.text,\n      }));\n    }\n\n    return { content, citations };\n  }\n}\n\nexport default Exa;\n"],"mappings":"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","names":["fetch"]}