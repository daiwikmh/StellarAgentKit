"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/openai/index.ts
var index_exports = {};
__export(index_exports, {
  RecallAgentToolkit: () => RecallAgentToolkit
});
module.exports = __toCommonJS(index_exports);

// src/openai/toolkit.ts
var import_zod_to_json_schema = require("zod-to-json-schema");

// src/shared/api.ts
var import_chains = require("@recallnet/chains");
var import_client = require("@recallnet/sdk/client");

// src/shared/functions.ts
var import_viem = require("viem");
var getAccountInfo = async (recall, _context, params) => {
  try {
    const address = params.address ? params.address : void 0;
    const { result } = await recall.accountManager().info(address);
    if (!result) {
      return { success: false, error: "Failed to get account info" };
    }
    return { success: true, result };
  } catch (error) {
    if (error instanceof Error) {
      return {
        success: false,
        error: `Failed to get account info: ${error.message}`
      };
    }
    return {
      success: false,
      error: "Failed to get account info: Unknown error"
    };
  }
};
var listBuckets = async (recall, _context, params) => {
  try {
    const address = params.address ? params.address : void 0;
    const { result } = await recall.bucketManager().list(address);
    if (!result) {
      return { success: false, error: "Failed to list buckets" };
    }
    return { success: true, result };
  } catch (error) {
    if (error instanceof Error) {
      return {
        success: false,
        error: `Failed to list buckets: ${error.message}`
      };
    }
    return {
      success: false,
      error: "Failed to list buckets: Unknown error"
    };
  }
};
var getCreditInfo = async (recall, _context, params) => {
  try {
    const address = params.address ? params.address : void 0;
    const { result } = await recall.creditManager().getAccount(address);
    if (!result) {
      return { success: false, error: "Failed to get credit info" };
    }
    return { success: true, result };
  } catch (error) {
    if (error instanceof Error) {
      return {
        success: false,
        error: `Failed to get credit info: ${error.message}`
      };
    }
    return {
      success: false,
      error: "Failed to get credit info: Unknown error"
    };
  }
};
var buyCredit = async (recall, _context, params) => {
  try {
    const to = params.to ? params.to : void 0;
    const { meta } = await recall.creditManager().buy((0, import_viem.parseEther)(params.amount), to);
    if (!meta?.tx?.transactionHash) {
      return { success: false, error: "Transaction not found" };
    }
    return { success: true, result: meta.tx.transactionHash };
  } catch (error) {
    if (error instanceof Error) {
      return {
        success: false,
        error: `Failed to buy credit: ${error.message}`
      };
    }
    return { success: false, error: "Failed to buy credit: Unknown error" };
  }
};
var createBucket = async (recall, _context, params) => {
  try {
    const metadata = params.metadata ?? {};
    const { meta, result } = await recall.bucketManager().create({
      metadata: { alias: params.bucketAlias, ...metadata }
    });
    if (!meta?.tx || !result) {
      return { success: false, error: "Failed to create bucket" };
    }
    return {
      success: true,
      result: { bucket: result.bucket, txHash: meta.tx.transactionHash }
    };
  } catch (error) {
    if (error instanceof Error) {
      return {
        success: false,
        error: `Failed to create bucket: ${error.message}`
      };
    }
    return {
      success: false,
      error: "Failed to create bucket: Unknown error"
    };
  }
};
var getOrCreateBucket = async (recall, _context, params) => {
  try {
    const buckets = await recall.bucketManager().list();
    if (buckets?.result) {
      const bucket = buckets.result.find(
        (b) => b.metadata?.alias === params.bucketAlias
      );
      if (bucket) {
        return { success: true, result: { bucket: bucket.addr, tx: "" } };
      }
    }
    const metadata = params.metadata ?? {};
    const { result, meta } = await recall.bucketManager().create({
      metadata: { alias: params.bucketAlias, ...metadata }
    });
    if (!meta?.tx || !result) {
      return { success: false, error: "Transaction not found" };
    }
    return {
      success: true,
      result: { bucket: result.bucket, tx: meta.tx.transactionHash }
    };
  } catch (error) {
    if (error instanceof Error) {
      return {
        success: false,
        error: `Failed to get or create bucket: ${error.message}`
      };
    }
    return {
      success: false,
      error: "Failed to get or create bucket: Unknown error"
    };
  }
};
var addObject = async (recall, _context, params) => {
  try {
    const metadata = params.metadata ?? {};
    const data = new TextEncoder().encode(params.data);
    const { meta } = await recall.bucketManager().add(params.bucket, params.key, data, {
      overwrite: params.overwrite ?? false,
      metadata
    });
    if (!meta?.tx) {
      return { success: false, error: "Transaction not found" };
    }
    return { success: true, result: { txHash: meta.tx.transactionHash } };
  } catch (error) {
    if (error instanceof Error) {
      return {
        success: false,
        error: `Failed to add object: ${error.message}`
      };
    }
    return { success: false, error: "Failed to add object: Unknown error" };
  }
};
var getObject = async (recall, _context, params) => {
  try {
    const { result: object } = await recall.bucketManager().get(params.bucket, params.key);
    if (!object) {
      return { success: false, error: "Object not found" };
    }
    const result = new TextDecoder().decode(object);
    return { success: true, result };
  } catch (error) {
    if (error instanceof Error) {
      return {
        success: false,
        error: `Failed to get object: ${error.message}`
      };
    }
    return { success: false, error: "Failed to get object: Unknown error" };
  }
};
var queryObjects = async (recall, _context, params) => {
  try {
    const { result } = await recall.bucketManager().query(params.bucket, {
      prefix: params.prefix,
      delimiter: params.delimiter,
      startKey: params.startKey,
      limit: params.limit
    });
    if (!result) {
      return { success: false, error: "Failed to query objects" };
    }
    return { success: true, result };
  } catch (error) {
    if (error instanceof Error) {
      return {
        success: false,
        error: `Failed to query objects: ${error.message}`
      };
    }
    return { success: false, error: "Failed to query objects: Unknown error" };
  }
};

// src/shared/parameters.ts
var import_zod = require("zod");
var addressSchema = import_zod.z.string().regex(/^0x[a-fA-F0-9]{40}$/);
var getAccountInfoParameters = (_context = {}) => import_zod.z.object({
  address: addressSchema.optional().describe("The address of the account (EVM hex string address)")
});
var listBucketsParameters = (_context = {}) => import_zod.z.object({
  address: addressSchema.optional().describe(
    "The address of the account to list buckets for (EVM hex string address)"
  )
});
var getCreditInfoParameters = (_context = {}) => import_zod.z.object({
  address: addressSchema.optional().describe("The address of the account (EVM hex string address)")
});
var buyCreditParameters = (_context = {}) => import_zod.z.object({
  amount: import_zod.z.string().min(1).describe("The amount of credit to buy"),
  to: addressSchema.optional().describe(
    "The address of the account to buy credit for (EVM hex string address)"
  )
});
var createBucketParameters = (_context = {}) => import_zod.z.object({
  bucketAlias: import_zod.z.string().min(1).describe("The alias of the bucket to create"),
  metadata: import_zod.z.record(
    import_zod.z.string().min(1).describe("The key of the metadata"),
    import_zod.z.string().min(1).describe("The value of the metadata")
  ).optional().describe("The metadata to store with the bucket")
});
var getOrCreateBucketParameters = (_context = {}) => import_zod.z.object({
  bucketAlias: import_zod.z.string().describe("The alias of the bucket to retrieve or create"),
  metadata: import_zod.z.record(
    import_zod.z.string().min(1).describe("The key of the metadata"),
    import_zod.z.string().min(1).describe("The value of the metadata")
  ).optional().describe("The metadata to store with the bucket")
});
var addObjectParameters = (_context = {}) => import_zod.z.object({
  bucket: addressSchema.describe("The address of the bucket"),
  key: import_zod.z.string().min(1).describe("The key under which to store the object"),
  data: import_zod.z.string().describe("The data to store as a string value"),
  metadata: import_zod.z.record(
    import_zod.z.string().min(1).describe("The key of the metadata"),
    import_zod.z.string().min(1).describe("The value of the metadata")
  ).optional().describe("The metadata to store with the object"),
  overwrite: import_zod.z.boolean().optional().describe("Whether to overwrite existing data at that key")
});
var getObjectParameters = (_context = {}) => import_zod.z.object({
  bucket: addressSchema.describe("The address of the bucket"),
  key: import_zod.z.string().min(1).describe("The key under which the object is stored")
});
var queryObjectsParameters = (_context = {}) => import_zod.z.object({
  bucket: addressSchema.describe("The address of the bucket"),
  prefix: import_zod.z.string().min(1).optional().describe("The prefix of the objects to query"),
  delimiter: import_zod.z.string().min(1).optional().describe("The delimiter of the objects to query"),
  startKey: import_zod.z.string().min(1).optional().describe("The starting key of the objects to query"),
  limit: import_zod.z.number().min(1).optional().describe("The maximum number of objects to query")
});

// src/shared/prompts.ts
var getAccountInfoPrompt = (_context = {}) => `
Gets account information from Recall, including token $RECALL balances, address, and nonce.

Arguments:
- address (str, optional): The address of the account, else, defaults to the connected user's account address.

Returns the account's balance, address, and nonce information. 
`;
var listBucketsPrompt = (_context = {}) => `
Lists all buckets owned by the connected account in Recall.

Arguments:
- owner (str, optional): The address of the account, else, defaults to the connected user's account address.

Returns an array of buckets, each containing the bucket's address and metadata (which includes the alias, if present).
`;
var getCreditInfoPrompt = (_context = {}) => `
Gets the credit information for the connected account.

Arguments:
- address (str, optional): The address of the account, else, defaults to the connected user's account address.

Returns the account's credit balance and credit approval information (used for access control).
`;
var buyCreditPrompt = (_context = {}) => `
Buys credit for the connected account. Use this to purchase storage and computation credits.

Arguments:
- amount (str): The amount of credit to buy (denominated in RECALL tokens).
- to (str, optional): The address of the account to buy credit for, else, defaults to the connected user's account address.

Returns a transaction hash confirming the credit purchase.
`;
var createBucketPrompt = (_context = {}) => `
Creates a new bucket in Recall. Buckets are containers for storing objects and data.

Arguments:
- bucketAlias (str): The alias to assign to the new bucket. Choose a descriptive name for your use case.

Returns the new bucket's address (unique identifier) and the transaction hash at which it was created.
`;
var getOrCreateBucketPrompt = (_context = {}) => `
Gets an existing bucket by alias, or creates a new one if it doesn't exist. Use this to ensure you have a bucket for storage.

Arguments:
- bucketAlias (str): The alias of the bucket to retrieve or create.

Returns the bucket's address (unique identifier) and the transaction hash at which it was created.
`;
var addObjectPrompt = (_context = {}) => `
Adds an object to a bucket in Recall. Use this to store data like files, JSON, or raw bytes.

Arguments:
- bucket (str): The address of the bucket (EVM hex string address).
- key (str): The key under which to store the object. Use a descriptive path-like structure (e.g. "users/profile/avatar.jpg").
- data (str): The data to store as a string value.
- overwrite (bool, optional): Whether to overwrite existing data. Defaults to false.

Returns the transaction hash at which the object was stored.
`;
var getObjectPrompt = (_context = {}) => `
Gets an object from a bucket in Recall. Use this to retrieve previously stored data.

Arguments:
- bucket (str): The address of the bucket (EVM hex string address).
- key (str): The key under which the object is stored.

Returns the object's data as a string value.
`;
var queryObjectsPrompt = (_context = {}) => `
Queries objects from a bucket in Recall. Use this to list or search for stored objects matching certain criteria.

Arguments:
- bucket (str): The address of the bucket (EVM hex string address).
- prefix (str, optional): The prefix of the objects to query (e.g. "users/" to list all user-related objects).
- delimiter (str, optional): The delimiter of the objects to query (e.g. "/" to group by directory-like structure).
- startKey (str, optional): The starting key of the objects to query, useful for pagination.
- limit (int, optional): The maximum number of objects to return.

Returns an array of objects matching the query criteria, including keys, blake3 hashes, sizes, and storage information.
`;

// src/shared/tools.ts
var tools = (context) => [
  // Account read methods
  {
    method: "get_account_info",
    name: "Get Account Info",
    description: getAccountInfoPrompt(context),
    parameters: getAccountInfoParameters(context),
    actions: {
      account: {
        read: true
      }
    },
    execute: getAccountInfo
  },
  {
    method: "get_credit_info",
    name: "Get Credit Info",
    description: getCreditInfoPrompt(context),
    parameters: getCreditInfoParameters(context),
    actions: {
      account: {
        read: true
      }
    },
    execute: getCreditInfo
  },
  // Account write methods
  {
    method: "buy_credit",
    name: "Buy Credit",
    description: buyCreditPrompt(context),
    parameters: buyCreditParameters(context),
    actions: {
      account: {
        write: true
      }
    },
    execute: buyCredit
  },
  // Bucket read methods
  {
    method: "list_buckets",
    name: "List Buckets",
    description: listBucketsPrompt(context),
    parameters: listBucketsParameters(context),
    actions: {
      bucket: {
        read: true
      }
    },
    execute: listBuckets
  },
  {
    method: "get_object",
    name: "Get Object",
    description: getObjectPrompt(context),
    parameters: getObjectParameters(context),
    actions: {
      bucket: {
        read: true
      }
    },
    execute: getObject
  },
  {
    method: "query_objects",
    name: "Query Objects",
    description: queryObjectsPrompt(context),
    parameters: queryObjectsParameters(context),
    actions: {
      bucket: {
        read: true
      }
    },
    execute: queryObjects
  },
  // Bucket write methods
  {
    method: "create_bucket",
    name: "Create Bucket",
    description: createBucketPrompt(context),
    parameters: createBucketParameters(context),
    actions: {
      bucket: {
        write: true
      }
    },
    execute: createBucket
  },
  {
    method: "get_or_create_bucket",
    name: "Get or Create Bucket",
    description: getOrCreateBucketPrompt(context),
    parameters: getOrCreateBucketParameters(context),
    actions: {
      bucket: {
        read: true,
        write: true
      }
    },
    execute: getOrCreateBucket
  },
  {
    method: "add_object",
    name: "Add Object",
    description: addObjectPrompt(context),
    parameters: addObjectParameters(context),
    actions: {
      bucket: {
        write: true
      }
    },
    execute: addObject
  }
];

// src/shared/util.ts
function jsonStringify(obj) {
  return JSON.stringify(
    obj,
    (_, value) => typeof value === "bigint" ? value.toString() : value
  );
}

// src/shared/api.ts
var RecallAPI = class {
  _recall;
  _context;
  _tools;
  _serialize;
  /**
   * Create a new RecallAPI instance.
   * @param privateKey - The private key of the account to use.
   * @param context - The context to use, including the network name (e.g., `testnet` or `localnet`).
   * @param serializer - The serializer to use, which formats the return value of the method.
   * Defaults to `jsonStringify` (i.e.,`JSON.stringify` with `bigint`s converted to strings).
   */
  constructor(privateKey, context, serializer = jsonStringify) {
    const chain = context?.network !== void 0 && (0, import_chains.checkChainName)(context.network) ? (0, import_chains.getChain)(context.network) : import_chains.testnet;
    const walletClient = (0, import_client.walletClientFromPrivateKey)(privateKey, chain);
    const recallClient = new import_client.RecallClient({ walletClient });
    this._recall = recallClient;
    this._context = context || {};
    this._tools = tools(context);
    this._serialize = serializer;
  }
  /**
   * Get the tools available to the `RecallAPI` instance.
   * @returns The tools available to the `RecallAPI` instance.
   */
  getTools() {
    return this._tools;
  }
  /**
   * Run a method on the Recall network.
   * @param method - The method to run.
   * @param arg - The arguments to pass to the method.
   * @returns The result of the method.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async run(method, arg) {
    const tool = this._tools.find((t) => t.method === method);
    if (tool !== void 0) {
      const output = this._serialize(
        await tool.execute(this._recall, this._context, arg)
      );
      return output;
    } else {
      throw new Error(`Invalid method: ${method}`);
    }
  }
};

// src/shared/configuration.ts
var isToolAllowed = (tool, configuration) => {
  return Object.keys(tool.actions).every((resource) => {
    const permissions = tool.actions[resource];
    if (!permissions) {
      return false;
    }
    return Object.keys(permissions).every((permission) => {
      return configuration.actions?.[resource]?.[permission] === true;
    });
  });
};

// src/openai/toolkit.ts
var RecallAgentToolkit = class {
  /**
   * The Recall API instance used to interact with the Recall network.
   * @private
   */
  _recall;
  /**
   * The collection of tools available in this toolkit. Each tool is configured as an OpenAI
   * `ChatCompletionTool` that can be used in function calling scenarios.
   */
  tools;
  /**
   * Create a new RecallAgentToolkit instance.
   * @param privateKey - The private key of the account to use.
   * @param configuration - The {@link Configuration} to use.
   */
  constructor({
    privateKey,
    configuration
  }) {
    this._recall = new RecallAPI(privateKey, configuration.context);
    const filteredTools = this._recall.getTools().filter((tool) => isToolAllowed(tool, configuration));
    this.tools = filteredTools.map((tool) => ({
      type: "function",
      function: {
        name: tool.method,
        description: tool.description,
        parameters: (0, import_zod_to_json_schema.zodToJsonSchema)(tool.parameters)
      }
    }));
  }
  getTools() {
    return this.tools;
  }
  /**
   * Processes a single OpenAI tool call by executing the requested function.
   *
   * @param toolCall - The tool call object from OpenAI containing function name, arguments, and ID
   * @returns A promise that resolves to a tool message object containing the result of the tool
   * execution with the proper format for the OpenAI API
   */
  async handleToolCall(toolCall) {
    const args = JSON.parse(toolCall.function.arguments);
    const response = await this._recall.run(toolCall.function.name, args);
    return {
      role: "tool",
      tool_call_id: toolCall.id,
      content: response
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RecallAgentToolkit
});
//# sourceMappingURL=index.cjs.map