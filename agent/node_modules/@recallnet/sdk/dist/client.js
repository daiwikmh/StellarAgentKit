import {
  AccountManager
} from "./chunk-WVNS6GIJ.js";
import {
  BlobManager
} from "./chunk-2TI5PCTO.js";
import {
  BucketManager
} from "./chunk-O53TSO4E.js";
import {
  CreditManager
} from "./chunk-AFZSOILV.js";
import {
  SubnetId
} from "./chunk-MQVFN5CY.js";
import "./chunk-B5D5HBWE.js";
import "./chunk-DKAYJ4BL.js";
import "./chunk-DLYT7DCU.js";
import "./chunk-L7737TX2.js";

// src/client.ts
import {
  createPublicClient,
  createWalletClient,
  http
} from "viem";
import { privateKeyToAccount } from "viem/accounts";
import "viem/window";
import { getChain, testnet } from "@recallnet/chains";
var createPublicClientForChain = (chain) => createPublicClient({
  chain,
  transport: http()
});
var walletClientFromPrivateKey = (privateKey, chain) => {
  return createWalletClient({
    account: privateKeyToAccount(privateKey),
    chain,
    transport: http()
  });
};
var RecallClient = class _RecallClient {
  publicClient;
  walletClient;
  contractOverrides;
  subnetId;
  // TODO: this logic probably needs to be refactored to properly handle conflicts
  constructor(config = {}) {
    if (config.walletClient) this.walletClient = config.walletClient;
    if (config.publicClient) {
      this.publicClient = config.publicClient;
    } else {
      this.publicClient = config.walletClient ? _RecallClient.fromChain(config.walletClient.chain).publicClient : _RecallClient.fromChain().publicClient;
    }
    const chain = this.publicClient.chain;
    if (!chain) throw new Error("missing chain in provided client");
    this.subnetId = SubnetId.fromChain(chain);
    this.contractOverrides = config.contractOverrides ?? {};
  }
  // Creates a RecallClient from a chain
  static fromChain(chain = testnet) {
    return new _RecallClient({
      publicClient: createPublicClient({ chain, transport: http() })
    });
  }
  // Creates a RecallClient from a chain name
  static fromChainName(chainName = "testnet") {
    return new _RecallClient({
      publicClient: createPublicClient({
        chain: getChain(chainName),
        transport: http()
      })
    });
  }
  // Switches the chain for the client (e.g., from/to a parent and child subnet chain)
  async switchChain(chain) {
    this.publicClient = createPublicClientForChain(chain);
    if (!this.walletClient) return;
    const isBrowserWallet = this.walletClient.transport.type === "custom";
    if (isBrowserWallet) {
      await this.walletClient.switchChain({ id: chain.id });
    } else {
      this.walletClient = createWalletClient({
        chain,
        account: this.walletClient.account,
        transport: http()
      });
    }
  }
  // Returns the subnet ID for the client
  getSubnetId() {
    return this.subnetId;
  }
  // Creates an AccountManager for the client
  accountManager() {
    return new AccountManager(this);
  }
  // Creates a BlobManager for the client
  blobManager(contractAddress) {
    const override = contractAddress ?? this.contractOverrides.blobManager?.[this.publicClient.chain.id];
    return new BlobManager(this, override);
  }
  // Creates a BucketManager for the client
  bucketManager(contractAddress) {
    const override = contractAddress ?? this.contractOverrides.bucketManager?.[this.publicClient.chain.id];
    return new BucketManager(this, override);
  }
  // Creates a CreditManager for the client
  creditManager(contractAddress) {
    const override = contractAddress ?? this.contractOverrides.creditManager?.[this.publicClient.chain.id];
    return new CreditManager(this, override);
  }
};
export {
  RecallClient,
  createPublicClientForChain,
  walletClientFromPrivateKey
};
